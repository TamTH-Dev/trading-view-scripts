// 춸 tamth_
// @version=5
indicator("EzAlgo", overlay = true, max_bars_back = 5000, max_boxes_count = 500)


// Colors
color transparent_color = color.new(#000000, 100)
color white_color = color.white
color yellow_color = #F2E40A
color orange_color = #F2643A
color green_color = #16F9BA
color red_color = #F23A64
color aqua_color = #21BAF3
color purple_color = #5932e6
color light_gray_color = #6c757d
color dark_gray_color = #343a40
color green_color_40 = color.new(green_color, 60)
color red_color_40 = color.new(red_color, 60)
color aqua_color_30 = color.new(aqua_color, 70)
color purple_color_30 = color.new(purple_color, 70)
color txt_color = #EEEEEE





//** Volume Profile **//

// Inputs
string vp_grp = "Volume Profile"
bool vp_showed = input.bool(true, title = "Show", group = vp_grp)
int vp_prd = input.int(200, "Period", 1, 500, group = vp_grp)
int vp_smoothing = input.int(3, "Smoothing", 1, 6, group = vp_grp)
int vp_pivot = input.int(3, "Peak Sensitivity", 1, 10, group = vp_grp)
int vp_peak_thresh = input.int(80, "Peak Threshold", group = vp_grp)
int vp_offset = input.int(12, "Offset From Last Bar", group = vp_grp)
int vp_trans = input.int(60, "Transparency", 0, 100, group = vp_grp)
color vp_high_color = input.color(light_gray_color, "Histogram Colors", inline = "Histogram Colors", group = vp_grp)
color vp_low_color = input.color(dark_gray_color, "", inline = "Histogram Colors", group = vp_grp)
int vp_compaction_factor = input.int(3, "Compaction Factor", tooltip = "Compact volume profile", minval = 1, maxval = 6, group = vp_grp)


// Methods
method get_sin(int src, int bandwidth) =>
    if src == 0
        1
    else
        math.sin(math.pi * src / bandwidth) / (math.pi * src / bandwidth)

method get_multi_kernel_regression(float[] src, int prd)=>
    int size = array.size(src)
    float[] estimated_arr = array.new<float>(size)
    float cur_price = na

    for i = 0 to size - 1 
        float sum = 0
        float sumw = 0

        for j = 0 to size - 1 
            diff = i - j
            weight = get_sin(diff, prd)
            sum += array.get(src, j) * weight
            sumw += weight

        cur_price := sum / sumw
        array.set(estimated_arr, i, cur_price >= 0 ? cur_price : 0)

    estimated_arr

int vp_cnum = 100
float vp_top = ta.highest(vp_prd)
float vp_bot = ta.lowest(vp_prd)
float vp_step = (vp_top - vp_bot) / vp_cnum
float[] vp_levels = array.new_float(vp_cnum + 1)

for x = 0 to vp_cnum by 1
    array.set(vp_levels, x, vp_bot + vp_step * x)

method get_vol(float a, float b, float x, float y, float vol) =>
    // Bar is completely below or above the range
    if y < a or x > b
        0
    // Entire bar is inside the range but doesn"t span it
    else if x >= a and y <= b
        p_range = (y - x) / (b - a)
        p_range * vol
    // Bar completely covers the range
    else if x <= a and y >= b
        p_bar = (b - a) / (y - x)
        p_bar * vol
    // Top of the bar is inside the range
    else if x < a and y <= b
        p_bar = (y - a) / (y - x)
        p_bar * vol
    // Bottom of the bar is inside the range
    else if x >= a and y > b
        p_bar = (b - x) / (y - x)
        p_bar * vol
    else
        vol

var lines = array.new<line>()
var probs = array.new<box>()
var volus = array.new<box>()
var float line_float = na

if array.size(lines) > 0
    for i = array.size(lines) - 1 to 0
        line.delete(array.get(lines, i))
        array.remove(lines, i)

    for i = array.size(probs) - 1 to 0
        box.delete(array.get(probs, i))
        array.remove(probs, i)

    for i = array.size(volus) - 1 to 0
        box.delete(array.get(volus, i))
        array.remove(volus, i)
 
if barstate.islast and vp_showed
    float[] _vols = array.new_float(vp_cnum, 0.)
    float[] _bullish_vols = array.new_float(vp_cnum, 0.)
    int _trans = 100 - vp_trans

    for bars = 0 to vp_prd - 1 by 1
        float _high = high[bars]
        float _low = low[bars]
        float _vol = volume[bars]
        bool _is_bullish = open[bars] < close[bars]

        for x = 0 to vp_cnum - 1 by 1
            array.set(_vols, x, array.get(_vols, x) + get_vol(array.get(vp_levels, x), array.get(vp_levels, x + 1), _low, _high, _vol))
            
            if _is_bullish
                array.set(_bullish_vols, x, array.get(_bullish_vols, x) + get_vol(array.get(vp_levels, x), array.get(vp_levels, x + 1), _low, _high, _vol))
                            
    float[] colors = array.new_float(vp_cnum, 0.)

    for i = 0 to vp_cnum - 1
        float max_level = array.get(_vols, i)
        float bullish_level = array.get(_bullish_vols, i)
        array.set(colors, i, bullish_level / max_level)

    float max_vol = array.max(_vols)

    for x = 0 to vp_cnum - 1 by 1
        array.set(_vols, x, array.get(_vols, x) * vp_prd / (3 * max_vol))

    float[] normal_vols = get_multi_kernel_regression(_vols, vp_smoothing)
    int edge = bar_index + math.round(array.max(normal_vols) / vp_compaction_factor) + vp_offset
    var vol_bars = array.new_box(vp_cnum, na)

    for i = 0 to vp_cnum - 1 by 1
        box.delete(array.get(vol_bars, i))
        array.set(
         vol_bars, i,
         box.new(edge - math.round(array.get(normal_vols, i) / vp_compaction_factor), 
          array.get(vp_levels, i + 1), 
          edge, 
          array.get(vp_levels, i), 
          border_width = 0, 
          bgcolor = color.new(color.from_gradient(array.get(colors, i), 0, 1, color.new(vp_low_color, _trans), color.new(vp_high_color, _trans)), _trans))
         )





//** S/R **//

// Inputs
string sr_grp = "S/R"
bool sr_showed = input.bool(true, title = "Show", group = sr_grp)
int sr_prd = input.int(284, title = "Period", group = sr_grp)
color sr_support_color = input.color(green_color, title = "Support Color", group = sr_grp)
color sr_resistance_color = input.color(red_color, title = "Resistance Color", group = sr_grp)
int sr_strength = input.int(2, title = "Strength", minval = 1, group = sr_grp)
int sr_zone_width_percent = input.int(2, title = "Zone Width In %", minval = 0, group = sr_grp)
int sr_trans = input.int(88, title = "Transparent", group = sr_grp)


// Methods
method get_width_by_percent(int len, int perc) => (ta.highest(len) - ta.lowest(len)) * perc / 100

method get_sr_val_txt(float val) =>
    string prd = timeframe.period
    string tf = na

    if str.contains(prd, "S")
        tf := str.length(prd) == 1 ? '1S' : prd
    else if str.contains(prd, "D")
        tf := str.length(prd) == 1 ? '1D' : prd
    else if str.contains(prd, "W")
        tf := str.length(prd) == 1 ? '1W' : prd
    else if str.contains(prd, "M")
        tf := ''
    else
        float mins = str.tonumber(prd)

        if mins >= 60
            tf := str.format("{0}H",  mins / 60)
        else
            tf := str.format("{0}M",  mins)

    if tf == ''
        str.tostring(val)
    else
        str.format("{0} | {1}", tf, val)

method build_sr_val_box(float top, float bot, float val, float v_padding) =>
    int sr_txt_offset = bar_index + 20
    box.new(sr_txt_offset, top - v_padding / 5, sr_txt_offset + 200, bot + v_padding / 5, bgcolor = transparent_color, border_width = 0, text = get_sr_val_txt(val), text_color = txt_color, text_size = size.auto, text_valign = text.align_center, text_halign = text.align_left, extend = extend.right)

// Plots
int sr_size = 21
int sr_rb = 10
float sr_ph = ta.pivothigh(sr_rb, sr_rb)
float sr_pl = ta.pivotlow (sr_rb, sr_rb)
var sr_levels = array.new_float(sr_size, na)
float sr_highest_prd = ta.highest(sr_prd)
float sr_lowest_prd = ta.lowest(sr_prd)
float sr_channel_width = get_width_by_percent(sr_prd, 10)
float sr_zone_width = get_width_by_percent(300, sr_zone_width_percent)
bool[] sr_aas = array.new_bool(41, true)
float sr_highest_ph = 0.0, sr_highest_ph := sr_highest_ph[1]
float sr_lowest_pl = 0.0, sr_lowest_pl := sr_lowest_pl[1]
var sr_levels_tmp = array.new_float(sr_size, na)
var sr_lines = array.new_line(sr_size, na)
var sr_lines_h = array.new_line(sr_size, na)
var sr_lines_l = array.new_line(sr_size, na)
var sr_lines_f = array.new_linefill(sr_size, na)
var sr_boxes = array.new_box(sr_size, na)

if (sr_ph or sr_pl) and sr_showed
    for i = 0 to array.size(sr_levels) - 1
        array.set(sr_levels, i, na)

    sr_highest_ph := sr_lowest_prd
    sr_lowest_pl := sr_highest_prd
    int pp_count = 0

    for i = 0 to sr_prd
        if na(close[i])
            break

        if not na(sr_ph[i]) or not na(sr_pl[i])
            sr_highest_ph := math.max(sr_highest_ph, nz(sr_ph[i], sr_lowest_prd), nz(sr_pl[i], sr_lowest_prd))
            sr_lowest_pl := math.min(sr_lowest_pl, nz(sr_ph[i], sr_highest_prd), nz(sr_pl[i], sr_highest_prd))
            pp_count += 1

            if pp_count > 40
                break

            if array.get(sr_aas, pp_count)
                upl = (sr_ph[i] ? high[i + sr_rb] : low[i + sr_rb]) + sr_channel_width
                dnl = (sr_ph[i] ? high[i + sr_rb] : low[i + sr_rb]) - sr_channel_width
                tmp = array.new_bool(41, true)
                count = 0
                points = 0

                for j = 0 to sr_prd
                    if na(close[j])
                        break

                    if not na(sr_ph[j]) or not na(sr_pl[j])
                        chg = false
                        count += 1

                        if count > 40
                            break

                        if array.get(sr_aas, count)
                            if not na(sr_ph[j])
                                if high[j + sr_rb] <= upl and high[j + sr_rb] >= dnl
                                    points += 1
                                    chg := true

                            if not na(sr_pl[j])
                                if low[j + sr_rb] <= upl and low[j + sr_rb] >= dnl
                                    points += 1
                                    chg := true

                        if chg and count < 41
                            array.set(tmp, count, false)

                if points >= sr_strength
                    for g = 0 to 40 by 1
                        if not array.get(tmp, g)
                            array.set(sr_aas, g, false)

                    if sr_ph[i] and pp_count < sr_size
                        array.set(sr_levels, pp_count, high[i + sr_rb])

                    if sr_pl[i] and pp_count < sr_size
                        array.set(sr_levels, pp_count, low[i + sr_rb])

if sr_showed
    var line sr_highest_fill_1 = na, line.delete(sr_highest_fill_1)
    var line sr_highest_fill_2 = na, line.delete(sr_highest_fill_2)
    var line sr_lowest_fill_1 = na, line.delete(sr_lowest_fill_1)
    var line sr_lowest_fill_2 = na, line.delete(sr_lowest_fill_2)
    var box sr_highest_box_1 = na, box.delete(sr_highest_box_1)
    var box sr_highest_box_2 = na, box.delete(sr_highest_box_2)
    color sr_high_color = close >= sr_highest_ph ? sr_support_color : sr_resistance_color
    color sr_low_color = close >= sr_lowest_pl ? sr_support_color : sr_resistance_color
    sr_highest_fill_1 := line.new(bar_index - 311, sr_highest_ph + sr_zone_width, bar_index, sr_highest_ph + sr_zone_width, xloc.bar_index, extend.both, na)
    sr_highest_fill_2 := line.new(bar_index - 311, sr_highest_ph - sr_zone_width, bar_index, sr_highest_ph - sr_zone_width, xloc.bar_index, extend.both, na)
    sr_lowest_fill_1 := line.new(bar_index - 311, sr_lowest_pl + sr_zone_width, bar_index, sr_lowest_pl + sr_zone_width, xloc.bar_index, extend.both, na)
    sr_lowest_fill_2 := line.new(bar_index - 311, sr_lowest_pl - sr_zone_width, bar_index, sr_lowest_pl - sr_zone_width, xloc.bar_index, extend.both, na)
    linefill.new(sr_highest_fill_1, sr_highest_fill_2, color.new(sr_high_color, sr_trans))
    linefill.new(sr_lowest_fill_1, sr_lowest_fill_2 , color.new(sr_low_color, sr_trans))
    sr_highest_box_1 := build_sr_val_box(sr_highest_ph + sr_zone_width, sr_highest_ph - sr_zone_width, sr_highest_ph, sr_zone_width)
    sr_highest_box_2 := build_sr_val_box(sr_lowest_pl + sr_zone_width, sr_lowest_pl - sr_zone_width, sr_lowest_pl, sr_zone_width)


    if sr_ph or sr_pl
        for i = 0 to array.size(sr_lines) - 1
            array.set(sr_levels_tmp, i, array.get(sr_levels, i))

    for i = 0 to array.size(sr_lines) - 1
        line.delete(array.get(sr_lines, i))
        line.delete(array.get(sr_lines_h, i))
        line.delete(array.get(sr_lines_l, i))
        linefill.delete(array.get(sr_lines_f, i))
        box.delete(array.get(sr_boxes, i))

        if array.get(sr_levels_tmp, i)
            color line_color = close >= array.get(sr_levels_tmp, i) ? sr_support_color : sr_resistance_color
            float level = array.get(sr_levels_tmp, i)
            float top_line = level + sr_zone_width
            float bot_line = level - sr_zone_width
            bool top_line_existed = math.abs(level - sr_highest_ph) < sr_zone_width
            bool bot_line_existed = math.abs(level - sr_lowest_pl) < sr_zone_width

            if (not top_line_existed and not bot_line_existed)
                array.set(sr_lines_h, i, line.new(bar_index - 355, top_line, bar_index, top_line, xloc.bar_index, extend.both, na))
                array.set(sr_lines_l, i, line.new(bar_index - 355, bot_line, bar_index, bot_line, xloc.bar_index, extend.both, na))
                array.set(sr_lines_f, i, linefill.new(array.get(sr_lines_h, i), array.get(sr_lines_l, i), color.new(line_color, sr_trans)))
                array.set(sr_boxes, i, build_sr_val_box(top_line, bot_line, level, sr_zone_width))





//** Signals **//

// Inputs
string buy_sell_grp = "Buy & Sell Signals"
bool buy_sell_signals_showed = input.bool(true, title = "Show", group = buy_sell_grp)
float sensitivity = input.float(1.7, title = "Sensitivity", minval = 1, maxval = 6, group = buy_sell_grp)
string trend_ribbon_grp = "Trend Ribbon"
bool ribbon_showed = input.bool(true, title = "Show", group = trend_ribbon_grp)
int ribbon_leading_smoothing = input.int(5, title = "Leading Smoothing", minval = 1, group = trend_ribbon_grp)
int ribbon_lagging_smoothing = input.int(8, title = "Lagging Smoothing", minval = 1, group = trend_ribbon_grp)
string reversal_bands_grp = "Reversal Bands"
bool rev_bands_showed = input.bool(true, "Show", group = reversal_bands_grp)
int rev_bands_prd = input.int(30, "Period", group = reversal_bands_grp)
string custom_bar_colors_grp = "Custom Bar Colors"
bool custom_bar_colors_used = input.bool(true, "Use", group = custom_bar_colors_grp)


// Methods
method smooth_rng(float src, int prd, float mult) =>
    float rng_avg = ta.ema(math.abs(src - src[1]), prd)
    ta.ema(rng_avg, prd * 2 - 1) * mult

method filter_rng(float src, float rng) =>
    float rng_src = src
    rng_src := src > nz(rng_src[1]) ? src - rng < nz(rng_src[1]) ? nz(rng_src[1]) : src - rng : src + rng > nz(rng_src[1]) ? nz(rng_src[1]) : src + rng

method get_wt(float src, int chl_prd, int avg_prd) =>
    float esa = ta.ema(src, chl_prd)
    float d = ta.ema(math.abs(src - esa), chl_prd)
    float ci = (src - esa) / (0.015 * d)
    float leading_wt = ta.ema(ci, avg_prd)
    float lagging_wt = ta.sma(leading_wt, 3)
    [leading_wt, lagging_wt]

method get_rev_bands(float src, int prd, float sensitivity) =>
    basis = ta.sma(src, prd)
    span = ta.atr(prd)
    [basis + span * sensitivity, basis - span * sensitivity]


float src = close
float leading_range = smooth_rng(src, 27, 1.5)
float lagging_range = smooth_rng(src, 55, sensitivity)
float avg_range = (leading_range + lagging_range) / 2
float clean_range = filter_rng(src, avg_range)
float up_signal = 0.0, up_signal := clean_range > clean_range[1] ? nz(up_signal[1]) + 1 : clean_range < clean_range[1] ? 0 : nz(up_signal[1])
float dn_signal = 0.0, dn_signal := clean_range < clean_range[1] ? nz(dn_signal[1]) + 1 : clean_range > clean_range[1] ? 0 : nz(dn_signal[1])
bool bullish_cond = bool(na), bullish_cond := src > clean_range and src > src[1] and up_signal > 0 or src > clean_range and src < src[1] and up_signal > 0
bool bearish_cond = bool(na), bearish_cond := src < clean_range and src < src[1] and dn_signal > 0 or src < clean_range and src > src[1] and dn_signal > 0
int final_cond = 0, final_cond := bullish_cond ? 1 : bearish_cond ? -1 : final_cond[1]
bool is_bullish = bullish_cond and final_cond[1] == -1
bool is_bearish = bearish_cond and final_cond[1] == 1
[leading_wt, lagging_wt] = get_wt(hlc3, 9, 12)
[upper_rev_s_band, lower_rev_s_band] = get_rev_bands(close, rev_bands_prd, 3)
[upper_rev_m_band, lower_rev_m_band] = get_rev_bands(close, rev_bands_prd, 4)
[upper_rev_l_band, lower_rev_l_band] = get_rev_bands(close, rev_bands_prd, 5)


// Plots
barcolor(custom_bar_colors_used ? (up_signal > dn_signal ? aqua_color : purple_color) : na, title = "Custom Bar Colors", editable = false)

bool has_mild_buy_signal = ta.crossover(leading_wt, lagging_wt) and lagging_wt <= -53
bool has_mild_sell_signal = ta.crossunder(leading_wt, lagging_wt) and lagging_wt >= 53
bool consistent_buy_signal = is_bullish and has_mild_buy_signal
bool consistent_sell_signal = is_bearish and has_mild_sell_signal
plotshape(buy_sell_signals_showed and is_bullish and not consistent_buy_signal, title = "Bullish Buy Signal" , style = shape.triangleup, location = location.belowbar, color = aqua_color, size = size.small, display = display.pane)
plotshape(buy_sell_signals_showed and is_bearish and not consistent_sell_signal, title = "Bearish Sell Signal", style = shape.triangledown, location = location.abovebar, color = purple_color, size = size.small, display = display.pane)
plotshape(buy_sell_signals_showed and has_mild_buy_signal and not consistent_buy_signal, title = "Mild Buy Signal" , style = shape.xcross, location = location.belowbar, color = green_color, size = size.tiny, display = display.pane)
plotshape(buy_sell_signals_showed and has_mild_sell_signal and not consistent_sell_signal, title = "Mild Sell Signal", style = shape.xcross, location = location.abovebar, color = red_color, size = size.tiny, display = display.pane)
plotshape(buy_sell_signals_showed and consistent_buy_signal, title = "Same Buy Signal" , style = shape.diamond, location = location.belowbar, color = yellow_color, size = size.small, display = display.pane)
plotshape(buy_sell_signals_showed and consistent_sell_signal, title = "Same Sell Signal", style = shape.diamond, location = location.abovebar, color = orange_color, size = size.small, display = display.pane)

plot(rev_bands_showed ? upper_rev_s_band : na, title = "Upper Reversal Short Band", color = red_color_40, display = display.pane)
plot(rev_bands_showed ? upper_rev_m_band : na, title = "Upper Reversal Medium Band", color = red_color_40, display = display.pane)
plot(rev_bands_showed ? upper_rev_l_band : na, title = "Upper Reversal Long Band", color = red_color_40, display = display.pane)
plot(rev_bands_showed ? lower_rev_l_band : na, title = "Lower Reversal Long Band", color = green_color_40, display = display.pane)
plot(rev_bands_showed ? lower_rev_m_band : na, title = "Lower Reversal Medium Band", color = green_color_40, display = display.pane)
plot(rev_bands_showed ? lower_rev_s_band : na, title = "Lower Reversal Short Band", color = green_color_40, display = display.pane)

float leading_ribbon = ta.sma(close, ribbon_leading_smoothing)
float lagging_ribbon = ta.sma(close, ribbon_lagging_smoothing)
fill(plot(ribbon_showed ? leading_ribbon : na, "", na, editable = false, display = display.pane), plot(ribbon_showed ? lagging_ribbon : na, "", na, editable = false, display = display.pane), color = leading_ribbon > lagging_ribbon ? aqua_color_30 : purple_color_30, title = "Ribbon Fill Color")





//** Master Pattern **//

// Inputs
// string mp_grp = "Master Pattern"
// int mp_contraction_lookback = input.int(3, "Contraction Detection Lookback", minval = 1, group = mp_grp)
// int mp_liq_levels = input.int(20, "Liquidity Levels", minval = 1, group = mp_grp)
// bool mp_major_showed = input.bool(true, "Show Major Pattern", group = mp_grp)
// bool mp_minor_showed = input.bool(true, "Show Minor Pattern", group = mp_grp)
// color mp_bullish_color = input.color(green_color_40, "Bullish Pattern", inline = "Bullish Pattern", group = mp_grp)
// bool mp_bullish_box_showed = input.bool(true, "Area", inline = "bull", group = mp_grp)
// bool mp_bullish_line_showed = input.bool(true, "Line", inline = "bull", group = mp_grp)
// color mp_bearish_color = input.color(red_color_40, "Bearish Pattern", inline = "Bearish Pattern", group = mp_grp)
// bool mp_bearish_box_showed = input.bool(true, "Area", inline = "bear", group = mp_grp)
// bool mp_bearish_line_showed = input.bool(true, "Line", inline = "bear", group = mp_grp)
// bool mp_liq_levels_showed = input.bool(true, "Show Liquidity Levels", group = mp_grp)
// color mp_bullish_liq_color = input.color(green_color_40, "Upper Liquidity", group = mp_grp)
// color mp_bearish_liq_color = input.color(red_color_40, "Lower Liquidity", group = mp_grp)

// type master_pattern
//     box area
//     line avg
//     bool break_up
//     bool break_down

// var mp_phy = 0., var mp_phx = 0, var mp_pht = 0.
// var mp_ply = 0., var mp_plx = 0, var mp_plt = 0.
// var float mp_top = na
// var float mp_btm = na
// int mp_bar_idx = bar_index
// float mp_ph = ta.pivothigh(mp_contraction_lookback, mp_contraction_lookback)
// float mp_pl = ta.pivotlow(mp_contraction_lookback, mp_contraction_lookback)

// if mp_ph
//     mp_pht := math.sign(mp_ph - mp_phy)
//     mp_phy := mp_ph

//     if mp_pht == -1 and mp_plt == 1
//         mp_top := mp_ph
//         mp_btm := mp_ply
//         mp_phx := mp_bar_idx - mp_contraction_lookback

// if mp_pl
//     mp_plt := math.sign(mp_pl - mp_ply)
//     mp_ply := mp_pl

//     if mp_pht  == -1 and mp_plt == 1
//         mp_top := mp_phy
//         mp_btm := mp_pl
//         mp_plx := mp_bar_idx - mp_contraction_lookback

// var master_pattern master = master_pattern.new()
// bool mp_is_bullish = high[mp_contraction_lookback] > mp_top and mp_top > mp_btm
// bool mp_is_bearish = low[mp_contraction_lookback] < mp_btm and mp_top > mp_btm

// if mp_is_bullish or mp_is_bearish
//     color style_color = mp_is_bullish ? mp_bullish_color : mp_bearish_color
//     master.avg.set_x2(mp_bar_idx - mp_contraction_lookback)
//     val = math.avg(mp_top, mp_btm)

//     master := master_pattern.new(
//       (mp_is_bullish and mp_bullish_box_showed) or (mp_is_bearish and mp_bearish_box_showed) ? box.new(math.max(mp_phx, mp_plx), mp_top, mp_bar_idx - mp_contraction_lookback, mp_btm, na, bgcolor = mp_minor_showed ? color.new(style_color, 80) : na) : na
//       , (mp_is_bullish and mp_bullish_line_showed) or (mp_is_bearish and mp_bearish_line_showed) ? line.new(mp_bar_idx - mp_contraction_lookback, val, mp_bar_idx, val, color = mp_minor_showed ? style_color : na) : na
//       , mp_is_bullish
//       , mp_is_bearish)
//     mp_top := na
//     mp_btm := na

// if master.break_up
//     if low < master.area.get_bottom()
//         if not mp_major_showed
//             master.area.delete()
//             master.avg.delete()
//         else
//             master.area.set_border_color(mp_bullish_color)

//             if not mp_minor_showed
//                 master.area.set_bgcolor(color.new(mp_bullish_color, 50))
//                 master.avg.set_color(mp_bullish_color)
// else if master.break_down
//     if high > master.area.get_top()
//         if not mp_major_showed
//             master.area.delete()
//             master.avg.delete()
//         else
//             master.area.set_border_color(mp_bearish_color)

//             if not mp_minor_showed
//                 master.area.set_bgcolor(color.new(mp_bearish_color, 50))
//                 master.avg.set_color(mp_bearish_color)

// if not na(master.avg)
//     master.avg.set_x2(mp_bar_idx)

// var line mp_liq_up = na, var mp_liq_up_reach = false
// var line mp_liq_dn = na, var mp_liq_dn_reach = false
// float mp_liq_ph = ta.pivothigh(mp_liq_levels, mp_liq_levels)
// float mp_liq_pl = ta.pivotlow(mp_liq_levels, mp_liq_levels)

// if mp_liq_ph and mp_liq_levels_showed
//     if not mp_liq_up_reach
//         mp_liq_up.set_x2(mp_bar_idx - mp_liq_levels)

//     mp_liq_up := line.new(mp_bar_idx - mp_liq_levels, mp_liq_ph, mp_bar_idx, mp_liq_ph, color = mp_bullish_liq_color, style = line.style_dotted)
//     mp_liq_up_reach := false
// else if not mp_liq_up_reach and mp_liq_levels_showed
//     mp_liq_up.set_x2(mp_bar_idx)

//     if high > mp_liq_up.get_y1()
//         mp_liq_up_reach := true

// if mp_liq_pl and mp_liq_levels_showed
//     if not mp_liq_dn_reach
//         mp_liq_dn.set_x2(mp_bar_idx - mp_liq_levels)

//     mp_liq_dn := line.new(mp_bar_idx - mp_liq_levels, mp_liq_pl, mp_bar_idx, mp_liq_pl, color = mp_bearish_liq_color, style = line.style_dotted)
//     mp_liq_dn_reach := false
// else if not mp_liq_dn_reach and mp_liq_levels_showed
//     mp_liq_dn.set_x2(mp_bar_idx)

//     if low < mp_liq_dn.get_y1()
//         mp_liq_dn_reach := true





//** Dashboard **//

// Inputs
string db_grp = "Dashboard"
bool db_showed = input.bool(true, "Show Dashboard", group = db_grp)
string db_location = input.string("Bottom Right", "Table Location", ["Top Right", "Middle Right", "Bottom Right", "Top Center", "Middle Center", "Bottom Center", "Top Left", "Middle Left", "Bottom Left"], group = db_grp)
color db_txt_color = input.color(txt_color, "Table Text Color", group = db_grp)
color db_bg_color = input.color(#1A1A1A, "Table Background Color", group = db_grp)
string db_size = input.string("Small", "Table Size", ["Large", "Normal", "Small", "Tiny"], group = db_grp)

var _db_location = db_location == "Top Right" ? position.top_right : db_location == "Middle Right" ? position.middle_right : db_location == "Bottom Right" ? position.bottom_right : db_location == "Top Center" ? position.top_center : db_location == "Middle Center" ? position.middle_center : db_location == "Bottom Center" ? position.bottom_center : db_location == "Top Left" ? position.top_left : db_location == "Middle Left" ? position.middle_left : position.bottom_left
var _db_size = db_size == "Large" ? size.large : db_size == "Normal" ? size.normal : db_size == "Small" ? size.small : size.tiny
var db_instance = db_showed ? table.new(_db_location, 2, 15, db_bg_color, #000000, 2, db_bg_color, 1) : na


// Methods
get_res_in_mins_by_tf() =>
    float _res_in_mins = timeframe.multiplier * (timeframe.isseconds ? 1 : timeframe.isminutes ? 1. : timeframe.isdaily ? 60. * 24 : timeframe.isweekly  ? 60. * 24 * 7 : timeframe.ismonthly ? 60. * 24 * 30.4375 : na)

build_db_cell(col, row, txt, signal = false) => table.cell(db_instance, col, row, txt, 0, 0, signal ? #000000 : db_txt_color, text_size = _db_size)
build_db_cell_bg(col, row, color) => table.cell_set_bgcolor(db_instance, col, row, color)

is_equal_tf(res) => str.tonumber(res) == get_res_in_mins_by_tf() and not timeframe.isseconds
is_higher_tf(res) => str.tonumber(res) > get_res_in_mins_by_tf() or timeframe.isseconds
is_too_small_tf(res) => (timeframe.isweekly and res == "1") or (timeframe.ismonthly and str.tonumber(res) < 10)

method get_bullish_status_by_tf(string sym, string res, bool is_ema_bullish) =>
    bool _is_bullish = na
    _is_bullish := is_equal_tf(res) ? is_ema_bullish : _is_bullish
    _is_bullish := is_higher_tf(res) ? request.security(sym, res, is_ema_bullish, barmerge.gaps_off, barmerge.lookahead_on) : _is_bullish
    _is_bullish_arr = request.security_lower_tf(syminfo.tickerid, is_higher_tf(res) ? str.tostring(get_res_in_mins_by_tf()) + (timeframe.isseconds ? "S" : "") : is_too_small_tf(res) ? (timeframe.isweekly ? "3" : "10") : res, is_ema_bullish)
    
    if array.size(_is_bullish_arr) > 1 and not is_equal_tf(res) and not is_higher_tf(res)
        _is_bullish := array.pop(_is_bullish_arr)

    array.clear(_is_bullish_arr)
    _is_bullish

bool is_ema_bullish = close > ta.ema(close, 144)
tf_30_status = get_bullish_status_by_tf(syminfo.tickerid, "30", is_ema_bullish)
tf_60_status = get_bullish_status_by_tf(syminfo.tickerid, "60", is_ema_bullish)
tf_240_status = get_bullish_status_by_tf(syminfo.tickerid, "240", is_ema_bullish)
tf_480_status = get_bullish_status_by_tf(syminfo.tickerid, "480", is_ema_bullish)
tf_720_status = get_bullish_status_by_tf(syminfo.tickerid, "720", is_ema_bullish)
tf_daily_status = get_bullish_status_by_tf(syminfo.tickerid, "1440", is_ema_bullish)
// tf_weekly_status = get_bullish_status_by_tf(syminfo.tickerid, "10080", is_ema_bullish)


// Plots
if barstate.islast and db_showed
    build_db_cell(0, 0, "Timeframe")
    build_db_cell(0, 1, "30M")
    build_db_cell(0, 2, "1H")
    build_db_cell(0, 3, "4H")
    build_db_cell(0, 4, "8H")
    build_db_cell(0, 5, "12H")
    build_db_cell(0, 6, "Daily")
    // build_db_cell(0, 7, "Weekly")
    build_db_cell(1, 0, "Bias")
    build_db_cell(1, 1, tf_30_status ? "游릭" : "游댮", true)
    build_db_cell(1, 2, tf_60_status ? "游릭" : "游댮", true)
    build_db_cell(1, 3, tf_240_status ? "游릭" : "游댮", true)
    build_db_cell(1, 4, tf_480_status ? "游릭" : "游댮", true)
    build_db_cell(1, 5, tf_720_status ? "游릭" : "游댮", true)
    build_db_cell(1, 6, tf_daily_status ? "游릭" : "游댮", true)
    // build_db_cell(1, 7, tf_weekly_status ? "游릭" : "游댮", true)