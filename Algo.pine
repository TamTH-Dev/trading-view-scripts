// Â© tamth_
// @version=5
indicator("Algo", shorttitle = "Algo", overlay = true, max_bars_back = 5000, max_lines_count = 500, max_boxes_count = 500, max_labels_count = 500)


//-----------------------------------------------------------------------------*
//  Constants
//-----------------------------------------------------------------------------{
color TRANSPARENT_COLOR = color.new(#000000, 100)
color WHITE_COLOR = #EFEFEF
color RED_COLOR = #E81E61
color AQUA_COLOR = #04ADBF
color YELLOW_COLOR = #E8D81E
color PURPLE_COLOR = #764AF1
color ORANGE_COLOR = #E8AF1E
color GREEN_COLOR = #1EE8A3
color BLUE_COLOR = #1E53E8
color PINK_COLOR = #C31EE8
color LIGHT_GRAY_COLOR = #364156
color DARK_GRAY_COLOR = #212d40


//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Common Variables
//-----------------------------------------------------------------------------{
series int barIdx = bar_index
series bool confirmed = barstate.isconfirmed

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Common Methods
//-----------------------------------------------------------------------------{
debug(simple string txt) =>
    // Create label on the first bar
    var label = label.new(barIdx, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, WHITE_COLOR, size.large, text.align_left)
    // On next bars, update the label"s x and y position, and the text it displays
    label.set_xy(label, barIdx, ta.highest(10)[1])
    label.set_text(label, txt)

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Range Filter
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string rfGrp = "Range Filter"
bool rfShowed = input.bool(false, title = "Show Range Filter", group = rfGrp)
float rngQty = input.float(2.618, title = "Range Size", minval = 0.0000001, group = rfGrp)
string rngScale = input.string("Average Change", title = "Range Scale", options = ["Points", "Pips", "Ticks", "% of Price", "ATR", "Average Change", "Standard Deviation", "Absolute"], group = rfGrp)
int rngPer = input.int(14, title = "Range Period (for ATR, Average Change, and Standard Deviation)", minval = 1, group = rfGrp)
bool rngSmoothRange = input.bool(true, title = "Smooth Range", group = rfGrp)
int rngSmoothPrd = input.int(27, title = "Smoothing Period", minval = 1, group = rfGrp)

//-----------------------------------------------------------------------------*
// Functions
//-----------------------------------------------------------------------------{
getCondEma(x, cond, n)=>
    var val = array.new_float(0)
    var emaVal = array.new_float(1)
    if cond
        array.push(val, x)
        if array.size(val) > 1
            array.remove(val, 0)
        if na(array.get(emaVal, 0))
            array.fill(emaVal, array.get(val, 0))
        array.set(emaVal, 0, (array.get(val, 0) - array.get(emaVal, 0)) * (2 / (n + 1)) + array.get(emaVal, 0))
    series float ema = array.get(emaVal, 0)
    ema

getCondSma(x, cond, n)=>
    var vals = array.new_float(0)
    if cond
        array.push(vals, x)
        if array.size(vals) > n
            array.remove(vals, 0)
    series float sma = array.avg(vals)
    sma

getStdev(x, n)=>
    math.sqrt(getCondSma(math.pow(x, 2), 1, n) - math.pow(getCondSma(x, 1, n), 2))

getRngSize(x, scale, qty, n)=> 
    series float atr = getCondEma(ta.tr(true), 1, n)
    series float ac = getCondEma(math.abs(x - x[1]), 1, n)
    series float sd = getStdev(x, n)
    rngSize = scale == "Pips" ? qty * 0.0001 : scale == "Points" ? qty * syminfo.pointvalue : scale == "% of Price" ? close * qty / 100 : scale == "ATR" ? qty * atr :
               scale == "Average Change" ? qty * ac : scale == "Standard Deviation" ? qty * sd : scale == "Ticks" ? qty * syminfo.mintick : qty   

getRngFilt(h, l, _rng, n, smooth, sn)=>
    series float rngSmooth = getCondEma(_rng, 1, sn)
    series float r = smooth ? rngSmooth : _rng
    var rfilt = array.new_float(2, (h + l) / 2)
    array.set(rfilt, 1, array.get(rfilt, 0))
    if h - r > array.get(rfilt, 1)
        array.set(rfilt, 0, h - r)
    if l + r < array.get(rfilt, 1)
        array.set(rfilt, 0, l + r)
    series float rngFilt = array.get(rfilt, 0)
    series float hiBand = rngFilt + r
    series float loBand = rngFilt - r
    [hiBand, loBand, rngFilt]

//-----------------------------------------------------------------------------*
// Get Values
//-----------------------------------------------------------------------------{
series float haOpen = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, open)
series float haClose = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)
series float hiVal = close
series float loVal = close
[hiBand, loBand, filt] = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, getRngFilt(hiVal, loVal, getRngSize((hiVal + loVal) / 2, rngScale, rngQty, rngPer), rngPer, rngSmoothRange, rngSmoothPrd))

var fdir = 0.0
fdir := filt > filt[1] ? 1 : filt < filt[1] ? -1 : fdir
bool isUpward = fdir == 1
bool isDnward = fdir == -1

color filtColor = isUpward ? AQUA_COLOR : isDnward ? WHITE_COLOR : LIGHT_GRAY_COLOR

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// VWAP
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string vwapGrp = "VWAP"
bool vwapShowed = input.bool(true, title = "Show", group = vwapGrp)
string vwapAnchor = input.string("Week", title = "Anchor Period", options = ["Session", "Week", "Month", "Quarter", "Year", "Decade", "Century", "Earnings", "Dividends", "Splits"], group="VWAP Settings")
float vwapSrc = input(hlc3, title = "Source", group = vwapGrp)

//-----------------------------------------------------------------------------*
// Get Values
//-----------------------------------------------------------------------------{
series float vwapNewEarnings = request.earnings(syminfo.tickerid, earnings.actual, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol = true)
series float vwapNewDividends = request.dividends(syminfo.tickerid, dividends.gross, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol = true)
series float vwapNewSplit = request.splits(syminfo.tickerid, splits.denominator, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol = true)
series bool vwapPrd = switch vwapAnchor
	"Earnings"  => not na(vwapNewEarnings)
	"Dividends" => not na(vwapNewDividends)
	"Splits"    => not na(vwapNewSplit)
	"Session"   => timeframe.change("D")
	"Week"      => timeframe.change("W")
	"Month"     => timeframe.change("M")
	"Quarter"   => timeframe.change("3M")
	"Year"      => timeframe.change("12M")
	"Decade"    => timeframe.change("12M") and year % 10 == 0
	"Century"   => timeframe.change("12M") and year % 100 == 0
	=> false

bool vwapIsEsdAnchor = vwapAnchor == "Earnings" or vwapAnchor == "Dividends" or vwapAnchor == "Splits"
if na(vwapSrc[1]) and not vwapIsEsdAnchor
	vwapPrd := true

[vwap, _, __] = ta.vwap(vwapSrc, vwapPrd, 1)

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// EMAs
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string emasGrp = "EMAs"
bool emasShowed = input.bool(true, title = "Show", group = emasGrp)
int leadingEmaLen = input.int(8, title = "Leading EMA Length", group = emasGrp)
int laggingEmaLen = input.int(21, title = "Lagging EMA Length", group = emasGrp)

//-----------------------------------------------------------------------------*
// Get Values
//-----------------------------------------------------------------------------{
series float leadingEma = ta.ema(close, leadingEmaLen)
series float laggingEma = ta.ema(close, laggingEmaLen)

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Plots
//-----------------------------------------------------------------------------{
plot(vwapShowed ? vwap : na, title = 'VWAP', color = LIGHT_GRAY_COLOR, linewidth = 3, display = display.pane)
plot(emasShowed ? laggingEma : na, title = "Lagging EMA", color = WHITE_COLOR, linewidth = 1, display = display.pane)
plot(emasShowed ? leadingEma : na, title = "Leading EMA", color = AQUA_COLOR, linewidth = 1, display = display.pane)
plot(rfShowed ? filt : na, title = "Range Filter", color = filtColor, linewidth = 2, display = display.pane)

//-----------------------------------------------------------------------------}