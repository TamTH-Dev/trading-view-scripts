// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tamth_

//@version=6
indicator("Algo", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500, max_bars_back=5000)


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
// Colors
color TRANSPARENT_COLOR = #ffffff00
color WHITE_COLOR       = #dee2e6
color BLACK_COLOR       = #000000
color RED_COLOR         = #F72585
color ORANGE_COLOR      = #fb5607
color YELLOW_COLOR      = #ffbe0b
color GREEN_COLOR       = #2a9d8f
color AQUA_COLOR        = #4CC9F0
color BLUE_COLOR        = #4361ee
color PURPLE_COLOR      = #3F37C9
color PINK_COLOR        = #B5179E
color LIGHT_GRAY_COLOR  = #364156
color DARK_GRAY_COLOR   = #212d40
color TEXT_COLOR        = #ced4da

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Trend Detectors
//-----------------------------------------------------------------------------
// [_vwap, _, _] = ta.vwap(hlc3, timeframe.change("D"), 1)
// plot(_vwap, color = PINK_COLOR, linewidth = 1, display = display.pane)
plot(ta.ema(close, 9), color = AQUA_COLOR, linewidth = 1, display = display.pane)
plot(ta.ema(close, 21), color = PURPLE_COLOR, linewidth = 1, display = display.pane)
// plot(ta.ema(close, 100), color = PINK_COLOR, linewidth = 1, display = display.pane)
// plot(ta.ema(close, 200), color = ORANGE_COLOR, linewidth = 1, display = display.pane)

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Round Numbers
//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------
string rnGrp = "Round Numbers"
bool rnShowed = input.bool(false, "Show", group = rnGrp)

var rnInline1 = "Round 00 Numbers"
linecolor1 = input(title=rnInline1, defval = LIGHT_GRAY_COLOR, inline = rnInline1, group = rnGrp)
linestyle1 = input.string(title="", defval = line.style_solid, options=[line.style_solid, line.style_dotted, line.style_dashed], inline = rnInline1, group = rnGrp)

var rnInline2 = "Round 50 Numbers"
linecolor2 = input(title=rnInline2, defval = DARK_GRAY_COLOR, inline = rnInline2, group = rnGrp)
linestyle2 = input.string(title="", defval = line.style_dashed, options=[line.style_solid, line.style_dotted, line.style_dashed], inline = rnInline2, group = rnGrp)

var rnInline3 = "Quarter Numbers"
linecolor3 = input(title=rnInline3, defval = TRANSPARENT_COLOR, inline = rnInline3, group = rnGrp)
linestyle3 = input.string(title="", defval = line.style_dashed, options=[line.style_solid, line.style_dotted, line.style_dashed], inline = rnInline3, group = rnGrp)


var number_of_lines = input.int(20, title="Number of lines above/below", group = rnGrp)

//-----------------------------------------------------------------------------
// Calculate & Render
//-----------------------------------------------------------------------------
var step = syminfo.mintick * 250
if barstate.islast and rnShowed
    for counter = 0 to number_of_lines - 1
        stepUp = math.ceil(close / step) * step + (counter * step)
        line.new(bar_index, stepUp, bar_index - 1, stepUp, xloc=xloc.bar_index, extend=extend.both, color=linecolor3, width=1, style=linestyle3)
        stepDown = math.floor(close / step) * step - (counter * step)
        line.new(bar_index, stepDown, bar_index - 1, stepDown, xloc=xloc.bar_index, extend=extend.both, color=linecolor3, width=1, style=linestyle3)
        

var step2 = syminfo.mintick * 500
if barstate.islast and rnShowed
    for counter = 0 to (number_of_lines / 2) - 1
        stepUp = math.ceil(close / step2) * step2 + (counter * step2)
        line.new(bar_index, stepUp, bar_index - 1, stepUp, xloc=xloc.bar_index, extend=extend.both, color=linecolor2, width=1, style=linestyle2)
        stepDown = math.floor(close / step2) * step2 - (counter * step2)
        line.new(bar_index, stepDown, bar_index - 1, stepDown, xloc=xloc.bar_index, extend=extend.both, color=linecolor2, width=1, style=linestyle2)
        

var step3 = syminfo.mintick * 1000
if barstate.islast and rnShowed
    for counter = 0 to (number_of_lines / 4) - 1
        stepUp = math.ceil(close / step3) * step3 + (counter * step3)
        line.new(bar_index, stepUp, bar_index - 1, stepUp, xloc=xloc.bar_index, extend=extend.both, color=linecolor1, width=1, style=linestyle1)
        stepDown = math.floor(close / step3) * step3 - (counter * step3)
        line.new(bar_index, stepDown, bar_index - 1, stepDown, xloc=xloc.bar_index, extend=extend.both, color=linecolor1, width=1, style=linestyle1)

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// DSMAs
//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------
dsmaGrp    = "DSMAs"
dsmaShowed = input.bool(false, title="Show", group=dsmaGrp)
dsmaSrc    = input.source(close, title="Source", group=dsmaGrp)
dsma1Len   = input.int(40, title="DSMA 1 Length", group=dsmaGrp)
dsma2Len   = input.int(100, title="DSMA 2 Length", group=dsmaGrp)

//-----------------------------------------------------------------------------
// Methods
//-----------------------------------------------------------------------------
// Calculate DSMA
calcDsma(src, len) =>
    filt = 0.0
    dsma = 0.0

    PI = 3.1415926
    a1 = math.exp( -1.414 * PI / (0.5 * len))
    b1 = 2 * a1 * math.cos( 1.414 * PI / ( 0.5 * len))
    c2 = b1
    c3 = -a1 * a1
    c1 = 1 - c2 - c3

    zeros = src - src[2]
    filt := c1 * (zeros + zeros[1]) / 2 + c2 * nz(filt[1]) + c3 * nz(filt[2])
    rm = math.sum(filt * filt, len) 
    rms = math.sqrt(rm / len) 
    scaledFilt = rms != 0 ? filt / rms : 0
    alpha1 = math.abs(scaledFilt) * 5 / len
    dsma := alpha1 * close + (1 - alpha1) * nz(dsma[1])
    dsma

//-----------------------------------------------------------------------------
// Values
//-----------------------------------------------------------------------------
dsma1 = calcDsma(dsmaSrc, dsma1Len)
dsma2 = calcDsma(dsmaSrc, dsma2Len)

//-----------------------------------------------------------------------------
// Render
//-----------------------------------------------------------------------------
plot(dsmaShowed ? dsma1 : na, color=AQUA_COLOR, linewidth=1, display = display.pane)
plot(dsmaShowed ? dsma2 : na, color=ORANGE_COLOR, linewidth=1, display = display.pane)

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// ORB
//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------
// Historical Display
showHist = input.bool(false, title = "Show Historical Data", group = "Historical Display", tooltip = "Displays All Data from Previous Sessions")
// Opening Range
orTF = input.timeframe("30", title = "Time Period", group = "Opening Range", tooltip = "Sets the Length of Time used for determining Opening Range.") 
// Custom Range
crTog = input.bool(false, title = "", inline = "Custom", group = "Custom Range")
crSesh = input.session("0930-0945", title = "", inline = "Custom", group = "Custom Range")
tz = input.string("UTC-5", title = "", group = "Custom Range", inline = "Custom", options = ["UTC-10", "UTC-8", "UTC-7", "UTC-6", "UTC-5", "UTC-4", "UTC-3", "UTC+0", "UTC+1", "UTC+2", "UTC+3", "UTC+3:30", "UTC+4", "UTC+5", "UTC+5:30", "UTC+5:45", "UTC+6","UTC+6:30", "UTC+7", "UTC+8", "UTC+9", "UTC+9:30", "UTC+10", "UTC+11", "UTC+12", "UTC+12:45", "UTC+13"])
// Breakout Signals
sigTog = input.bool(true, title = "Show Breakout Signals", group = "Breakout Signals")
useBias = input.string("No Bias", title = "Signal Bias", options = ["No Bias","Daily Bias"], group = "Breakout Signals", tooltip = "OR Fill Color is directional based on if the current Day/Session ORM is Above or Below the Previous ORM.\nExamples\nNo Bias: Signals Occur Regardless of OR Color\nDaily Bias: Signals do not fire until Target 1 when Breakout is in opposite direction of OR Color.") == "No Bias" ? false : true
sigSize = str.lower(input.string("Small", title = "Signal Size", options = ["Tiny","Small","Normal","Large","Huge"], group = "Breakout Signals"))
upSigColor = input.color(#089981, title = "Up Color", group = "Breakout Signals", inline = "Colors")
downSigColor = input.color(#f23645, title = "Down Color", group = "Breakout Signals", inline = "Colors")
// Targets
tTog = input.bool(true, title = "Show Targets", group = "Targets")
tPer = input.float(50,minval = 1, title = "Target % of Range", group = "Targets", tooltip = "Uses this % of OR Width to use as the distance for targets.")*0.01
tSrc = input.string("Close", title = "Target Cross Source", options = ["Close","Highs/Lows"], group = "Targets", tooltip = "Uses this Source to tell the script when a target is hit in order to draw the next target.")
tDispType = input.string("Adaptive", title = "Target Display", options = ["Adaptive","Extended"], group = "Targets", tooltip = "Adaptive: Displays and hides targets Adaptivly based on the current price.\nExtended: Extends all targets to the current bar and does not hide any targets after generation.")
// Style
greenFill = input.color(GREEN_COLOR, title = "Bull Fill Color", group = "Style", inline = "Bull")
redFill = input.color(RED_COLOR, title = "Bear Fill Color", group = "Style", inline = "Bear")
orColor = input.color(LIGHT_GRAY_COLOR, title = "OR Levels Color", group = "Style", inline = "Range")
txtSize = str.lower(input.string("Small", title = "Text Size", options = ["Tiny","Small","Normal","Large","Huge"], group = "Style"))

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------
fz(_val) => _val == 0 ? 1 : _val

dash() => (bar_index/2 - math.floor(bar_index/2)) > 0

linestyle(_input) =>
    _input == "___"?line.style_solid:
     _input == "- - -"?line.style_dashed:
     _input == ". . ."?line.style_dotted:
     na

get_1up(_val) => (_val - math.floor(_val)) > 0 ? int(math.floor(_val) + 1) : int(_val)

//-----------------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------------
type target
    line ln

var up_targs = array.new<target>(na)
var down_targs = array.new<target>(na)
var signals = array.new_label()

var bool or_sesh = false
var bool or_token = false

var float orh = na 
var float orl = na
var float hst = na 
var float lst = na
var float prev_orm = na

var int up_count = na
var int down_count = na

var box or_bx = na

var int day_dir = 0
var down_check = false
var up_check = false
down_signal = false
up_signal = false

var target h_ln = target.new(na)
var target l_ln = target.new(na)
var line m_ln = na

//-----------------------------------------------------------------------------
// Calculate
//-----------------------------------------------------------------------------
orm = math.avg(orh,orl)
orw = math.abs(orh-orl)    

h_src = tSrc == "Close" ? close : high
l_src = tSrc == "Close" ? close : low

// Establishing When the OR Sesssion is

new_tf = timeframe.change(orTF)
if crTog
    or_sesh := not na(time(timeframe.period, crSesh, tz))
else 
    if session.isfirstbar
        or_sesh := true
    else if not session.isfirstbar and new_tf
        or_sesh := false

or_start = or_sesh and not or_sesh[1]
or_end = or_sesh[1] and not or_sesh

// On Start of OR Session
if or_start
    for targ in up_targs
        if showHist == false
            targ.ln.delete()

    for targ in down_targs
        if showHist == false
            targ.ln.delete()

    for lab in signals
        if showHist == false
            lab.delete()

    if showHist == false
        or_bx.delete()
        h_ln.ln.delete()
        l_ln.ln.delete()
        m_ln.delete()

    up_targs.clear()
    down_targs.clear()

    orh := high
    orl := low
    prev_orm := orm[1]
    up_count := 0
    down_count := 0
    up_check := true
    down_check := true
    or_token := false

// Running while OR Session is Live
if or_sesh
    if high > orh
        orh := high
    if low < orl
        orl := low
    or_bx.set_top(orh)
    or_bx.set_bottom(orl)
    or_bx.set_right(bar_index)
    if orh != orl
        or_token := true
        
// On End of OR Session
if or_end and or_token
    orb_color = day_dir == 1 ? greenFill : day_dir == -1 ? redFill : TRANSPARENT_COLOR
    h_ln := target.new(line.new(bar_index, orh, bar_index, orh, color = color.new(orb_color, 50)))
    l_ln := target.new(line.new(bar_index, orl, bar_index, orl, color = color.new(orb_color, 50)))
    hst := orh + (orw * tPer)
    lst := orl - (orw * tPer)
    day_dir := orm > prev_orm ? 1 : orm < prev_orm ? -1 : 0
    linefill.new(h_ln.ln,l_ln.ln, color.new(orb_color, 90))


// Running outside of OR Session
if not or_sesh and or_token
    h_ln.ln.set_x2(bar_index)
    l_ln.ln.set_x2(bar_index)
    m_ln.set_x2(bar_index)

// Target Calculations
if h_src > hst
    hst := h_src
if l_src < lst
    lst := l_src

up_max = get_1up((hst - orh) / (orw * tPer))
down_max = get_1up((orl - lst) / (orw * tPer))

up_cur = math.max(0, get_1up((h_src - orh) / (orw * tPer)))
down_cur = math.max(0, get_1up((orl - l_src) / (orw * tPer)))

// Signal Calcs
if  (close > orm and down_check == false)
    down_check := true

xdown = ta.crossunder(close, orl)
xdown2 = ta.crossunder(close, orl - orw * tPer)
if (useBias ? ((day_dir != 1 and xdown) or (day_dir == 1 and xdown2)) : ta.crossunder(close, orl)) and down_check
    down_signal := true
    down_check := false

if (close < orm and up_check == false)
    up_check := true

xup = ta.crossover(close, orh)
xup2 = ta.crossover(close, orh + orw * tPer)
if (useBias ? ((day_dir != -1 and xup) or (day_dir == -1 and xup2)) : ta.crossover(close, orh)) and up_check
    up_signal := true
    up_check := false

//-----------------------------------------------------------------------------
// Render
//-----------------------------------------------------------------------------
if up_signal and sigTog
    signals.push(label.new(bar_index, orl, style = label.style_label_center, text = "\n\n▲", color = TRANSPARENT_COLOR, textcolor = upSigColor, size = sigSize))

if down_signal and sigTog
    signals.push(label.new(bar_index, orh, style = label.style_label_center, text = "▼\n\n", color = TRANSPARENT_COLOR, textcolor = downSigColor, size = sigSize))

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// HTF Candles
//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------
type Helper
	string name = 'Helper'

type Candle
	float o
	float c
	float h
	float l
    int o_time
	int o_idx
	int c_idx
	int h_idx
	int l_idx
    string dow
	box body
	line wick_up
	line wick_down
    label dow_label

type CandeTrace
	line o
	line c
	line h
	line l
	label o_l
	label c_l
	label h_l
	label l_l

type CandeImbalance
	box b
	int idx

type CandeSettingsHTF
	bool show
	string htf
	int max_display

type CandleSettings
	int max_sets
	color bull_body
	color bull_border
	color bull_wick
	color bear_body
	color bear_border
	color bear_wick
	int offset
	int buffer
	int htf_buffer
	int width
	bool use_custom_daily
    string custom_daily
    bool daily_name
	bool trace_show
	color trace_o_color
	string trace_o_style
	int trace_o_size
	color trace_c_color
	string trace_c_style
	int trace_c_size
	color trace_h_color
	string trace_h_style
	int trace_h_size
	color trace_l_color
	string trace_l_style
	int trace_l_size
	string trace_anchor
	bool label_show
	color label_color
	string label_size
    string label_position
    string label_alignment
	bool fvg_show
	color fvg_color
	bool vi_show
	color vi_color
	bool htf_label_show
	color htf_label_color
	string htf_label_size
	bool htf_timer_show
	color htf_timer_color
	string htf_timer_size
    color dow_color
    string dow_size

type CandleSet
	array<Candle> candles
	array<CandeImbalance> imbalances
	CandeSettingsHTF settings
	label tfNameTop
    label tfNameBottom
	label tfTimerTop
    label tfTimerBottom

CandleSettings candle_settings = CandleSettings.new()

var CandeSettingsHTF CandleSettingsHTF1 = CandeSettingsHTF.new()
var CandeSettingsHTF CandleSettingsHTF2 = CandeSettingsHTF.new()
var CandeSettingsHTF CandleSettingsHTF3 = CandeSettingsHTF.new()
var CandeSettingsHTF CandleSettingsHTF4 = CandeSettingsHTF.new()
var CandeSettingsHTF CandleSettingsHTF5 = CandeSettingsHTF.new()
var CandeSettingsHTF CandleSettingsHTF6 = CandeSettingsHTF.new()

var array<Candle> candles_1 = array.new<Candle>(0)
var array<Candle> candles_2 = array.new<Candle>(0)
var array<Candle> candles_3 = array.new<Candle>(0)
var array<Candle> candles_4 = array.new<Candle>(0)
var array<Candle> candles_5 = array.new<Candle>(0)
var array<Candle> candles_6 = array.new<Candle>(0)

var array<CandeImbalance> candles_imbalances_1 = array.new<CandeImbalance>()
var array<CandeImbalance> candles_imbalances_2 = array.new<CandeImbalance>()
var array<CandeImbalance> candles_imbalances_3 = array.new<CandeImbalance>()
var array<CandeImbalance> candles_imbalances_4 = array.new<CandeImbalance>()
var array<CandeImbalance> candles_imbalances_5 = array.new<CandeImbalance>()
var array<CandeImbalance> candles_imbalances_6 = array.new<CandeImbalance>()

var CandleSet candle_htf1 = CandleSet.new()
candle_htf1.settings := CandleSettingsHTF1
candle_htf1.candles := candles_1
candle_htf1.imbalances := candles_imbalances_1

var CandleSet candle_htf2 = CandleSet.new()
candle_htf2.settings := CandleSettingsHTF2
candle_htf2.candles := candles_2
candle_htf2.imbalances := candles_imbalances_2

var CandleSet candle_htf3 = CandleSet.new()
candle_htf3.settings := CandleSettingsHTF3
candle_htf3.candles := candles_3
candle_htf3.imbalances := candles_imbalances_3

var CandleSet candle_htf4 = CandleSet.new()
candle_htf4.settings := CandleSettingsHTF4
candle_htf4.candles := candles_4
candle_htf4.imbalances := candles_imbalances_4

var CandleSet candle_htf5 = CandleSet.new()
candle_htf5.settings := CandleSettingsHTF5
candle_htf5.candles := candles_5
candle_htf5.imbalances := candles_imbalances_5

var CandleSet candle_htf6 = CandleSet.new()
candle_htf6.settings := CandleSettingsHTF6
candle_htf6.candles := candles_6
candle_htf6.imbalances := candles_imbalances_6

//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------
string group_htf_candles        = "HTF Candles  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string group_style              = "Styling  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string group_label              = "Label  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string group_imbalance          = "Imbalance  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string group_trace              = "Trace  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

candle_htf1.settings.show              := input.bool(false, 'HTF 1', inline = 'htf1', group = group_htf_candles)
cancle_htf_1_input                      = input.timeframe('5', '', inline = 'htf1', group = group_htf_candles)
candle_htf1.settings.htf := cancle_htf_1_input
candle_htf1.settings.max_display       := input.int(10, '', inline = 'htf1', group = group_htf_candles)

candle_htf2.settings.show              := input.bool(true, 'HTF 2', inline = 'htf2', group = group_htf_candles)
cancle_htf_2_input                      = input.timeframe('15', '', inline = 'htf2', group = group_htf_candles)
candle_htf2.settings.htf := cancle_htf_2_input
candle_htf2.settings.max_display       := input.int(10, '', inline = 'htf2', group = group_htf_candles)

candle_htf3.settings.show              := input.bool(true, 'HTF 3', inline = 'htf3', group = group_htf_candles)
cancle_htf_3_input                      = input.timeframe('60', '', inline = 'htf3', group = group_htf_candles)
candle_htf3.settings.htf := cancle_htf_3_input
candle_htf3.settings.max_display       := input.int(10, '', inline = 'htf3', group = group_htf_candles)

candle_htf4.settings.show              := input.bool(true, 'HTF 4', inline = 'htf4', group = group_htf_candles)
cancle_htf_4_input                      = input.timeframe('240', '', inline = 'htf4', group = group_htf_candles)
candle_htf4.settings.htf               := cancle_htf_4_input
candle_htf4.settings.max_display       := input.int(10, '', inline = 'htf4', group = group_htf_candles)

candle_htf5.settings.show              := input.bool(true, 'HTF 5', inline = 'htf5', group = group_htf_candles)
cancle_htf_5_input                      = input.timeframe('1D', '', inline = 'htf5', group = group_htf_candles)
candle_htf5.settings.htf := cancle_htf_5_input
candle_htf5.settings.max_display       := input.int(10, '', inline = 'htf5', group = group_htf_candles)

candle_htf6.settings.show              := input.bool(true, 'HTF 6', inline = 'htf6', group = group_htf_candles)
cancle_htf_6_input                      = input.timeframe('1W', '', inline = 'htf6', group = group_htf_candles)
candle_htf6.settings.htf               := cancle_htf_6_input
candle_htf6.settings.max_display       := input.int(10, '', inline = 'htf6', group = group_htf_candles)

candle_settings.max_sets               := input.int(6, 'Limit to next HTFs only', minval = 1, maxval = 6)
candle_settings.use_custom_daily       := input.bool(false, 'Custom daily candle open', inline='customdaily')
candle_settings.custom_daily           := input.string('Midnight', '', options=['Midnight', '8:30', '9:30'], inline='customdaily')
candle_settings.bull_body              := input.color(WHITE_COLOR, 'Body', inline = 'body', group = group_style)
candle_settings.bear_body              := input.color(BLUE_COLOR, '', inline = 'body', group = group_style)
candle_settings.bull_border            := input.color(WHITE_COLOR, 'Borders', inline = 'borders', group = group_style)
candle_settings.bear_border            := input.color(BLUE_COLOR, '', inline = 'borders', group = group_style)
candle_settings.bull_wick              := input.color(LIGHT_GRAY_COLOR, 'Wick', inline = 'wick', group = group_style)
candle_settings.bear_wick              := input.color(LIGHT_GRAY_COLOR, '', inline = 'wick', group = group_style)

candle_settings.offset                 := input.int(30, 'padding from current candles', minval = 1, group = group_style)
candle_settings.buffer                 := input.int(1, 'space between candles', minval = 1, maxval = 4, group = group_style)
candle_settings.htf_buffer             := input.int(10, 'space between Higher Timeframes', minval = 1, maxval = 10, group = group_style)
candle_settings.width                  := input.int(1, 'Candle Width', minval = 1, maxval = 4, group = group_style) * 2

candle_settings.htf_label_show         := input.bool(true, 'HTF Label', group = group_label, inline = 'HTFlabel')
candle_settings.htf_label_color        := input.color(LIGHT_GRAY_COLOR, '', group = group_label, inline = 'HTFlabel')
candle_settings.htf_label_size         := input.string(size.large, '', [size.tiny, size.small, size.normal, size.large, size.huge], group = group_label, inline = 'HTFlabel')

candle_settings.label_position         := input.string("Top", 'Label Positions', options=['Both', 'Top', 'Bottom'], group = group_label)
candle_settings.label_alignment        := input.string("Align", "Label Alignment", options=['Align', 'Follow Candles'], group = group_label)

candle_settings.htf_timer_show         := input.bool(true, 'Remaining time', inline = 'timer', group = group_label)
candle_settings.htf_timer_color        := input.color(LIGHT_GRAY_COLOR, '', inline = 'timer', group = group_label)
candle_settings.htf_timer_size         := input.string(size.normal, '', [size.tiny, size.small, size.normal, size.large, size.huge], group = group_label, inline = 'timer')

candle_settings.daily_name             := input.bool(false, 'Interval Value', group = group_label, inline = 'dow')
candle_settings.dow_color              := input.color(LIGHT_GRAY_COLOR , '', group = group_label, inline = 'dow')
candle_settings.dow_size               := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], group = group_label, inline = 'dow')

candle_settings.fvg_show               := input.bool(true, 'Fair Value Gap', group = group_imbalance, inline = 'fvg')
candle_settings.fvg_color              := input.color(color.new(DARK_GRAY_COLOR, 60), '', inline = 'fvg', group = group_imbalance)

candle_settings.vi_show                := input.bool(false, 'Volume Imbalance', group = group_imbalance, inline = 'vi')
candle_settings.vi_color               := input.color(color.new(PINK_COLOR, 80), '', inline = 'vi', group = group_imbalance)

candle_settings.trace_show             := input.bool(false, 'Trace lines', group = group_trace)
candle_settings.trace_o_color          := input.color(DARK_GRAY_COLOR, 'Open', inline = '1', group = group_trace)
candle_settings.trace_o_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '1', group = group_trace)
candle_settings.trace_o_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '1', group = group_trace)
candle_settings.trace_c_color          := input.color(DARK_GRAY_COLOR, 'Close', inline = '2', group = group_trace)
candle_settings.trace_c_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '2', group = group_trace)
candle_settings.trace_c_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '2', group = group_trace)
candle_settings.trace_h_color          := input.color(DARK_GRAY_COLOR, 'High', inline = '3', group = group_trace)
candle_settings.trace_h_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '3', group = group_trace)
candle_settings.trace_h_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '3', group = group_trace)
candle_settings.trace_l_color          := input.color(DARK_GRAY_COLOR, 'Low', inline = '4', group = group_trace)
candle_settings.trace_l_style          := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '4', group = group_trace)
candle_settings.trace_l_size           := input.int(1, '', options = [1, 2, 3, 4], inline = '4', group = group_trace)
candle_settings.trace_anchor           := input.string('First Timeframe', 'Anchor to', options = ['First Timeframe', 'Last Timeframe'], group = group_trace)

candle_settings.label_show             := input.bool(false, 'Price Label', inline = 'label')
candle_settings.label_color            := input.color(color.new(TEXT_COLOR, 10), '', inline = 'label')
candle_settings.label_size             := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline = 'label')

//-----------------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------------
Helper candle_helper = Helper.new()
var CandeTrace candle_trace = CandeTrace.new()

//-----------------------------------------------------------------------------
// Methods
//-----------------------------------------------------------------------------
method LineStyle(Helper helper, string style) =>
    helper.name := style
    out = switch style
        '----' => line.style_dashed
        '····' => line.style_dotted
        => line.style_solid
    out

method DayOfWeek(Helper helper, int index) =>
    helper.name := 'DOW'
    switch
        index == 1 => 'M'
        index == 2 => 'T'
        index == 3 => 'W'
        index == 4 => 'T'
        index == 5 => 'F'
        index == 6 => 'S'
        index == 7 => 'S'
        na(index) => ''

method CandleValidTimeframe(Helper helper, string HTF) =>
    helper.name := HTF
    if timeframe.in_seconds(HTF) >= timeframe.in_seconds('D') and timeframe.in_seconds(HTF) > timeframe.in_seconds()
        true
    else
        n1 = timeframe.in_seconds()
        n2 = timeframe.in_seconds(HTF)
        n3 = n1 % n2
        n1 < n2 and math.round(n2 / n1) == n2 / n1


method CandleRemainingTime(Helper helper, string HTF) =>
    helper.name := HTF
    if barstate.isrealtime
        timeRemaining = (time_close(HTF) - timenow) / 1000
        days = math.floor(timeRemaining / 86400)
        hours = math.floor((timeRemaining - days * 86400) / 3600)
        minutes = math.floor((timeRemaining - days * 86400 - hours * 3600) / 60)
        seconds = math.floor(timeRemaining - days * 86400 - hours * 3600 - minutes * 60)

        r = str.tostring(seconds, '00')
        if minutes > 0 or hours > 0 or days > 0
            r := str.tostring(minutes, '00') + ':' + r
            r
        if hours > 0 or days > 0
            r := str.tostring(hours, '00') + ':' + r
            r
        if days > 0
            r := str.tostring(days) + 'D ' + r
            r
        r
    else
        'n/a'

method CandleHTFName(Helper helper, string HTF) =>
    helper.name := 'HTFName'
    formatted = HTF

    seconds = timeframe.in_seconds(HTF)
    if seconds < 60
        formatted := str.tostring(seconds) + 's'
        formatted
    else if seconds / 60 < 60
        formatted := str.tostring(seconds / 60) + 'm'
        formatted
    else if seconds / 60 / 60 < 24
        formatted := str.tostring(seconds / 60 / 60) + 'H'
        formatted
    formatted

method CandleHTFEnabled(Helper helper) =>
    helper.name := 'HTFEnabled'
    int enabled = 0
    enabled := enabled + (candle_htf1.settings.show ? 1 : 0)
    enabled := enabled + (candle_htf2.settings.show ? 1 : 0)
    enabled := enabled + (candle_htf3.settings.show ? 1 : 0)
    enabled := enabled + (candle_htf4.settings.show ? 1 : 0)
    enabled := enabled + (candle_htf5.settings.show ? 1 : 0)
    enabled := enabled + (candle_htf6.settings.show ? 1 : 0)
    int last = math.min(enabled, candle_settings.max_sets)

    last

method CandleSetHigh(Helper helper, array<Candle> candles, float h) =>
    helper.name := 'CandlesSetHigh'
    float _h = h
    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.h > _h
                _h := c.h
                _h
    _h

method CandleSetLow(Helper helper, array<Candle> candles, float l) =>
    helper.name := 'CandlesSetLow'
    float _l = l
    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.l < _l
                _l := c.l
                _l
    _l

method CandlesHigh(Helper helper, array<Candle> candles) =>
    helper.name := 'CandlesHigh'
    h = 0.0
    int candle_cnt = 0
    int last = helper.CandleHTFEnabled()

    if candle_htf1.settings.show and helper.CandleValidTimeframe(candle_htf1.settings.htf)
        h := helper.CandleSetHigh(candle_htf1.candles, h)
        candle_cnt := candle_cnt + 1
    if candle_htf2.settings.show and helper.CandleValidTimeframe(candle_htf2.settings.htf) and candle_cnt < last
        h := helper.CandleSetHigh(candle_htf2.candles, h)
        candle_cnt := candle_cnt + 1
    if candle_htf3.settings.show and helper.CandleValidTimeframe(candle_htf3.settings.htf) and candle_cnt < last
        h := helper.CandleSetHigh(candle_htf3.candles, h)
        candle_cnt := candle_cnt + 1
    if candle_htf4.settings.show and helper.CandleValidTimeframe(candle_htf4.settings.htf) and candle_cnt < last
        h := helper.CandleSetHigh(candle_htf4.candles, h)
        candle_cnt := candle_cnt + 1
    if candle_htf5.settings.show and helper.CandleValidTimeframe(candle_htf5.settings.htf) and candle_cnt < last
        h := helper.CandleSetHigh(candle_htf5.candles, h)
        candle_cnt := candle_cnt + 1
    if candle_htf6.settings.show and helper.CandleValidTimeframe(candle_htf6.settings.htf) and candle_cnt < last
        h := helper.CandleSetHigh(candle_htf6.candles, h)

    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.h > h
                h := c.h
    h

method CandlesLow(Helper helper, array<Candle> candles, float h) =>
    helper.name := 'CandlesLow'
    l = h
    int candle_cnt = 0
    int last = helper.CandleHTFEnabled()

    if candle_htf1.settings.show and helper.CandleValidTimeframe(candle_htf1.settings.htf)
        l := helper.CandleSetLow(candle_htf1.candles, l)
        candle_cnt := candle_cnt + 1
    if candle_htf2.settings.show and helper.CandleValidTimeframe(candle_htf2.settings.htf) and candle_cnt < last
        l := helper.CandleSetLow(candle_htf2.candles, l)
        candle_cnt := candle_cnt + 1
    if candle_htf3.settings.show and helper.CandleValidTimeframe(candle_htf3.settings.htf) and candle_cnt < last
        l := helper.CandleSetLow(candle_htf3.candles, l)
        candle_cnt := candle_cnt + 1
    if candle_htf4.settings.show and helper.CandleValidTimeframe(candle_htf4.settings.htf) and candle_cnt < last
        l := helper.CandleSetLow(candle_htf4.candles, l)
        candle_cnt := candle_cnt + 1
    if candle_htf5.settings.show and helper.CandleValidTimeframe(candle_htf5.settings.htf) and candle_cnt < last
        l := helper.CandleSetLow(candle_htf5.candles, l)
        candle_cnt := candle_cnt + 1
    if candle_htf6.settings.show and helper.CandleValidTimeframe(candle_htf6.settings.htf) and candle_cnt < last
        l := helper.CandleSetLow(candle_htf6.candles, l)

    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.l < l
                l := c.l
    l

method CandleUpdateTime(CandleSet candleSet, int offset) =>
    if candle_settings.htf_timer_show and (barstate.isrealtime or barstate.islast)
        string tmr = '(' + candle_helper.CandleRemainingTime(candleSet.settings.htf) + ')'

        if not na(candleSet.tfTimerTop)
            candleSet.tfTimerTop.set_text(tmr)

        if not na(candleSet.tfTimerBottom)
            candleSet.tfTimerBottom.set_text(tmr)
    candleSet

method CandleReorder(CandleSet candleSet, int offset) =>
    size = candleSet.candles.size()

    if size > 0
        for i = size - 1 to 0 by 1
            Candle candle = candleSet.candles.get(i)
            t_buffer = offset + (candle_settings.width + candle_settings.buffer) * (size - i - 1)
            box.set_left(candle.body, bar_index + t_buffer)
            box.set_right(candle.body, bar_index + candle_settings.width + t_buffer)
            line.set_x1(candle.wick_up, bar_index + candle_settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_up, bar_index + candle_settings.width / 2 + t_buffer)
            line.set_x1(candle.wick_down, bar_index + candle_settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_down, bar_index + candle_settings.width / 2 + t_buffer)

            if candle_settings.daily_name //and candleSet.settings.htf == '1D'
                if not na(candle.dow_label)
                    candle.dow_label.set_y(candle.h)
                    candle.dow_label.set_x(bar_index + candle_settings.width / 2 + t_buffer)
                    candle.dow_label.set_text(candle.dow)
                else
                    candle.dow_label := label.new(bar_index + candle_settings.width / 2 + t_buffer, candle.h, candle.dow, color = TRANSPARENT_COLOR, textcolor = candle_settings.dow_color, style = label.style_label_down, size = candle_settings.dow_size)

    top = 0.0
    bottom = 0.0

    if candle_settings.label_alignment == 'Align'
        top := candle_helper.CandlesHigh(candleSet.candles)
        bottom := candle_helper.CandlesLow(candleSet.candles, top)
    if candle_settings.label_alignment == 'Follow Candles'
        top := candle_helper.CandleSetHigh(candleSet.candles, 0)
        bottom := candle_helper.CandleSetLow(candleSet.candles, top)

    left = bar_index + offset + (candle_settings.width + candle_settings.buffer) * (size - 1) / 2

    if candle_settings.htf_label_show
        string lblt = candle_helper.CandleHTFName(candleSet.settings.htf)
        string lbll = lblt
        if candle_settings.htf_timer_show
            lblt := lblt + '\n'
            lbll := '\n' + lbll
        if candle_settings.daily_name
            lblt := lblt + '\n'

        string tmr = '(' + candle_helper.CandleRemainingTime(candleSet.settings.htf) + ')' + (candle_settings.daily_name ? '\n' : '')
        if candle_settings.label_position == 'Both' or candle_settings.label_position == 'Top'
            
            if not na(candleSet.tfNameTop)
                candleSet.tfNameTop.set_xy(left, top)
            else
                candleSet.tfNameTop := label.new(left, top, lblt, color = TRANSPARENT_COLOR, textcolor = candle_settings.htf_label_color, style = label.style_label_down, size = candle_settings.htf_label_size)
            if candle_settings.htf_timer_show
                if not na(candleSet.tfTimerTop)
                    candleSet.tfTimerTop.set_xy(left, top)
                else
                    candleSet.tfTimerTop := label.new(left, top, tmr, color = TRANSPARENT_COLOR, textcolor = candle_settings.htf_timer_color, style = label.style_label_down, size = candle_settings.htf_timer_size)

        if candle_settings.label_position == 'Both' or candle_settings.label_position == 'Bottom'
            if not na(candleSet.tfNameBottom)
                candleSet.tfNameBottom.set_xy(left, bottom)
            else
                candleSet.tfNameBottom := label.new(left, bottom, lbll, color = TRANSPARENT_COLOR, textcolor = candle_settings.htf_label_color, style = label.style_label_up, size = candle_settings.htf_label_size)
            if candle_settings.htf_timer_show
                if candle_settings.htf_timer_show
                    if not na(candleSet.tfTimerBottom)
                        candleSet.tfTimerBottom.set_xy(left, bottom)
                    else
                        candleSet.tfTimerBottom := label.new(left, bottom, tmr, color = TRANSPARENT_COLOR, textcolor = candle_settings.htf_timer_color, style = label.style_label_up, size = candle_settings.htf_timer_size)

    candleSet

method CandleFindImbalance(CandleSet candleSet) =>
    if barstate.isrealtime or barstate.islast
        if candleSet.imbalances.size() > 0
            for i = candleSet.imbalances.size() - 1 to 0 by 1
                CandeImbalance del = candleSet.imbalances.get(i)
                box.delete(del.b)
                candleSet.imbalances.pop()

        if candleSet.candles.size() > 3 and candle_settings.fvg_show
            for i = 0 to candleSet.candles.size() - 3 by 1
                candle1 = candleSet.candles.get(i)
                candle2 = candleSet.candles.get(i + 2)
                candle3 = candleSet.candles.get(i + 1)

                if candle1.l > candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                    CandeImbalance imb = CandeImbalance.new()
                    imb.b := box.new(box.get_left(candle2.body), candle2.h, box.get_right(candle1.body), candle1.l, bgcolor = candle_settings.fvg_color, border_color = candle_settings.fvg_color, xloc = xloc.bar_index)
                    candleSet.imbalances.push(imb)
                if candle1.h < candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                    CandeImbalance imb = CandeImbalance.new()
                    imb.b := box.new(box.get_right(candle1.body), candle1.h, box.get_left(candle2.body), candle2.l, bgcolor = candle_settings.fvg_color, border_color = candle_settings.fvg_color)
                    candleSet.imbalances.push(imb)
                box temp = box.copy(candle3.body)
                box.delete(candle3.body)
                candle3.body := temp
                candle3.body

        if candleSet.candles.size() > 2 and candle_settings.vi_show
            for i = 0 to candleSet.candles.size() - 2 by 1
                candle1 = candleSet.candles.get(i)
                candle2 = candleSet.candles.get(i + 1)
                if candle1.l < candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                    CandeImbalance imb = CandeImbalance.new()
                    imb.b := box.new(box.get_left(candle2.body), math.min(candle1.o, candle1.c), box.get_right(candle1.body), math.max(candle2.o, candle2.c), bgcolor = candle_settings.vi_color, border_color = TRANSPARENT_COLOR)
                    candleSet.imbalances.push(imb)
                if candle1.h > candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                    CandeImbalance imb = CandeImbalance.new()
                    imb.b := box.new(box.get_right(candle1.body), math.min(candle2.o, candle2.c), box.get_left(candle2.body), math.max(candle1.o, candle1.c), bgcolor = candle_settings.vi_color, border_color = TRANSPARENT_COLOR)
                    candleSet.imbalances.push(imb)
    candleSet

method CandleMonitor(CandleSet candleSet) =>
    HTFBarTime = time(candleSet.settings.htf, 'america/New_York')
    isNewHTFCandle = ta.change(HTFBarTime) > 0

    if candle_settings.use_custom_daily
        int _830 = 0
        if isNewHTFCandle
            _830 := timestamp("America/New_York", year(time), month(time), dayofmonth(time), 0, 0) + 30600000
        if candleSet.settings.htf == '1D'
            if candle_settings.custom_daily == 'Midnight'
                isNewHTFCandle := dayofweek(time, 'America/New_York') != dayofweek(time - (time - time[1]), 'America/New_York')
            if candle_settings.custom_daily == '8:30'    
                // Get 8:30 AM New York time for today 
                isNewHTFCandle := not na(time(timeframe.period, "0830-0831:123456", 'America/New_York')) and na(time(timeframe.period, "0830-0831:123456", 'America/New_York')[1])
            if candle_settings.custom_daily == '9:30'    
                // Get 9:30 AM New York time for today 
                isNewHTFCandle := not na(time(timeframe.period, "0930-0931:123456", 'America/New_York')) and na(time(timeframe.period, "0930-0931:123456", 'America/New_York')[1])
    if isNewHTFCandle
        Candle candle = Candle.new()
        candle.o := open
        candle.c := close
        candle.h := high
        candle.l := low
        candle.o_time := time
        candle.o_idx := bar_index
        candle.c_idx := bar_index
        candle.h_idx := bar_index
        candle.l_idx := bar_index
        candle.dow := switch
            candleSet.settings.htf == '1D' =>
                candle_helper.DayOfWeek(dayofweek(time_tradingday, "America/New_York"))
            str.tonumber(candleSet.settings.htf) < 60 =>
                str.format_time(candle.o_time, 'm', 'America/New_York')
            str.tonumber(candleSet.settings.htf) >= 60 =>
                str.format_time(candle.o_time, 'H', 'America/New_York')
            candleSet.settings.htf == '1M' =>
                str.format_time(candle.o_time, 'M', 'America/New_York')
            =>
                ''
        log.info('dow: {1} |{0}|', candle.dow, candleSet.settings.htf)
        bull = candle.c > candle.o

        candle.body := box.new(bar_index, math.max(candle.o, candle.c), bar_index + 2, math.min(candle.o, candle.c), bull ? candle_settings.bull_border : candle_settings.bear_border, 1, bgcolor = bull ? candle_settings.bull_body : candle_settings.bear_body)
        candle.wick_up := line.new(bar_index + 1, candle.h, bar_index, math.max(candle.o, candle.c), color = bull ? candle_settings.bull_wick : candle_settings.bear_wick)
        candle.wick_down := line.new(bar_index + 1, math.min(candle.o, candle.c), bar_index, candle.l, color = bull ? candle_settings.bull_wick : candle_settings.bear_wick)

        candleSet.candles.unshift(candle)

        if candleSet.candles.size() > candleSet.settings.max_display
            Candle delCandle = array.pop(candleSet.candles)
            box.delete(delCandle.body)
            line.delete(delCandle.wick_up)
            line.delete(delCandle.wick_down)
            delCandle.dow_label.delete()

    candleSet

method CandleUpdate(CandleSet candleSet, int offset, bool showTrace) =>
    if candleSet.candles.size() > 0
        Candle candle = candleSet.candles.first()
        candle.h_idx := high > candle.h ? bar_index : candle.h_idx
        candle.h := high > candle.h ? high : candle.h
        candle.l_idx := low < candle.l ? bar_index : candle.l_idx
        candle.l := low < candle.l ? low : candle.l
        candle.c := close
        candle.c_idx := bar_index

        bull = candle.c > candle.o

        box.set_top(candle.body, candle.o)
        box.set_bottom(candle.body, candle.c)
        box.set_bgcolor(candle.body, bull ? candle_settings.bull_body : candle_settings.bear_body)
        box.set_border_color(candle.body, bull ? candle_settings.bull_border : candle_settings.bear_border)
        line.set_color(candle.wick_up, bull ? candle_settings.bull_wick : candle_settings.bear_wick)
        line.set_color(candle.wick_down, bull ? candle_settings.bull_wick : candle_settings.bear_wick)
        line.set_y1(candle.wick_up, candle.h)
        line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
        line.set_y1(candle.wick_down, candle.l)
        line.set_y2(candle.wick_down, math.min(candle.o, candle.c))

        if barstate.isrealtime or barstate.islast
            candleSet.CandleReorder(offset)
            if candle_settings.trace_show and showTrace
                if bar_index - candle.o_idx < 5000
                    if na(candle_trace.o)
                        candle_trace.o := line.new(candle.o_idx, candle.o, box.get_left(candle.body), candle.o, xloc = xloc.bar_index, color = candle_settings.trace_o_color, style = candle_helper.LineStyle(candle_settings.trace_o_style), width = candle_settings.trace_o_size)
                        candle_trace.o
                    else
                        line.set_xy1(candle_trace.o, candle.o_idx, candle.o)
                        line.set_xy2(candle_trace.o, box.get_left(candle.body), candle.o)

                    if candle_settings.label_show
                        if na(candle_trace.o_l)
                            candle_trace.o_l := label.new(box.get_right(candle.body), candle.o, str.tostring(candle.o), textalign = text.align_center, style = label.style_label_left, size = candle_settings.label_size, color = TRANSPARENT_COLOR, textcolor = candle_settings.label_color)
                            candle_trace.o_l
                        else
                            label.set_xy(candle_trace.o_l, box.get_right(candle.body), candle.o)
                            label.set_text(candle_trace.o_l, str.tostring(candle.o))

                if bar_index - candle.c_idx < 5000
                    if na(candle_trace.c)
                        candle_trace.c := line.new(candle.c_idx, candle.c, box.get_left(candle.body), candle.c, xloc = xloc.bar_index, color = candle_settings.trace_c_color, style = candle_helper.LineStyle(candle_settings.trace_c_style), width = candle_settings.trace_c_size)
                        candle_trace.c
                    else
                        line.set_xy1(candle_trace.c, candle.c_idx, candle.c)
                        line.set_xy2(candle_trace.c, box.get_left(candle.body), candle.c)

                    if candle_settings.label_show
                        if na(candle_trace.c_l)
                            candle_trace.c_l := label.new(box.get_right(candle.body), candle.c, str.tostring(candle.c), textalign = text.align_center, style = label.style_label_left, size = candle_settings.label_size, color = TRANSPARENT_COLOR, textcolor = candle_settings.label_color)
                            candle_trace.c_l
                        else
                            label.set_xy(candle_trace.c_l, box.get_right(candle.body), candle.c)
                            label.set_text(candle_trace.c_l, str.tostring(candle.c))

                if bar_index - candle.h_idx < 5000
                    if na(candle_trace.h)
                        candle_trace.h := line.new(candle.h_idx, candle.h, line.get_x1(candle.wick_up), candle.h, xloc = xloc.bar_index, color = candle_settings.trace_h_color, style = candle_helper.LineStyle(candle_settings.trace_h_style), width = candle_settings.trace_h_size)
                        candle_trace.h
                    else
                        line.set_xy1(candle_trace.h, candle.h_idx, candle.h)
                        line.set_xy2(candle_trace.h, line.get_x1(candle.wick_up), candle.h)

                    if candle_settings.label_show
                        if na(candle_trace.h_l)
                            candle_trace.h_l := label.new(box.get_right(candle.body), candle.h, str.tostring(candle.h), textalign = text.align_center, style = label.style_label_left, size = candle_settings.label_size, color = TRANSPARENT_COLOR, textcolor = candle_settings.label_color)
                            candle_trace.h_l
                        else
                            label.set_xy(candle_trace.h_l, box.get_right(candle.body), candle.h)
                            label.set_text(candle_trace.h_l, str.tostring(candle.h))

                if bar_index - candle.l_idx < 5000
                    if na(candle_trace.l)
                        candle_trace.l := line.new(candle.l_idx, candle.l, line.get_x1(candle.wick_down), candle.l, xloc = xloc.bar_index, color = candle_settings.trace_l_color, style = candle_helper.LineStyle(candle_settings.trace_l_style), width = candle_settings.trace_l_size)
                        candle_trace.l
                    else
                        line.set_xy1(candle_trace.l, candle.l_idx, candle.l)
                        line.set_xy2(candle_trace.l, line.get_x1(candle.wick_down), candle.l)

                    if candle_settings.label_show
                        if na(candle_trace.l_l)
                            candle_trace.l_l := label.new(box.get_right(candle.body), candle.l, str.tostring(candle.l), textalign = text.align_center, style = label.style_label_left, size = candle_settings.label_size, color = TRANSPARENT_COLOR, textcolor = candle_settings.label_color)
                            candle_trace.l_l
                        else
                            label.set_xy(candle_trace.l_l, box.get_right(candle.body), candle.l)
                            label.set_text(candle_trace.l_l, str.tostring(candle.l))
    candleSet


//-----------------------------------------------------------------------------
// Calculate & Render
//-----------------------------------------------------------------------------
int candle_cnt = 0
int candle_last = candle_helper.CandleHTFEnabled()

int candle_offset = candle_settings.offset
if candle_htf1.settings.show and candle_helper.CandleValidTimeframe(candle_htf1.settings.htf)
    bool showTrace = false
    if candle_settings.trace_anchor == 'First Timeframe'
        showTrace := true
        showTrace
    if candle_settings.trace_anchor == 'Last Timeframe' and candle_settings.max_sets == 1
        showTrace := true
        showTrace
    candle_htf1.CandleUpdateTime(candle_offset)
    candle_htf1.CandleMonitor().CandleUpdate(candle_offset, showTrace).CandleFindImbalance()
    candle_cnt := candle_cnt + 1
    candle_offset := candle_offset + (candle_cnt > 0 ? candle_htf1.candles.size() * candle_settings.width + (candle_htf1.candles.size() > 0 ? (candle_htf1.candles.size() - 1) * candle_settings.buffer : 0) + candle_settings.htf_buffer : 0)
    candle_offset
if candle_htf2.settings.show and candle_helper.CandleValidTimeframe(candle_htf2.settings.htf) and candle_cnt < candle_last
    bool showTrace = false
    if candle_settings.trace_anchor == 'First Timeframe' and candle_cnt == 0
        showTrace := true
        showTrace
    if candle_settings.trace_anchor == 'Last Timeframe' and candle_cnt == candle_last - 1
        showTrace := true
        showTrace
    candle_htf2.CandleUpdateTime(candle_offset)
    candle_htf2.CandleMonitor().CandleUpdate(candle_offset, showTrace).CandleFindImbalance()
    candle_cnt := candle_cnt + 1
    candle_offset := candle_offset + (candle_cnt > 0 ? candle_htf2.candles.size() * candle_settings.width + (candle_htf2.candles.size() > 0 ? (candle_htf2.candles.size() - 1) * candle_settings.buffer : 0) + candle_settings.htf_buffer : 0)
    candle_offset
if candle_htf3.settings.show and candle_helper.CandleValidTimeframe(candle_htf3.settings.htf) and candle_cnt < candle_last
    bool showTrace = false
    if candle_settings.trace_anchor == 'First Timeframe' and candle_cnt == 0
        showTrace := true
        showTrace
    if candle_settings.trace_anchor == 'Last Timeframe' and candle_cnt == candle_last - 1
        showTrace := true
        showTrace
    candle_htf3.CandleUpdateTime(candle_offset)
    candle_htf3.CandleMonitor().CandleUpdate(candle_offset, showTrace).CandleFindImbalance()
    candle_cnt := candle_cnt + 1
    candle_offset := candle_offset + (candle_cnt > 0 ? candle_htf3.candles.size() * candle_settings.width + (candle_htf3.candles.size() > 0 ? (candle_htf3.candles.size() - 1) * candle_settings.buffer : 0) + candle_settings.htf_buffer : 0)
    candle_offset
if candle_htf4.settings.show and candle_helper.CandleValidTimeframe(candle_htf4.settings.htf) and candle_cnt < candle_last
    bool showTrace = false
    if candle_settings.trace_anchor == 'First Timeframe' and candle_cnt == 0
        showTrace := true
        showTrace
    if candle_settings.trace_anchor == 'Last Timeframe' and candle_cnt == candle_last - 1
        showTrace := true
        showTrace
    candle_htf4.CandleUpdateTime(candle_offset)
    candle_htf4.CandleMonitor().CandleUpdate(candle_offset, showTrace).CandleFindImbalance()
    candle_cnt := candle_cnt + 1
    candle_offset := candle_offset + (candle_cnt > 0 ? candle_htf4.candles.size() * candle_settings.width + (candle_htf4.candles.size() > 0 ? (candle_htf4.candles.size() - 1) * candle_settings.buffer : 0) + candle_settings.htf_buffer : 0)
    candle_offset
if candle_htf5.settings.show and candle_helper.CandleValidTimeframe(candle_htf5.settings.htf) and candle_cnt < candle_last
    bool showTrace = false
    if candle_settings.trace_anchor == 'First Timeframe' and candle_cnt == 0
        showTrace := true
        showTrace
    if candle_settings.trace_anchor == 'Last Timeframe' and candle_cnt == candle_last - 1
        showTrace := true
        showTrace
    candle_htf5.CandleUpdateTime(candle_offset)
    candle_htf5.CandleMonitor().CandleUpdate(candle_offset, showTrace).CandleFindImbalance()
    candle_cnt := candle_cnt + 1
    candle_offset := candle_offset + (candle_cnt > 0 ? candle_htf5.candles.size() * candle_settings.width + (candle_htf5.candles.size() > 0 ? (candle_htf5.candles.size() - 1) * candle_settings.buffer : 0) + candle_settings.htf_buffer : 0)
    candle_offset
if candle_htf6.settings.show and candle_helper.CandleValidTimeframe(candle_htf6.settings.htf) and candle_cnt < candle_last
    bool showTrace = false
    if candle_settings.trace_anchor == 'First Timeframe' and candle_cnt == 0
        showTrace := true
        showTrace
    if candle_settings.trace_anchor == 'Last Timeframe'
        showTrace := true
        showTrace
    candle_htf6.CandleUpdateTime(candle_offset)
    candle_htf6.CandleMonitor().CandleUpdate(candle_offset, showTrace).CandleFindImbalance()

//-----------------------------------------------------------------------------