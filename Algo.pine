// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tamth_

//@version=6
indicator("Algo", overlay=true, precision=2, max_labels_count=500, max_lines_count=500, max_boxes_count=1000, max_bars_back=1000)


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
// Colors
color TRANSPARENT_COLOR = color.new(#000000, 100)
color WHITE_COLOR      = #ffffff
color BLACK_COLOR      = #000000
color RED_COLOR        = #F72585
color ORANGE_COLOR     = #fb5607
color YELLOW_COLOR     = #ffbe0b
color GREEN_COLOR      = #2a9d8f
color AQUA_COLOR       = #4CC9F0
color BLUE_COLOR       = #4895EF
color PURPLE_COLOR     = #3F37C9
color PINK_COLOR       = #B5179E
color LIGHT_GRAY_COLOR = #364156
color DARK_GRAY_COLOR  = #212d40
color TEXT_COLOR       = #ced4da

//-----------------------------------------------------------------------------
// Common Variables
//-----------------------------------------------------------------------------
// Bar index and input
series int barIdx = bar_index

//-----------------------------------------------------------------------------
// Common Methods
//-----------------------------------------------------------------------------
// Debug label function
debug(simple string txt) =>
    var label lbl = label.new(barIdx, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, WHITE_COLOR, size.large, text.align_left)
    label.set_xy(lbl, barIdx, ta.highest(10)[1])
    label.set_text(lbl, txt)

//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// KAMAs
//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------
kamaCommonGrp   = "kamaCommonGrp"
kamaGrp         = "Kaufman Adaptive Moving Average"
kamaSrc         = input.source(close, title = "Source", group = kamaGrp, inline = kamaCommonGrp)
kamaShowed      = input.bool(true, "", group = kamaGrp, inline = kamaCommonGrp)

kama1Grp        = "KAMA 1"
kama1Tf         = input.timeframe("", title = "K1", group = kamaGrp, inline = kama1Grp)
kama1Len        = input.int(21, title = "", group = kamaGrp, inline = kama1Grp)
kama1FastEmaLen = input.int(2, title = "", group = kamaGrp, inline = kama1Grp)
kama1SlowEmaLen = input.int(30, title = "", group = kamaGrp, inline = kama1Grp)
kama1Showed     = input.bool(true, title = "", group = kamaGrp, inline = kama1Grp)

kama2Grp        = "KAMA 2"
kama2Tf         = input.timeframe("", title = "K2", group = kamaGrp, inline = kama2Grp)
kama2Len        = input.int(21, title = "", group = kamaGrp, inline = kama2Grp)
kama2FastEmaLen = input.int(2, title = "", group = kamaGrp, inline = kama2Grp)
kama2SlowEmaLen = input.int(30, title = "", group = kamaGrp, inline = kama2Grp)
kama2Showed     = input.bool(true, title = "", group = kamaGrp, inline = kama2Grp)

//-----------------------------------------------------------------------------
// Methods
//-----------------------------------------------------------------------------
getKama(src, len, fastEmaLen, slowEmaLen) =>
    mom = math.abs(ta.change(src, len))
    volatility = math.sum(math.abs(ta.change(src)), len)
    efficiencyRatio = volatility != 0 ? mom / volatility : 0
    fastAlpha = 2 / (fastEmaLen + 1)
    slowAlpha = 2 / (slowEmaLen + 1)
    alpha = math.pow(efficiencyRatio * (fastAlpha - slowAlpha) + slowAlpha, 2)
    kama = 0.0
    kama := alpha * src + (1 - alpha) * nz(kama[1], src)

getDefHtf() =>
    switch timeframe.period
        "3"   => "30"
		"5"   => "60"
		"15"  => "240"
        "30"  => "480"
		"60"  => "D"
		"240" => "W"
        "1D"  => "M"
        "1M"  => "12M"

//-----------------------------------------------------------------------------
// Calculate
//-----------------------------------------------------------------------------
kama1 = request.security(syminfo.tickerid, kama1Tf, getKama(kamaSrc, kama1Len, kama1FastEmaLen, kama1SlowEmaLen), gaps = barmerge.gaps_on, lookahead = barmerge.lookahead_off)
kama2 = request.security(syminfo.tickerid, kama2Tf != "" ? kama2Tf : getDefHtf(), getKama(kamaSrc, kama2Len, kama2FastEmaLen, kama2SlowEmaLen), gaps = barmerge.gaps_on, lookahead = barmerge.lookahead_off)

//-----------------------------------------------------------------------------
// Render
//-----------------------------------------------------------------------------
plot(kamaShowed and kama1Showed ? kama1 : na, title = "KAMA 1", linewidth = 1, color = AQUA_COLOR, display = display.pane)
plot(kamaShowed and kama2Showed ? kama2 : na, title = "KAMA 2", linewidth = 1, color = PURPLE_COLOR, display = display.pane)

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Delta Volume Profile
//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------
dvpGrp = "Delta Volume Profile"
dvpShowed = input.bool(true, "Show", group=dvpGrp)
dvpLookback = input.int(300, group=dvpGrp)
dvpPlusColor = input.color(PINK_COLOR, "Volume +", group=dvpGrp)
dvpMinusColor = input.color(PURPLE_COLOR, "Volume -", group=dvpGrp)

//-----------------------------------------------------------------------------
// Calculate & Render
//-----------------------------------------------------------------------------
dvpMaxMin = array.new<float>()
dvpStep = 0.
dvpBins = 0

dvpAtr = ta.atr(200)

if barstate.islast
    for i = 0 to dvpLookback-1

        h = high[i]
        l = low[i]

        dvpMaxMin.push(h)
        dvpMaxMin.push(l)

    dvpBins := int((dvpMaxMin.max() - dvpMaxMin.min()) / dvpAtr)
    dvpStep := (dvpMaxMin.max() - dvpMaxMin.min()) / dvpBins

dvpVolPlus = array.new<float>(dvpBins, 0)
dvpVolMinus = array.new<float>(dvpBins, 0)

if barstate.islast
    for i = 0 to dvpLookback-1
        h = high[i]
        l = low[i]
        c = close[i]
        o = open[i]
        v = volume[i]

        for k = 0 to dvpBins - 1

            loww = dvpMaxMin.min() + dvpStep * k
            mid = loww + dvpStep/2

            if h > mid and l < mid 
                if c > o
                    dvpVolPlus.set(k, dvpVolPlus.get(k) + v)
                else
                    dvpVolMinus.set(k, dvpVolMinus.get(k) + v)

var dvpBoxes = array.new<box>()
var dvpLabels = array.new<label>()

if barstate.islast
    if dvpBoxes.size() >= 0
        for b in dvpBoxes
            box.delete(b)
        dvpBoxes.clear()

    if dvpLabels.size() >= 0
        for l in dvpLabels
            label.delete(l)
        dvpLabels.clear()

    for i = 0 to dvpBins - 1
        loww = dvpMaxMin.min() + dvpStep * i
        highh = loww + dvpStep

        value_plus = int(dvpVolPlus.get(i) / dvpVolPlus.sum()*200)
        value_minus = int(dvpVolMinus.get(i) / dvpVolMinus.sum()*200)

        max_plus = dvpVolPlus.get(i) == dvpVolPlus.max()
        dvpMaxMinus = dvpVolMinus.get(i) == dvpVolMinus.max()

        col_plus = color.from_gradient(dvpVolPlus.get(i), dvpVolPlus.min(), dvpVolPlus.max(), color.new(dvpPlusColor, 90), color.new(dvpPlusColor, 30))
        col_minus = color.from_gradient(dvpVolMinus.get(i), dvpVolMinus.min(), dvpVolMinus.max(), color.new(dvpMinusColor, 90), color.new(dvpMinusColor, 30))

        sum = value_plus + value_minus
        tot = dvpVolPlus.sum() + dvpVolMinus.sum()

        delta = ((dvpVolPlus.sum() - dvpVolMinus.sum()) / dvpVolMinus.sum()) * 100

        b1=box.new(bar_index+50, highh, bar_index+50-value_plus, loww, chart.bg_color, bgcolor = max_plus ? dvpPlusColor : col_plus, text =  dvpVolPlus.get(i) != 0 ? "+"+str.tostring(dvpVolPlus.get(i), format.volume) : "", text_color = TEXT_COLOR, text_size = size.small, text_halign = text.align_right)
        b2=box.new(bar_index+50, highh, bar_index+50+value_minus, loww, chart.bg_color, bgcolor = dvpMaxMinus ? dvpMinusColor : col_minus, text = dvpVolMinus.get(i) != 0 ? "-"+str.tostring(dvpVolMinus.get(i), format.volume) : "", text_color = TEXT_COLOR, text_size = size.small, text_halign = text.align_left)

        dvpBoxes.push(b1)
        dvpBoxes.push(b2)

        l1=label.new(bar_index+50, dvpMaxMin.max(), "Delta: "+ str.tostring(delta, format.percent), color = delta > 0 ? dvpPlusColor : dvpMinusColor, textcolor = TEXT_COLOR, style = label.style_label_down, size = size.small)
        // l2=label.new(bar_index+50, dvpMaxMin.min(), "Total: "+ str.tostring(tot, format.volume), color = LIGHT_GRAY_COLOR, textcolor = TEXT_COLOR, style = label.style_label_up)

        dvpLabels.push(l1)
        // dvpLabels.push(l2)

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Session Volume Profile
//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------
svpGrp = "Session Volume Profile"
sessionType = input.string('Daily', 'Session Type', options=['Daily','Weekly', 'Monthly', 'Quarterly', 'Yearly'], group=svpGrp)
svpShowed = input.bool(true, 'Show', group=svpGrp)
svpPocShowed = input.bool(false, 'Show POC', group=svpGrp)
svpRes = input.int(70, 'Resolution', minval=5, tooltip='The higher the value, the more refined of a profile, but less profiles shown on chart', group=svpGrp)
svpVavWid = input.int(100, 'Value Area Volume %', minval=1, maxval=100, group=svpGrp)
svpTf = input.timeframe('', 'Timeframe', group=svpGrp)
svpColor = input.color(LIGHT_GRAY_COLOR, 'Color', group=svpGrp)
svpPocColor = input.color(ORANGE_COLOR, 'POC', inline='p', group=svpGrp)
svpVahColor = input.color(DARK_GRAY_COLOR, 'VAH', inline='h', group=svpGrp)
svpValColor = input.color(DARK_GRAY_COLOR, 'VAL', inline='l', group=svpGrp)

//-----------------------------------------------------------------------------
// Values
//-----------------------------------------------------------------------------
var int svpZoneStart = 0
int svpLookBack = bar_index - svpZoneStart
var svpActiveZone = false

// Defining arrays that store the information
var svpVpGreen = array.new_float(svpRes, 0) // Sum of volume on long bars
var svpVpRed = array.new_float(svpRes, 0) // Same thing but with red bars
var svpZoneBounds = array.new_float(svpRes, 0) // Array that stores the highest value that can be in a zone

// Values to store current intra bar data
var float[] svpLtfOpen =  array.new_float(0)
var float[] svpLtfClose =  array.new_float(0)
var float[] svpLtfHigh =  array.new_float(0)
var float[] svpLtfLow =  array.new_float(0)
var float[] svpLtfVol = array.new_float(0)

// Getting intrabar intial data
[svpDO, svpDC, svpDH, svpDL, svpDV] = request.security_lower_tf(syminfo.tickerid, svpTf, [open, close, high, low, volume])

//-----------------------------------------------------------------------------
// Methods
//-----------------------------------------------------------------------------
svpResetProfile(enable) =>
    if enable
        array.fill(svpVpGreen, 0)
        array.fill(svpVpRed, 0)
        array.clear(svpLtfOpen)
        array.clear(svpLtfHigh)
        array.clear(svpLtfLow)
        array.clear(svpLtfClose)
        array.clear(svpLtfVol)

svpProfHigh = ta.highest(high, svpLookBack+1)[1]
svpProfLow = ta.lowest(low, svpLookBack+1)[1]

svpGetVol(y11, y12, y21, y22, height, vol) =>
    nz(math.max(math.min(math.max(y11, y12), math.max(y21, y22)) - math.max(math.min(y11, y12), math.min(y21, y22)), 0) * vol / height)

svpAddProfile(o, h, l, c, v, g, w) =>
    // Array to store how much to distribute in each zone, on scale of 1 for full gap size to 0
    zoneDist = array.new_float(svpRes, 0)
    distSum = 0.0
    // Going over each zone
    for i = 0 to array.size(svpVpGreen) - 1
        // Checking to see if cur bar is in zone
        zoneTop = array.get(svpZoneBounds, i)
        zoneBot = zoneTop - g

        body_top = math.max(c, o)
        body_bot = math.min(c, o)
        itsgreen = c >= o

        topwick = h - body_top
        bottomwick = body_bot - l
        body = body_top - body_bot

        bodyvol = body * v / (2 * topwick + 2 * bottomwick + body)
        topwickvol = 2 * topwick * v / (2 * topwick + 2 * bottomwick + body)
        bottomwickvol = 2 * bottomwick * v / (2 * topwick + 2 * bottomwick + body)

        array.set(svpVpGreen, i, array.get(svpVpGreen, i) + (itsgreen ? svpGetVol(zoneBot, zoneTop, body_bot, body_top, body, bodyvol) : 0) + svpGetVol(zoneBot, zoneTop, body_top, h, topwick, topwickvol) / 2 + svpGetVol(zoneBot, zoneTop, body_bot, l, bottomwick, bottomwickvol) / 2)
        array.set(svpVpRed, i, array.get(svpVpRed, i) + (itsgreen ? 0 : svpGetVol(zoneBot, zoneTop, body_bot, body_top, body, bodyvol)) + svpGetVol(zoneBot, zoneTop, body_top, h, topwick, topwickvol) / 2 + svpGetVol(zoneBot, zoneTop, body_bot, l, bottomwick, bottomwickvol) / 2)

svpCalcSession(update) =>
    array.fill(svpVpGreen, 0)
    array.fill(svpVpRed, 0)
    if bar_index > svpLookBack and update
        gap = (svpProfHigh - svpProfLow) / svpRes

        // Defining profile bounds
        for i = 0 to svpRes - 1
            array.set(svpZoneBounds, i, svpProfHigh - gap * i)

        // Putting each bar inside zone into the volume profile array
        if array.size(svpLtfOpen) > 0
            for j = 0 to array.size(svpLtfOpen) - 1    
                svpAddProfile(array.get(svpLtfOpen, j), array.get(svpLtfHigh, j), array.get(svpLtfLow, j), array.get(svpLtfClose, j), array.get(svpLtfVol, j), gap, 1)

svpGetPocLevel() =>
    float maxVol = 0
    int levelInd = 0
    for i = 0 to array.size(svpVpRed) - 1
        if array.get(svpVpRed, i) + array.get(svpVpGreen, i) > maxVol
            maxVol := array.get(svpVpRed, i) + array.get(svpVpGreen, i)
            levelInd := i
    
    float outLevel = na
    if levelInd != array.size(svpVpRed) - 1
        outLevel := array.get(svpZoneBounds, levelInd) - (array.get(svpZoneBounds, levelInd) - array.get(svpZoneBounds, levelInd+1)) / 2
    outLevel

svpGetValLevels(poc) =>
    float gap = (svpProfHigh - svpProfLow) / svpRes
    float volSum = array.sum(svpVpRed) + array.sum(svpVpGreen)
    float volCnt = 0
    
    float vah = svpProfHigh
    float val = svpProfLow

    //Finding poc index
    int pocInd = 0
    for i = 0 to array.size(svpZoneBounds)-2
        if array.get(svpZoneBounds, i) >= poc and array.get(svpZoneBounds, i + 1) < poc
            pocInd := i
    
    volCnt += (array.get(svpVpRed, pocInd) + array.get(svpVpGreen, pocInd))
    for i = 1 to array.size(svpVpRed)
        if pocInd + i >= 0 and pocInd + i < array.size(svpVpRed)    
            volCnt += (array.get(svpVpRed, pocInd + i) + array.get(svpVpGreen, pocInd + i))
            if volCnt >= volSum * (svpVavWid/100)    
                break 
            else
                val := array.get(svpZoneBounds, pocInd + i) - gap
        if pocInd - i >= 0 and pocInd - i < array.size(svpVpRed)    
            volCnt += (array.get(svpVpRed, pocInd - i) + array.get(svpVpGreen, pocInd - i))
            if volCnt >= volSum * (svpVavWid/100)    
                break 
            else
                vah := array.get(svpZoneBounds, pocInd - i)

    [val, vah]

svpDrawNewZone(update) =>
    if bar_index > svpLookBack and update and array.sum(svpVpGreen) + array.sum(svpVpRed) > 0
        gap = (svpProfHigh - svpProfLow) / svpRes
        float leftMax = bar_index[svpLookBack]
        float rightMax = bar_index[int(svpLookBack / 1.4)]
        float rightMaxVol = array.max(svpVpGreen)+array.max(svpVpRed)
        float buffer = gap / 10

        if svpShowed
            for i = 0 to array.size(svpVpRed) - 1
                greenEnd = int(leftMax + (rightMax - leftMax) * (array.get(svpVpGreen, i) / rightMaxVol))
                redEnd = int(greenEnd + (rightMax - leftMax) * (array.get(svpVpRed, i) / rightMaxVol))
                box.new(int(leftMax), array.get(svpZoneBounds, i) - buffer, redEnd, array.get(svpZoneBounds, i) - gap + buffer, bgcolor=svpColor, border_width=0)

        poc = svpGetPocLevel()
        [val, vah] = svpGetValLevels(poc)
        if svpPocShowed
            line.new(int(leftMax), poc, bar_index-1, poc, color=svpPocColor, width=1)

svpDrawCurZone(update, delete) =>
    var line pocLine = na
    var line vahLine = na
    var line valLine = na
    var box outBox = na
    var label sessionLab = na

    var redBoxes = array.new_box(array.size(svpVpRed), na)
    var greenBoxes = array.new_box(array.size(svpVpRed), na)

    if bar_index > svpLookBack and update and array.sum(svpVpGreen) + array.sum(svpVpRed) > 0
        // Clearing the previous boxes and array
        if not na(pocLine)
            line.delete(pocLine)
        if not na(vahLine)
            line.delete(vahLine)
        if not na(valLine)
            line.delete(valLine)
        if not na(outBox)
            box.delete(outBox)
        if not na(sessionLab)
            label.delete(sessionLab)

        for i = 0 to array.size(redBoxes) - 1
            if not na(array.get(redBoxes, i))
                box.delete(array.get(redBoxes, i))
                box.delete(array.get(greenBoxes, i))

        gap = (svpProfHigh - svpProfLow) / svpRes
        float leftMax = bar_index[svpLookBack]
        float rightMax = bar_index[int(svpLookBack / 1.4)]
        float rightMaxVol = array.max(svpVpGreen)+array.max(svpVpRed)
        float buffer = gap / 10
        if svpShowed
            for i = 0 to array.size(svpVpRed) - 1
                greenEnd = int(leftMax + (rightMax - leftMax) * (array.get(svpVpGreen, i) / rightMaxVol))
                redEnd = int(greenEnd + (rightMax - leftMax) * (array.get(svpVpRed, i) / rightMaxVol))
                array.set(greenBoxes, i, box.new(int(leftMax), array.get(svpZoneBounds, i) - buffer, redEnd, array.get(svpZoneBounds, i) - gap + buffer, bgcolor=svpColor, border_width=0))
        
        poc = svpGetPocLevel()
        [val, vah] = svpGetValLevels(poc)
        if svpPocShowed    
            line.delete(pocLine)
            pocLine := line.new(int(leftMax), poc, bar_index-1, poc, color=svpPocColor, width=1)

    if delete
        box.delete(outBox)
        line.delete(pocLine)
        line.delete(vahLine)
        line.delete(valLine)
        for i = 0 to array.size(greenBoxes)-1
            box.delete(array.get(greenBoxes, i))
        for i = 0 to array.size(redBoxes)-1
            box.delete(array.get(redBoxes, i))

svpUpdateIntra(o, h, l, c, v) =>
    if array.size(o) > 0
        for i = 0 to array.size(o) - 1
            array.push(svpLtfOpen, array.get(o, i))
            array.push(svpLtfHigh,array.get(h, i)) 
            array.push(svpLtfLow,array.get(l, i)) 
            array.push(svpLtfClose,array.get(c, i)) 
            array.push(svpLtfVol,array.get(v, i))
    
//-----------------------------------------------------------------------------
// Calculate
//-----------------------------------------------------------------------------
// Detecting different start dates
svpNewDaily = dayofweek != dayofweek[1]
svpNewWeekly = weekofyear != weekofyear[1]
svpNewMonthly = (dayofmonth != dayofmonth[1] + 1) and (dayofmonth != dayofmonth[1])
svpNewYearly = year != year[1]
svpNewQuarterly = month != month[1] and (month - 1) % 3 == 0

svpUtcHour = hour(time(timeframe.period, '0000-2400', 'GMT'), 'GMT')

svpNewSession = switch sessionType
    'Daily' => svpNewDaily
    'Weekly' => svpNewWeekly
    'Monthly' => svpNewMonthly
    'Yearly' => svpNewYearly
    'Quarterly' => svpNewQuarterly
    => svpNewDaily

svpZoneEnd = switch sessionType
    'Daily' => svpNewDaily
    'Weekly' => svpNewWeekly
    'Monthly' => svpNewMonthly
    'Yearly' => svpNewYearly
    'Quarterly' => svpNewQuarterly
    => svpNewDaily

//-----------------------------------------------------------------------------
// Render
//-----------------------------------------------------------------------------
// Re calculating and drawing zones
svpCalcSession(svpZoneEnd or (barstate.islast))
svpDrawNewZone(svpZoneEnd)
svpDrawCurZone(barstate.islast and not svpZoneEnd and svpActiveZone, svpZoneEnd)

// Reseting profie at start of new zone
svpResetProfile(svpNewSession)

// Updating data arrays
svpUpdateIntra(svpDO, svpDH, svpDL, svpDC, svpDV)

// Reseting zone start value
if svpZoneEnd 
    svpActiveZone := false

if svpNewSession
    svpZoneStart := bar_index
    svpActiveZone := true

//-----------------------------------------------------------------------------