// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© tamth_

//@version=6
indicator("Oscillator", overlay=false, max_bars_back=5000, max_lines_count=500, max_boxes_count=1000, max_labels_count=500)

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
color TRANSPARENT_COLOR = #ffffff00
color WHITE_COLOR       = #dee2e6
color BLACK_COLOR       = #000000
color RED_COLOR         = #F72585
color ORANGE_COLOR      = #fb5607
color YELLOW_COLOR      = #ffbe0b
color GREEN_COLOR       = #2a9d8f
color AQUA_COLOR        = #4CC9F0
color BLUE_COLOR        = #4361ee
color PURPLE_COLOR      = #3F37C9
color PINK_COLOR        = #B5179E
color LIGHT_GRAY_COLOR  = #364156
color DARK_GRAY_COLOR   = #212d40
color TEXT_COLOR        = #ced4da

//-----------------------------------------------------------------------------
// Tooltip
//-----------------------------------------------------------------------------
string tt_stoch = "The first value is the lookback length for your traditional Stochastic Oscillator. The second is the smoothing length."
string tt_disp = "The dropdown is a selection of methods of calculating dispersion. The box that follows is the lookback length to measure."
string tt_straddle = "This value defines the size of the 'straddle box' where price is within consolidation and the limits where it breaks out."
string tt_barcolor = "Check this box if you want to color candles/bars similar to the color of the Price Action Index."

//-----------------------------------------------------------------------------
// HTF Framework
//-----------------------------------------------------------------------------
TF0 = "None"
TF1 = "Auto-Steps (15min, 60min, 4H, 1D, 3D, 1W, 1M, 12M)"
TF2 = "Multiple Of Current TF"
TF3 = "Fixed TF"
i_htfRepaints = input.bool(false, "Repaint HTF", group="âŒš Time Frame âŒš")
i_htfType = input.string(TF0, "Higher Timeframe Selection", options=[TF0, TF1, TF2, TF3], group="âŒš Time Frame âŒš")
i_htfType2 = input.float(3., "Multiple of Current TF", minval=1, group="âŒš Time Frame âŒš")
i_htfType3 = input.timeframe("D", "Fixed TF", group="âŒš Time Frame âŒš")

var htfOn = i_htfType != TF0

//-----------------------------------------------------------------------------
// HTF Functions
//-----------------------------------------------------------------------------
// â€”â€”â€”â€”â€” Converts current "timeframe.multiplier" plus the TF into minutes of type float.
f_resInMinutes() =>
    _resInMinutes = timeframe.multiplier * (timeframe.isseconds ? 1. / 60. : timeframe.isminutes ? 1. : timeframe.isdaily ? 1440. : timeframe.isweekly ? 10080. : timeframe.ismonthly ? 43800. : na)

// â€”â€”â€”â€”â€” Returns resolution of _resolution period in minutes.
f_tfResInMinutes(_resolution) =>
    request.security(syminfo.tickerid, _resolution, f_resInMinutes())

// â€”â€”â€”â€”â€” Given current resolution, returns next step of HTF.
f_resNextStep(_res) =>
    _res <= 1 ? "15" : _res <= 5 ? "60" : _res <= 30 ? "240" : _res <= 60 ? "1D" : _res <= 360 ? "3D" : _res <= 1440 ? "1W" : _res <= 10080 ? "1M" : "12M"

// â€”â€”â€”â€”â€” Returns a multiple of current resolution as a string in "timeframe.period" format usable with "security()".
f_multipleOfRes(_res, _mult) =>
    _targetResInMin = _res * math.max(_mult, 1)
    _targetResInMin <= 0.083 ? "5S" : _targetResInMin <= 0.251 ? "15S" : _targetResInMin <= 0.501 ? "30S" : _targetResInMin <= 1440 ? str.tostring(math.round(_targetResInMin)) : _targetResInMin <= 43800 ? str.tostring(math.round(math.min(_targetResInMin / 1440, 365))) + "D" : str.tostring(math.round(math.min(_targetResInMin / 43800, 12))) + "M"

//-----------------------------------------------------------------------------
// HTF Calc
//-----------------------------------------------------------------------------
// Get current resolution in float minutes.
var resInMinutes = f_resInMinutes()
// Get HTF from user-defined mode.
var htf = i_htfType == TF0 ? timeframe.period : i_htfType == TF1 ? f_resNextStep(resInMinutes) : i_htfType == TF2 ? f_multipleOfRes(resInMinutes, i_htfType2) : i_htfType3

//-----------------------------------------------------------------------------
// Dispersion Functions
//-----------------------------------------------------------------------------
string dis0 = "Standard Deviation"
f_dis0(src, len) => ta.stdev(src, len)
string dis1 = "Variance"
f_dis1(src, len) => ta.variance(src, len)
string dis2 = "Coefficient of Variation"
f_dis2(src, len) => ta.stdev(src, len) / ta.sma(src, len)
string dis3 = "Signal-to-Noise"
f_dis3(src, len) => ta.sma(src, len) / ta.stdev(src, len)
string dis4 = "Signal-to-NoiseÂ²"
f_dis4(src, len) => math.pow(ta.sma(src, len), 2) / math.pow(ta.stdev(src, len), 2)
string dis5 = "Index of Dispersion"
f_dis5(src, len) => math.pow(ta.variance(src, len), 2) / ta.sma(src, len)
string dis6 = "Efficiency"
f_dis6(src, len) => math.pow(ta.stdev(src, len), 2) / math.pow(ta.sma(src, len), 2)
string dis7 = "High-Low Range"
f_dis7(src, len) => ta.highest(len) - ta.lowest(len)

//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------
src = input.source(defval=close, title="Source", group="âŒ¨ï¸ Inputs ðŸ–±")
len = input.int(defval=20, title="Stochastic", group="âŒ¨ï¸ Inputs ðŸ–±", inline="Stoch")
smooth = input.int(defval=3, title="", group="âŒ¨ï¸ Inputs ðŸ–±", inline="Stoch", tooltip=tt_stoch)
dis_method = input.string(dis0, options=[dis0, dis1, dis2, dis3, dis4, dis5, dis6, dis7], title="Dispersion", group="âŒ¨ï¸ Inputs ðŸ–±", inline="Dispersion")
dis_len = input.int(defval=20, title="", group="âŒ¨ï¸ Inputs ðŸ–±", inline="Dispersion", tooltip=tt_disp)

straddle_area = input.float(defval=5.0, title="ðŸ§² Straddle Area â›”", group="Outputs & Alerts", tooltip=tt_straddle)
use_bar_colors = input.bool(defval=false, title="ðŸŽ¨ Use Bar Colors ðŸŽ¨", group="Outputs & Alerts", tooltip=tt_barcolor)
use_alerts = input.bool(defval=false, title="ðŸ”‡ Use Alerts ðŸ”Š", group="Outputs & Alerts")
alerts_breakouts = input.bool(defval=false, title="ðŸ“ˆ Breakouts ðŸ“‰", group="Outputs & Alerts", inline="Alerts")
alerts_extremes = input.bool(defval=false, title="âš ï¸ Tops/Bottoms âš ï¸", group="Outputs & Alerts", inline="Alerts")

//-----------------------------------------------------------------------------
// Divergence Settings
//-----------------------------------------------------------------------------
lbR = input(title="Pivot Lookback Right", defval=2, group="Divergence Indicator")
lbL = input(title="Pivot Lookback Left", defval=2, group="Divergence Indicator")
rangeUpper = input(title="Max of Lookback Range", defval=10, group="Divergence Indicator")
rangeLower = input(title="Min of Lookback Range", defval=2, group="Divergence Indicator")
plotBull = input(title="Plot Bullish", defval=false, group="Divergence Indicator")
plotHiddenBull = input(title="Plot Hidden Bullish", defval=false, group="Divergence Indicator")
plotBear = input(title="Plot Bearish", defval=false, group="Divergence Indicator")
plotHiddenBear = input(title="Plot Hidden Bearish", defval=false, group="Divergence Indicator")
bearColor = RED_COLOR
bullColor = GREEN_COLOR
hiddenBullColor = color.new(GREEN_COLOR, 80)
hiddenBearColor = color.new(RED_COLOR, 80)
textColor = TEXT_COLOR
noneColor = TRANSPARENT_COLOR

//-----------------------------------------------------------------------------
// Calculate
//-----------------------------------------------------------------------------
pai(src, disp, len) =>
    _disp = f_dis0(src, dis_len)
    if dis_method == dis1
        _disp := f_dis1(src, dis_len)
    else
        if dis_method == dis2
            _disp := f_dis2(src, dis_len)
        else
            if dis_method == dis3
                _disp := -f_dis3(src, dis_len)
            else
                if dis_method == dis4
                    _disp := -f_dis4(src, dis_len)
                else
                    if dis_method == dis5
                        _disp := f_dis5(src, dis_len)
                    else
                        if dis_method == dis6
                            _disp := f_dis6(src, dis_len)
                        else
                            if dis_method == dis7
                                _disp := f_dis7(src, dis_len)
    
    P = src == close ? ((ta.sma(ta.stoch(close, high, low, len), smooth) - 50) / 50) : ((ta.sma(ta.stoch(src, src, src, len), smooth) - 50) / 50)
    V = ta.stoch(_disp, _disp, _disp, len)
    P * V

f_security(_sym, _res, _src, _rep) => request.security(_sym, _res, _src[not _rep and barstate.isrealtime ? 1 : 0])[_rep or barstate.isrealtime ? 0 : 1]
Z = not htfOn ? pai(src, dis_len, len) : f_security(syminfo.tickerid, htf, pai(src, dis_len, len), i_htfRepaints)

//-----------------------------------------------------------------------------
// Output
//-----------------------------------------------------------------------------
straddle = Z < straddle_area and Z > -straddle_area
rally = Z > 40
draw = Z < -40

color col = color.black
if straddle
    col := PINK_COLOR
if Z > straddle_area
    col := AQUA_COLOR
if Z < -straddle_area
    col := PURPLE_COLOR

//-----------------------------------------------------------------------------
// Plots
//-----------------------------------------------------------------------------
plot(Z, color=col, title="Price Action Index", display = display.pane)

// st_ = hline(straddle_area, color=color.new(PINK_COLOR, 50), linestyle = hline.style_solid, title="Straddle Area")
// sb_ = hline(-straddle_area, color=color.new(PINK_COLOR, 50), linestyle = hline.style_solid, title="Straddle Area")
// fill(st_, sb_, color=straddle ? color.new(PINK_COLOR, 80) : na, title="Straddle Area")

p_ob1 = hline(80, color=color.new(LIGHT_GRAY_COLOR, 30), linestyle = hline.style_dotted, title="Overbought Area")
p_ob2 = hline(100, color=TRANSPARENT_COLOR, title="Overbought Area")
fill(p_ob1, p_ob2, color=rally ? color.new(RED_COLOR, 85) : na, title="Overbought Area")

p_os1 = hline(-80, color=color.new(LIGHT_GRAY_COLOR, 30), linestyle = hline.style_dotted, title="Oversold Area")
p_os2 = hline(-100, color=TRANSPARENT_COLOR, title="Oversold Area")
fill(p_os1, p_os2, color=draw ? color.new(GREEN_COLOR, 85) : na, title="Oversold Area")

barcolor(use_bar_colors ? col : na, editable=false, title="Bar Colors")

//-----------------------------------------------------------------------------
// Divergence Plots
osc = Z
plFound = na(ta.pivotlow(osc, lbL, lbR)) ? false : true
phFound = na(ta.pivothigh(osc, lbL, lbR)) ? false : true
_inRange(cond) =>
    bars = ta.barssince(cond == true)
    rangeLower <= bars and bars <= rangeUpper

// Regular Bullish
// Osc: Higher Low
oscHL = osc[lbR] > ta.valuewhen(plFound, osc[lbR], 1) and _inRange(plFound[1])
// Price: Lower Low
priceLL = low[lbR] < ta.valuewhen(plFound, low[lbR], 1)
bullCond = plotBull and priceLL and oscHL and plFound

plot(plFound ? osc[lbR] : na, offset=-lbR, title="Regular Bullish", linewidth=2, color=(bullCond ? bullColor : noneColor), display = display.pane)

plotshape(bullCond ? osc[lbR] : na, offset=-lbR, title="Regular Bullish Label", text=" Bull ", style=shape.labelup, location=location.absolute, color=bullColor, textcolor=textColor, display = display.pane)

// Hidden Bullish
// Osc: Lower Low
oscLL = osc[lbR] < ta.valuewhen(plFound, osc[lbR], 1) and _inRange(plFound[1])
// Price: Higher Low
priceHL = low[lbR] > ta.valuewhen(plFound, low[lbR], 1)
hiddenBullCond = plotHiddenBull and priceHL and oscLL and plFound

plot(plFound ? osc[lbR] : na, offset=-lbR, title="Hidden Bullish", linewidth=2, color=(hiddenBullCond ? hiddenBullColor : noneColor), display = display.pane)

plotshape(hiddenBullCond ? osc[lbR] : na, offset=-lbR, title="Hidden Bullish Label", text=" H Bull ", style=shape.labelup, location=location.absolute, color=bullColor, textcolor=textColor, display = display.pane)

// Regular Bearish
// Osc: Lower High
oscLH = osc[lbR] < ta.valuewhen(phFound, osc[lbR], 1) and _inRange(phFound[1])
// Price: Higher High
priceHH = high[lbR] > ta.valuewhen(phFound, high[lbR], 1)
bearCond = plotBear and priceHH and oscLH and phFound

plot(phFound ? osc[lbR] : na, offset=-lbR, title="Regular Bearish", linewidth=2, color=(bearCond ? bearColor : noneColor), display = display.pane)

plotshape(bearCond ? osc[lbR] : na, offset=-lbR, title="Regular Bearish Label", text=" Bear ", style=shape.labeldown, location=location.absolute, color=bearColor, textcolor=textColor, display = display.pane)

// Hidden Bearish
// Osc: Higher High
oscHH = osc[lbR] > ta.valuewhen(phFound, osc[lbR], 1) and _inRange(phFound[1])
// Price: Lower High
priceLH = high[lbR] < ta.valuewhen(phFound, high[lbR], 1)
hiddenBearCond = plotHiddenBear and priceLH and oscHH and phFound

plot(phFound ? osc[lbR] : na, offset=-lbR, title="Hidden Bearish", linewidth=2, color=(hiddenBearCond ? hiddenBearColor : noneColor), display = display.pane)

plotshape(hiddenBearCond ? osc[lbR] : na, offset=-lbR, title="Hidden Bearish Label", text=" H Bear ", style=shape.labeldown, location=location.absolute, color=bearColor, textcolor=textColor, display = display.pane)

//-----------------------------------------------------------------------------
// Conditions
cond_bull_breakout = ta.crossover(Z, straddle_area)
cond_bull_top = ta.crossunder(Z, 80)
cond_bear_breakout = ta.crossunder(Z, -straddle_area)
cond_bear_bottom = ta.crossover(Z, -80)

//-----------------------------------------------------------------------------
// Alerts
alertcondition(straddle, title="Straddle Area", message="Inside Straddle Area")
alertcondition(cond_bull_breakout, title="Bullish Breakout", message="Bullish Breakout")
alertcondition(cond_bull_top, title="Bull Top", message="Bull Top")
alertcondition(cond_bear_breakout, title="Bearish Breakout", message="Bearish Breakout")
alertcondition(cond_bear_bottom, title="Bear Bottom", message="Bear Bottom")

if use_alerts
    if cond_bull_breakout
        alert(syminfo.tickerid + "Bullish Breakout")
    if cond_bull_top
        alert(syminfo.tickerid + "Bull Top")
    if cond_bear_breakout
        alert(syminfo.tickerid + "Bearish Breakout")
    if cond_bear_bottom
        alert(syminfo.tickerid + "Bear Bottom")

//-----------------------------------------------------------------------------