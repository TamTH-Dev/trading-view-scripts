// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © tamth_

// @version=5
indicator("Price Action Supporter", "Price Action Supporter", overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, max_bars_back = 500)


//-----------------------------------------------------------------------------{
//Constants
//-----------------------------------------------------------------------------{
color TRANSPARENT_COLOR = #ffffff00
color WHITE_COLOR = #ffffff
color RED_COLOR = #e91e62
color AQUA_COLOR = #00bbf9
color LIGHT_GRAY_COLOR = #364156
color DARK_GRAY_COLOR = #212d40
color GREEN_COLOR = #008170
color PURPLE_COLOR = #764AF1
color YELLOW_COLOR = #f2e40a
color ORANGE_COLOR = #f2aa0a


// Debugger
f_print(simple string txt) =>
    // Create label on the first bar.
    var label = label.new(bar_index, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, color.gray, size.large, text.align_left)
    // On next bars, update the label"s x and y position, and the text it displays.
    label.set_xy(label, bar_index, ta.highest(10)[1])
    label.set_text(label, txt)




//-----------------------------------------------------------------------------{
// Volume Profile
//-----------------------------------------------------------------------------{
// vpLen = input.int(200, "vpSmoothing", 1, 500)
// vpSmoothing = input.int(3, "Smoothing", 1, 6)
// vpPivot = input.int(3, "Peak Sensitivity", 1, 10)
// vpPeakThresh = input.int(80, "Peak Threshold")
// vpScoreLen = input.int(20, "vpMean Score vpSmoothing")
// vpEnableLevels = input.string("POC", "Control Lines", ["POC", "All", "None"])
// vpHighColor = input.color(color.rgb(235, 170, 252), "Histogram Colors", inline = "hist")
// vpLowColor = input.color(color.rgb(163, 46, 192), "", inline = "hist")
// vpTrans = input.int(10, "Transparency", 0, 100)
// vpPOCColor = input.color(color.red, "POC Color", inline = "POC")
// vpLevelColor = input.color(color.rgb(255, 134, 65), "Peak Level Color", inline = "POC")

// vpAlpha = color.new(color.black, 100)


// gamma(float src) =>
//     var float math_LnPi = 1.1447298858494001741434273513530587116472948129153
//     var float math_LogTwoSqrtEOverPi = 0.6207822376352452223455184457816472122518527279025978
//     var float math_TwoSqrtEOverPi = 1.8603827342052657173362492472666631120594218414085755
//     var int GammaN = 10
//     var float GammaR = 10.900511
//     var float[] series_GammaDk = array.from(
//      2.48574089138753565546e-5,
//      1.05142378581721974210,
//      -3.45687097222016235469,
//      4.51227709466894823700,
//      -2.98285225323576655721, 
//      1.05639711577126713077, 
//      -1.95428773191645869583e-1, 
//      1.70970543404441224307e-2, 
//      -5.71926117404305781283e-4, 
//      4.63399473359905636708e-6, 
//      -2.71994908488607703910e-9)

//     float z = src

//     if z < 0.5

//         float s = array.get(series_GammaDk, 0)
//         for int i = 1 to GammaN by 1
//             s += array.get(series_GammaDk, i) / (i - z)
//             s

//         return_Gamma = math.pi / math.sin(math.pi * z) * s * math_TwoSqrtEOverPi * math.pow((0.5 - z + GammaR) / math.e, 0.5 - z)
//         return_Gamma
//     else

//         float s = array.get(series_GammaDk, 0)
//         for int i = 1 to GammaN by 1
//             s += array.get(series_GammaDk, i) / (z + i - 1.0)
//             s

//         return_Gamma = s * math_TwoSqrtEOverPi * math.pow((z - 0.5 + GammaR) / math.e, z - 0.5)
//         return_Gamma

// t_dist_pdf(float x, int v) =>
//     gamma((v + 1) / 2) / (math.sqrt(v * math.pi) * gamma(v / 2)) * math.pow(1 + x * x / v, -(v + 1) / 2)

// rising_factorial(float c, int n) =>
//     float product = 1.0
//     if n > 0
//         for i = 0 to n - 1
//             product *= (c + i)
//     product

// hypergeometric(float a, float b, float c, float z) =>
//     float sum = 0.0
//     for i = 0 to 2
//         sum += rising_factorial(a, i) * rising_factorial(b, i) * math.pow(z, i) / (rising_factorial(c, i) * rising_factorial(i, i))
//     sum

// t_dist_cdf(float x, int v) =>
//     1/2.0 + x * gamma((v+1)/2.0) * (hypergeometric(1/2.0, (v+1)/2.0, 3.0/2, x*x/v) / (math.sqrt(v * math.pi)* gamma(v/2)))

// rounder(number)=>
//     if number >= 1000000000
//         str.tostring(math.round(number / 1000000000, 2)) + " B"
//     else if number >= 1000000
//         str.tostring(math.round(number / 1000000, 2)) + " M"
//     else if number >= 1000
//         str.tostring(math.round(number / 1000, 2)) + " K"
//     else 
//         str.tostring(math.round(number, 2))

// vpStdevLen = vpScoreLen
// vpMean = ta.sma(close, vpScoreLen)

// demo = (1 - 0.99) / 2

// float vpLower = -100
// float vpUpper = 100
// float vpMid = (vpLower + vpUpper) / 2
// while math.abs(t_dist_cdf(vpMid, vpStdevLen - 1) - demo) > 0.000001
//     if t_dist_cdf(vpMid, vpStdevLen - 1) > demo 
//         vpUpper := vpMid
//     else
//         vpLower := vpMid
//     vpMid := (vpLower + vpUpper) / 2
// float t_value = vpMid

// if t_value < 0
//     t_value := -t_value

// squared_diff = math.pow(open - vpMean, 2)
// summed_squares = math.sum(squared_diff, vpStdevLen)

// mean_squared_error = summed_squares / (vpStdevLen - 1)
// rmse = math.sqrt(mean_squared_error)
// vpRootStandardError = math.sqrt(1 + 1 / vpStdevLen + squared_diff / summed_squares)
// vpOffset = t_value * rmse * vpRootStandardError

// sq(source) => math.pow(source, 2)

// sinc(source, bandwidth) =>
//     if source == 0
//         1
//     else
//         math.sin(math.pi * source / bandwidth) / (math.pi * source / bandwidth)  

// window_function(size, n) =>
//     0.54 - 0.46 * math.cos(2 * math.pi * n / (size - 1))

// multi_kernel_regression(source, vpSmoothing)=>
//     src_size = array.size(source)
//     estimate_array = array.new<float>(src_size) 
//     float current_price = na
//     for i = 0 to src_size - 1 
//         float sum = 0
//         float sumw = 0
//         for j = 0 to src_size - 1 
//             diff = i - j
//             weight = sinc(diff, vpSmoothing)
//             sum += array.get(source, j) * weight
//             sumw += weight
//         current_price := sum / sumw
//         array.set(estimate_array, i, current_price >= 0 ? current_price : 0)
//     estimate_array

// cnum = 100
// vpTop = ta.highest(vpLen)
// vpBot = ta.lowest(vpLen)
// vpDist = (vpTop - vpBot) / 500
// vpStep = (vpTop - vpBot) / cnum
// RANGE = vpStep * vpPivot

// levels = array.new_float(cnum + 1)
// for x = 0 to cnum by 1
//     array.set(levels, x, vpBot + vpStep * x)

// get_vol(a, b, x, y, vol) =>
//     // Bar is completely below or above the range
//     if y < a or x > b
//         0
//     // Entire bar is inside the range but doesn't span it
//     else if x >= a and y <= b
//         p_range = (y - x) / (b - a)
//         p_range * vol
//     // Bar completely covers the range
//     else if x <= a and y >= b
//         p_bar = (b - a) / (y - x)
//         p_bar * vol
//     // vpTop of the bar is inside the range
//     else if x < a and y <= b
//         p_bar = (y - a) / (y - x)
//         p_bar * vol
//     // Bottom of the bar is inside the range
//     else if x >= a and y > b
//         p_bar = (b - x) / (y - x)
//         p_bar * vol
//     else
//         vol

// var lines = array.new<line>()
// var probs = array.new<box>()
// var volus = array.new<box>()
// var float line_float = na
// if array.size(lines) > 0
//     for i = array.size(lines) - 1 to 0
//         line.delete(array.get(lines, i))
//         array.remove(lines, i)
//     for i = array.size(probs) - 1 to 0
//         box.delete(array.get(probs, i))
//         array.remove(probs, i)
//     for i = array.size(volus) - 1 to 0
//         box.delete(array.get(volus, i))
//         array.remove(volus, i)
 
// if barstate.islast

//     _volumes = array.new_float(cnum, 0.)
//     bullish_volumes = array.new_float(cnum, 0.)
//     for bars = 0 to vpLen - 1 by 1
//         High = high[bars]
//         Low = low[bars]
//         Volume = volume[bars]
//         state = open[bars] < close[bars]
//         for x = 0 to cnum - 1 by 1
//             array.set(_volumes, x, array.get(_volumes, x) + get_vol(array.get(levels, x), array.get(levels, x + 1), Low, High, Volume))
//             if state
//                 array.set(bullish_volumes, x, array.get(bullish_volumes, x) + get_vol(array.get(levels, x), array.get(levels, x + 1), Low, High, Volume))

//     smooth_volume = multi_kernel_regression(_volumes, vpSmoothing) 
//     int poc = array.indexof(smooth_volume, array.max(smooth_volume))
//     pocs = array.new<float>()
//     vpoc = array.new<float>()
//     var hl = array.new_float(vpPivot, na)
//     var hr = array.new_float(vpPivot, na)
//     for i = 0 to array.size(smooth_volume) - 1
//         max = array.max(smooth_volume, i) 
//         var previous = 0.
//         idx = array.indexof(smooth_volume, max)
//         if max > array.percentile_nearest_rank(smooth_volume, vpPeakThresh)
//             for j = 0 to array.size(hl) - 1
//                 array.set(hl, j, array.get(smooth_volume, math.max(0, idx - 1 - j)))
//                 array.set(hr, j, array.get(smooth_volume, math.min(array.size(smooth_volume) - 1, idx + 1 + j)))

//             is_peak = true
//             for j = 0 to array.size(hl) - 1
//                 if (max < array.get(hr, j) or max < array.get(hl, j)) and (array.get(hr, math.min(array.size(hl) - 1, j + 1)) <= array.get(hl, j) or array.get(hl, math.min(array.size(hl) - 1, j + 1)) <= array.get(hl, j))
//                     is_peak := false
//                     break

//             // if is_peak
//             //     poc_i = idx
//             //     POC = math.avg(array.get(levels, poc_i), array.get(levels, poc_i < array.size(levels) ? poc_i + 1 : poc_i - 1))
//             //     if i == 0
//             //         array.push(pocs, POC)
//             //         array.push(vpoc, max)
//             //     else
//             //         for j = 0 to array.size(pocs)
//             //             if j < array.size(pocs)
//             //                 if not (POC > array.get(pocs, j) ? POC - RANGE > RANGE + array.get(pocs, j) : POC + RANGE < array.get(pocs, j) - RANGE)
//             //                     break
//             //             if j == array.size(pocs)
//             //                 array.push(pocs, POC)
//             //                 array.push(vpoc, max)
                            

//     color_array = array.new_float(cnum, 0.)
//     for i = 0 to cnum - 1
//         max_level = array.get(_volumes, i)
//         bullish_level = array.get(bullish_volumes, i)
//         array.set(color_array, i, bullish_level/max_level)

//     maxvol = array.max(_volumes)
//     for x = 0 to cnum - 1 by 1
//         array.set(_volumes, x, array.get(_volumes, x) * vpLen / (3 * maxvol))
//     normal_volumes = multi_kernel_regression(_volumes, vpSmoothing)
//     edge = bar_index - vpLen + 1

//     var vol_bars = array.new_box(cnum, na)
//     for i = 0 to cnum - 1 by 1
//         box.delete(array.get(vol_bars, i))
//         array.set(
//          vol_bars, i, 
//          box.new(edge, 
//           array.get(levels, i + 1) - vpDist, 
//           edge + math.round(array.get(normal_volumes, i)), 
//           array.get(levels, i) + vpDist, 
//           border_width = 0, 
//           bgcolor = color.new(color.from_gradient(array.get(color_array, i), 0, 1, vpLowColor, vpHighColor), vpTrans))
//          )
 

    // size_index = array.size(pocs) - 1
    // for i = 0 to size_index
    //     POC = array.get(pocs, i)
    //     pocv = array.get(vpoc, i)
    //     colour = color.new(color.rgb((23 * (i + 4)) % 255, (79 * (i + 4)) % 255, (127 * (i + 4)) % 255), 60)

    //     line_a = line.new(edge, POC + RANGE, bar_index + 1, POC + RANGE, color = colour, extend = extend.right)
    //     line_b = line.new(edge, POC - RANGE, bar_index + 1, POC - RANGE, color = colour, extend = extend.right)
    //     array.unshift(lines, line_a)
    //     array.unshift(lines, line_b)
    //     if i == 0 
    //         point_of_control = line.new(edge, POC, bar_index + 1, POC, color = vpEnableLevels != "None" ? vpPOCColor : vpAlpha, extend = extend.right)
    //         array.unshift(lines, point_of_control)
    //     if i != 0 
    //         point_of_control = line.new(edge, POC, bar_index + 1, POC, color = vpEnableLevels == "All" ? vpLevelColor : vpAlpha, extend = extend.right)
    //         array.unshift(lines, point_of_control)
    //     linefill.new(line_a, line_b, colour)
    //     zscore = (POC - vpMean)/(vpOffset * 1.5)
    //     probability = math.round(t_dist_pdf(zscore, vpStdevLen - 1), 2)
    //     array.unshift(probs, box.new(bar_index + 32, POC + RANGE, bar_index + 48, POC - RANGE, border_color = color.new(color.black, 30), bgcolor = color.new(color.black, 30), text = "vpMean Score" + "\n" + str.tostring(probability * 100 / 40 * 100), text_color = color.white))
    //     array.unshift(volus, box.new(bar_index + 16, POC + RANGE, bar_index + 32, POC - RANGE, border_color = color.new(color.black, 30), bgcolor = color.new(color.black, 30), text = "Volume" + "\n" + rounder(pocv), text_color = color.white))







//-----------------------------------------------------------------------------{
// Smart Money Concepts
//-----------------------------------------------------------------------------{


// Tooltips
string MODE_TOOLTIP          = 'Allows to display historical Structure or only the recent ones'
string STYLE_TOOLTIP         = 'Indicator color theme'
string COLOR_CANDLES_TOOLTIP = 'Display additional candles with a color reflecting the current trend detected by structure'
string SHOW_INTERNAL         = 'Display internal market structure'
string CONFLUENCE_FILTER     = 'Filter non significant internal structure breakouts'
string SHOW_SWING            = 'Display swing market Structure'
string SHOW_SWING_POINTS     = 'Display swing point as labels on the chart'
string SHOW_SWHL_POINTS      = 'Highlight most recent strong and weak high/low points on the chart'
string INTERNAL_OB           = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
string SWING_OB              = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
string FILTER_OB             = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
string SHOW_EQHL             = 'Display equal highs and equal lows on the chart'
string EQHL_BARS             = 'Number of bars used to confirm equal highs and equal lows'
string EQHL_THRESHOLD        = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
string SHOW_FVG              = 'Display fair values gaps on the chart'
string AUTO_FVG              = 'Filter out non significant fair value gaps'
string FVG_TF                = 'Fair value gaps timeframe'
string EXTEND_FVG            = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
string PED_ZONES             = 'Display premium, discount, and equilibrium zones on chart'

//-----------------------------------------------------------------------------{
// Settings
//-----------------------------------------------------------------------------{
// General
//----------------------------------------{
mode = input.string('Historical'
  , options = ['Historical', 'Present']
  , group = 'Smart Money Concepts'
  , tooltip = MODE_TOOLTIP)

style = input.string('Colored'
  , options = ['Colored', 'Monochrome']
  , group = 'Smart Money Concepts'
  , tooltip = STYLE_TOOLTIP)

show_trend = input(false, 'Color Candles'
  , group = 'Smart Money Concepts'
  , tooltip = COLOR_CANDLES_TOOLTIP)

//----------------------------------------}
// Internal Structure
//----------------------------------------{
show_internals = input(true, 'Show Internal Structure'
  , group = 'Real Time Internal Structure'
  , tooltip = SHOW_INTERNAL)

show_ibull = input.string('All', 'Bullish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'ibull'
  , group = 'Real Time Internal Structure')

swing_ibull_css = input(AQUA_COLOR, ''
  , inline = 'ibull'
  , group = 'Real Time Internal Structure')

// Bear Structure
show_ibear = input.string('All', 'Bearish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'ibear'
  , group = 'Real Time Internal Structure')

swing_ibear_css = input(RED_COLOR, ''
  , inline = 'ibear'
  , group = 'Real Time Internal Structure')

ifilter_confluence = input(false, 'Confluence Filter'
  , group = 'Real Time Internal Structure'
  , tooltip = CONFLUENCE_FILTER)

internal_structure_size = input.string('Tiny', 'Internal Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'Real Time Internal Structure')

//----------------------------------------}
// Swing Structure
//----------------------------------------{
show_Structure = input(true, 'Show Swing Structure'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWING)

// Bull Structure
show_bull = input.string('All', 'Bullish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'bull'
  , group = 'Real Time Swing Structure')

swing_bull_css = input(AQUA_COLOR, ''
  , inline = 'bull'
  , group = 'Real Time Swing Structure')

// Bear Structure
show_bear = input.string('All', 'Bearish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'bear'
  , group = 'Real Time Swing Structure')

swing_bear_css = input(RED_COLOR, ''
  , inline = 'bear'
  , group = 'Real Time Swing Structure')

swing_structure_size = input.string('Small', 'Swing Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'Real Time Swing Structure')

// Swings
show_swings = input(false, 'Show Swings Points'
  , inline = 'swings'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWING_POINTS)

length = input.int(50, ''
  , minval = 10
  , inline = 'swings'
  , group = 'Real Time Swing Structure')

show_hl_swings = input(true, 'Show Strong/Weak High/Low'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWHL_POINTS)

//----------------------------------------}
// Order Blocks
//----------------------------------------{
show_iob = input(true, 'Internal Order Blocks'
  , inline = 'iob'
  , group = 'Order Blocks'
  , tooltip = INTERNAL_OB)

iob_showlast = input.int(5, ''
  , minval = 1
  , inline = 'iob'
  , group = 'Order Blocks')

show_ob = input(false, 'Swing Order Blocks'
  , inline = 'ob'
  , group = 'Order Blocks'
  , tooltip = SWING_OB)

ob_showlast = input.int(5, ''
  , minval = 1
  , inline = 'ob'
  , group = 'Order Blocks')

ob_filter = input.string('Atr', 'Order Block Filter'
  , options = ['Atr', 'Cumulative Mean Range']
  , group = 'Order Blocks'
  , tooltip = FILTER_OB)

ibull_ob_css = input.color(color.new(AQUA_COLOR, 85), 'Internal Bullish OB'
  , group = 'Order Blocks')

ibear_ob_css = input.color(color.new(RED_COLOR, 85), 'Internal Bearish OB'
  , group = 'Order Blocks')

bull_ob_css = input.color(color.new(AQUA_COLOR, 85), 'Bullish OB'
  , group = 'Order Blocks')

bear_ob_css = input.color(color.new(RED_COLOR, 85), 'Bearish OB'
  , group = 'Order Blocks')

//----------------------------------------}
// EQH/EQL
//----------------------------------------{
show_eq = input(false, 'Equal High/Low'
  , group = 'EQH/EQL'
  , tooltip = SHOW_EQHL)

eq_len = input.int(3, 'Bars Confirmation'
  , minval = 1
  , group = 'EQH/EQL'
  , tooltip = EQHL_BARS)

eq_threshold = input.float(0.1, 'Threshold'
  , minval = 0
  , maxval = 0.5
  , step = 0.1
  , group = 'EQH/EQL'
  , tooltip = EQHL_THRESHOLD)

eq_size = input.string('Tiny', 'Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'EQH/EQL')

//----------------------------------------}
// Fair Value Gaps
//----------------------------------------{
show_fvg = input(true, 'Fair Value Gaps'
  , group = 'Fair Value Gaps'
  , tooltip = SHOW_FVG)
  
fvg_auto = input(true, "Auto Threshold"
  , group = 'Fair Value Gaps'
  , tooltip = AUTO_FVG)

fvg_tf = input.timeframe('', "Timeframe"
  , group = 'Fair Value Gaps'
  , tooltip = FVG_TF)

bull_fvg_css = input.color(color.new(AQUA_COLOR, 70), 'Bullish FVG'
  , group = 'Fair Value Gaps')

bear_fvg_css = input.color(color.new(RED_COLOR, 70), 'Bearish FVG'
  , group = 'Fair Value Gaps')

fvg_extend = input.int(1, "Extend FVG"
  , minval = 0
  , group = 'Fair Value Gaps'
  , tooltip = EXTEND_FVG)

//----------------------------------------}
// Previous day/week high/low
//----------------------------------------{
// Daily
show_pdhl = input(false, 'Daily'
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

pdhl_style = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

pdhl_css = input(YELLOW_COLOR, ''
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

// Weekly
show_pwhl = input(false, 'Weekly'
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

pwhl_style = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

pwhl_css = input(YELLOW_COLOR, ''
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

// Monthly
show_pmhl = input(false, 'Monthly'
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

pmhl_style = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

pmhl_css = input(YELLOW_COLOR, ''
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

//----------------------------------------}
// Premium/Discount zones
//----------------------------------------{
show_sd = input(true, 'Premium/Discount Zones'
  , group = 'Premium & Discount Zones'
  , tooltip = PED_ZONES)

premium_css = input.color(ORANGE_COLOR, 'Premium Zone'
  , group = 'Premium & Discount Zones')

eq_css = input.color(color.new(WHITE_COLOR, 60), 'Equilibrium Zone'
  , group = 'Premium & Discount Zones')

discount_css = input.color(GREEN_COLOR, 'Discount Zone'
  , group = 'Premium & Discount Zones')

//-----------------------------------------------------------------------------}
// Functions
//-----------------------------------------------------------------------------{
n = bar_index

atr = ta.atr(200)
cmean_range = ta.cum(high - low) / n

// HL Output function
hl() => [high, low]

// Get ohlc values function
get_ohlc()=> [close[1], open[1], high, low, high[2], low[2]]

// Display Structure function
display_Structure(x, y, txt, css, dashed, down, lbl_size)=>
    structure_line = line.new(x, y, n, y
      , color = css
      , style = dashed ? line.style_dashed : line.style_solid)

    structure_lbl = label.new(int(math.avg(x, n)), y, txt
      , color = TRANSPARENT_COLOR
      , textcolor = css
      , style = down ? label.style_label_down : label.style_label_up
      , size = lbl_size)

    if mode == 'Present'
        line.delete(structure_line[1])
        label.delete(structure_lbl[1])

// Swings detection/measurements
swings(len)=>
    var os = 0
    
    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]

    top = os == 0 and os[1] != 0 ? high[len] : 0
    btm = os == 1 and os[1] != 1 ? low[len] : 0

    [top, btm]

// Order block coordinates function
ob_coord(use_max, loc, target_top, target_btm, target_left, target_type)=>
    min = 99999999.
    max = 0.
    idx = 1

    ob_threshold = ob_filter == 'Atr' ? atr : cmean_range 

    // Search for highest/lowest high within the structure interval and get range
    if use_max
        for i = 1 to (n - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                max := math.max(high[i], max)
                min := max == high[i] ? low[i] : min
                idx := max == high[i] ? i : idx
    else
        for i = 1 to (n - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                min := math.min(low[i], min)
                max := min == low[i] ? high[i] : max
                idx := min == low[i] ? i : idx

    array.unshift(target_top, max)
    array.unshift(target_btm, min)
    array.unshift(target_left, time[idx])
    array.unshift(target_type, use_max ? -1 : 1)

// Set order blocks
timediff = time[1] - time[2]

extract_tf(simple string prd) =>
    int len = str.length(prd)

    if str.contains(prd, "M")
        if (str.length(prd) == 1)
            1
        else
            str.tonumber(str.substring(prd, 0, len - 1))
    else if str.contains(prd, "W")
        if (str.length(prd) == 1)
            1
        else
            str.tonumber(str.substring(prd, 0, len - 1))
    else if str.contains(prd, "D")
        if (str.length(prd) == 1)
            1
        else
            str.tonumber(str.substring(prd, 0, len - 1))
    else if str.contains(prd, "S")
        if (str.length(prd) == 1)
            1
        else
            str.tonumber(str.substring(prd, 0, len - 1))
    else
        str.tonumber(prd)

getMillisInTf() => math.round(timeframe.multiplier * (timeframe.isseconds ? 1 : timeframe.isminutes ? 1. : timeframe.isdaily ? 60. * 24 : timeframe.isweekly ? 60. * 24 * 7 : timeframe.ismonthly ? 60. * 24 * 30.4375 : 0)) * 60 * 1000

demo = math.round(extract_tf(timeframe.period))

display_ob(boxes, target_top, target_btm, target_left, target_type, show_last, swing, size)=>
    for i = 0 to math.min(show_last-1, size-1)
        get_box = array.get(boxes, i)
        box.set_lefttop(get_box, array.get(target_left, i), array.get(target_top, i))
        box.set_rightbottom(get_box, timenow + timediff + getMillisInTf(), array.get(target_btm, i))

        color css = na
        
        if swing 
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
                border_css = array.get(target_type, i) == 1 ? #b2b5be : #5d606b
                box.set_border_color(get_box, border_css)
            else
                css := array.get(target_type, i) == 1 ? bull_ob_css : bear_ob_css
                box.set_border_color(get_box, css)

            box.set_bgcolor(get_box, css)
        else
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
            else
                css := array.get(target_type, i) == 1 ? ibull_ob_css : ibear_ob_css
            
            box.set_border_color(get_box, css)
            box.set_bgcolor(get_box, css)

        
// Line Style function
get_line_style(style) =>
    out = switch style
        '⎯⎯⎯'  => line.style_solid
        '----' => line.style_dashed
        '····' => line.style_dotted

// Set line/labels function for previous high/lows
phl(h, l, tf, css)=>
    var line high_line = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = get_line_style(pdhl_style))

    var label high_lbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format('P{0}H', tf)
      , color = TRANSPARENT_COLOR
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)

    var line low_line = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = get_line_style(pdhl_style))

    var label low_lbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format('P{0}L', tf)
      , color = TRANSPARENT_COLOR
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)

    hy = ta.valuewhen(h != h[1], h, 1)
    hx = ta.valuewhen(h == high, time, 1)

    ly = ta.valuewhen(l != l[1], l, 1)
    lx = ta.valuewhen(l == low, time, 1)

    if barstate.islast
        ext = time + (time - time[1])*20

        //High
        line.set_xy1(high_line, hx, hy)
        line.set_xy2(high_line, ext, hy)

        label.set_xy(high_lbl, ext, hy)

        //Low
        line.set_xy1(low_line, lx, ly)
        line.set_xy2(low_line, ext, ly)

        label.set_xy(low_lbl, ext, ly)

//-----------------------------------------------------------------------------}
// Global variables
//-----------------------------------------------------------------------------{
var trend = 0, var itrend = 0

var top_y = 0., var top_x = 0
var btm_y = 0., var btm_x = 0

var itop_y = 0., var itop_x = 0
var ibtm_y = 0., var ibtm_x = 0

var trail_up = high, var trail_dn = low
var trail_up_x = 0,  var trail_dn_x = 0

var top_cross = true,  var btm_cross = true
var itop_cross = true, var ibtm_cross = true

var txt_top = '',  var txt_btm = ''

// Alerts
bull_choch_alert = false 
bull_bos_alert   = false 

bear_choch_alert = false 
bear_bos_alert   = false 

bull_ichoch_alert = false 
bull_ibos_alert   = false 

bear_ichoch_alert = false 
bear_ibos_alert   = false 

bull_iob_break = false 
bear_iob_break = false

bull_ob_break = false 
bear_ob_break = false

eqh_alert = false 
eql_alert = false 

// Structure colors
var bull_css = style == 'Monochrome' ? #b2b5be 
  : swing_bull_css

var bear_css = style == 'Monochrome' ? #b2b5be 
  : swing_bear_css

var ibull_css = style == 'Monochrome' ? #b2b5be 
  : swing_ibull_css

var ibear_css = style == 'Monochrome' ? #b2b5be 
  : swing_ibear_css

// Labels size
var internal_structure_lbl_size = internal_structure_size == 'Tiny' 
  ? size.tiny 
  : internal_structure_size == 'Small' 
  ? size.small 
  : size.normal 

var swing_structure_lbl_size = swing_structure_size == 'Tiny' 
  ? size.tiny 
  : swing_structure_size == 'Small' 
  ? size.small 
  : size.normal 

var eqhl_lbl_size = eq_size == 'Tiny' 
  ? size.tiny 
  : eq_size == 'Small' 
  ? size.small
  : size.normal 

// Swings
[top, btm] = swings(length)

[itop, ibtm] = swings(5)

//-----------------------------------------------------------------------------}
// Pivot High
//-----------------------------------------------------------------------------{
var line extend_top = na

var label extend_top_lbl = label.new(na, na
  , color = TRANSPARENT_COLOR
  , textcolor = bear_css
  , style = label.style_label_down
  , size = size.tiny)

if top
    top_cross := true
    txt_top := top > top_y ? 'HH' : 'LH'

    if show_swings
        top_lbl = label.new(n-length, top, txt_top
          , color = TRANSPARENT_COLOR
          , textcolor = bear_css
          , style = label.style_label_down
          , size = swing_structure_lbl_size)

        if mode == 'Present'
            label.delete(top_lbl[1])

    // Extend recent top to last bar
    line.delete(extend_top[1])
    extend_top := line.new(n-length, top, n, top
      , color = bear_css)

    top_y := top
    top_x := n - length

    trail_up := top
    trail_up_x := n - length

if itop
    itop_cross := true

    itop_y := itop
    itop_x := n - 5

// Trailing maximum
trail_up := math.max(high, trail_up)
trail_up_x := trail_up == high ? n : trail_up_x

// Set top extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_top, trail_up_x, trail_up)
    line.set_xy2(extend_top, n + 20, trail_up)

    label.set_x(extend_top_lbl, n + 20)
    label.set_y(extend_top_lbl, trail_up)
    label.set_text(extend_top_lbl, trend < 0 ? 'Strong High' : 'Weak High')

//-----------------------------------------------------------------------------}
// Pivot Low
//-----------------------------------------------------------------------------{
var line extend_btm = na 

var label extend_btm_lbl = label.new(na, na
  , color = TRANSPARENT_COLOR
  , textcolor = bull_css
  , style = label.style_label_up
  , size = size.tiny)

if btm
    btm_cross := true
    txt_btm := btm < btm_y ? 'LL' : 'HL'
    
    if show_swings
        btm_lbl = label.new(n - length, btm, txt_btm
          , color = TRANSPARENT_COLOR
          , textcolor = bull_css
          , style = label.style_label_up
          , size = swing_structure_lbl_size)

        if mode == 'Present'
            label.delete(btm_lbl[1])
    
    // Extend recent btm to last bar
    line.delete(extend_btm[1])
    extend_btm := line.new(n - length, btm, n, btm
      , color = bull_css)

    btm_y := btm
    btm_x := n-length

    trail_dn := btm
    trail_dn_x := n-length

if ibtm
    ibtm_cross := true

    ibtm_y := ibtm
    ibtm_x := n - 5

// Trailing minimum
trail_dn := math.min(low, trail_dn)
trail_dn_x := trail_dn == low ? n : trail_dn_x

// Set btm extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_btm, trail_dn_x, trail_dn)
    line.set_xy2(extend_btm, n + 20, trail_dn)

    label.set_x(extend_btm_lbl, n + 20)
    label.set_y(extend_btm_lbl, trail_dn)
    label.set_text(extend_btm_lbl, trend > 0 ? 'Strong Low' : 'Weak Low')

//-----------------------------------------------------------------------------}
// Order Blocks Arrays
//-----------------------------------------------------------------------------{
var iob_top = array.new_float(0)
var iob_btm = array.new_float(0)
var iob_left = array.new_int(0)
var iob_type = array.new_int(0)

var ob_top = array.new_float(0)
var ob_btm = array.new_float(0)
var ob_left = array.new_int(0)
var ob_type = array.new_int(0)

//-----------------------------------------------------------------------------}
// Pivot High BOS/CHoCH
//-----------------------------------------------------------------------------{
// Filtering
var bull_concordant = true

if ifilter_confluence
    bull_concordant := high - math.max(close, open) > math.min(close, open - low)

// Detect internal bullish Structure
if ta.crossover(close, itop_y) and itop_cross and top_y != itop_y and bull_concordant
    bool choch = na
    
    if itrend < 0
        choch := true
        bull_ichoch_alert := true
    else 
        bull_ibos_alert := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    if show_internals
        if show_ibull == 'All' or (show_ibull == 'BOS' and not choch) or (show_ibull == 'CHoCH' and choch)
            display_Structure(itop_x, itop_y, txt, ibull_css, true, true, internal_structure_lbl_size)
    
    itop_cross := false
    itrend := 1
    
    // Internal Order Block
    if show_iob
        ob_coord(false, itop_x, iob_top, iob_btm, iob_left, iob_type)

// Detect bullish Structure
if ta.crossover(close, top_y) and top_cross
    bool choch = na
    
    if trend < 0
        choch := true
        bull_choch_alert := true
    else 
        bull_bos_alert := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    if show_Structure
        if show_bull == 'All' or (show_bull == 'BOS' and not choch) or (show_bull == 'CHoCH' and choch)
            display_Structure(top_x, top_y, txt, bull_css, false, true, swing_structure_lbl_size)
    
    // Order Block
    if show_ob
        ob_coord(false, top_x, ob_top, ob_btm, ob_left, ob_type)

    top_cross := false
    trend := 1

//-----------------------------------------------------------------------------}
// Pivot Low BOS/CHoCH
//-----------------------------------------------------------------------------{
var bear_concordant = true

if ifilter_confluence
    bear_concordant := high - math.max(close, open) < math.min(close, open - low)

// Detect internal bearish Structure
if ta.crossunder(close, ibtm_y) and ibtm_cross and btm_y != ibtm_y and bear_concordant
    bool choch = false
    
    if itrend > 0
        choch := true
        bear_ichoch_alert := true
    else 
        bear_ibos_alert := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    if show_internals
        if show_ibear == 'All' or (show_ibear == 'BOS' and not choch) or (show_ibear == 'CHoCH' and choch)
            display_Structure(ibtm_x, ibtm_y, txt, ibear_css, true, false, internal_structure_lbl_size)
    
    ibtm_cross := false
    itrend := -1
    
    // Internal Order Block
    if show_iob
        ob_coord(true, ibtm_x, iob_top, iob_btm, iob_left, iob_type)

// Detect bearish Structure
if ta.crossunder(close, btm_y) and btm_cross
    bool choch = na
    
    if trend > 0
        choch := true
        bear_choch_alert := true
    else 
        bear_bos_alert := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    if show_Structure
        if show_bear == 'All' or (show_bear == 'BOS' and not choch) or (show_bear == 'CHoCH' and choch)
            display_Structure(btm_x, btm_y, txt, bear_css, false, false, swing_structure_lbl_size)
    
    // Order Block
    if show_ob
        ob_coord(true, btm_x, ob_top, ob_btm, ob_left, ob_type)

    btm_cross := false
    trend := -1

//-----------------------------------------------------------------------------}
// Order Blocks
//-----------------------------------------------------------------------------{
// Set order blocks
var iob_boxes = array.new_box(0)
var ob_boxes = array.new_box(0)

// Delete internal order blocks box coordinates if top/bottom is broken
for element in iob_type
    index = array.indexof(iob_type, element)

    if close < array.get(iob_btm, index) and element == 1
        array.remove(iob_top, index) 
        array.remove(iob_btm, index) 
        array.remove(iob_left, index) 
        array.remove(iob_type, index)
        bull_iob_break := true

    else if close > array.get(iob_top, index) and element == -1
        array.remove(iob_top, index) 
        array.remove(iob_btm, index)
        array.remove(iob_left, index) 
        array.remove(iob_type, index)
        bear_iob_break := true

// Delete internal order blocks box coordinates if top/bottom is broken
for element in ob_type
    index = array.indexof(ob_type, element)

    if close < array.get(ob_btm, index) and element == 1
        array.remove(ob_top, index) 
        array.remove(ob_btm, index) 
        array.remove(ob_left, index) 
        array.remove(ob_type, index)
        bull_ob_break := true

    else if close > array.get(ob_top, index) and element == -1
        array.remove(ob_top, index) 
        array.remove(ob_btm, index)
        array.remove(ob_left, index) 
        array.remove(ob_type, index)
        bear_ob_break := true

iob_size = array.size(iob_type)
ob_size = array.size(ob_type)

if barstate.isfirst
    if show_iob
        for i = 0 to iob_showlast-1
            array.push(iob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))
    if show_ob
        for i = 0 to ob_showlast-1
            array.push(ob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))

if iob_size > 0
    if barstate.islast
        display_ob(iob_boxes, iob_top, iob_btm, iob_left, iob_type, iob_showlast, false, iob_size)

if ob_size > 0
    if barstate.islast
        display_ob(ob_boxes, ob_top, ob_btm, ob_left, ob_type, ob_showlast, true, ob_size)

//-----------------------------------------------------------------------------}
// EQH/EQL
//-----------------------------------------------------------------------------{
var eq_prev_top = 0.
var eq_top_x = 0

var eq_prev_btm = 0.
var eq_btm_x = 0

if show_eq
    eq_top = ta.pivothigh(eq_len, eq_len)
    eq_btm = ta.pivotlow(eq_len, eq_len)

    if eq_top 
        max = math.max(eq_top, eq_prev_top)
        min = math.min(eq_top, eq_prev_top)
        
        if max < min + atr * eq_threshold
            eqh_line = line.new(eq_top_x, eq_prev_top, n-eq_len, eq_top
              , color = bear_css
              , style = line.style_dotted)

            eqh_lbl = label.new(int(math.avg(n-eq_len, eq_top_x)), eq_top, 'EQH'
              , color = #00000000
              , textcolor = bear_css
              , style = label.style_label_down
              , size = eqhl_lbl_size)

            if mode == 'Present'
                line.delete(eqh_line[1])
                label.delete(eqh_lbl[1])
            
            eqh_alert := true

        eq_prev_top := eq_top
        eq_top_x := n-eq_len

    if eq_btm 
        max = math.max(eq_btm, eq_prev_btm)
        min = math.min(eq_btm, eq_prev_btm)
        
        if min > max - atr * eq_threshold
            eql_line = line.new(eq_btm_x, eq_prev_btm, n-eq_len, eq_btm
              , color = bull_css
              , style = line.style_dotted)

            eql_lbl = label.new(int(math.avg(n-eq_len, eq_btm_x)), eq_btm, 'EQL'
              , color = #00000000
              , textcolor = bull_css
              , style = label.style_label_up
              , size = eqhl_lbl_size)

            eql_alert := true

            if mode == 'Present'
                line.delete(eql_line[1])
                label.delete(eql_lbl[1])

        eq_prev_btm := eq_btm
        eq_btm_x := n-eq_len

//-----------------------------------------------------------------------------}
// Fair Value Gaps
//-----------------------------------------------------------------------------{
var bullish_fvg_max = array.new_box(0)
var bullish_fvg_min = array.new_box(0)

var bearish_fvg_max = array.new_box(0)
var bearish_fvg_min = array.new_box(0)

float bullish_fvg_avg = na
float bearish_fvg_avg = na

bullish_fvg_cnd = false
bearish_fvg_cnd = false

[src_c1, src_o1, src_h, src_l, src_h2, src_l2] =
  request.security(syminfo.tickerid, fvg_tf, get_ohlc())

if show_fvg
    delta_per = (src_c1 - src_o1) / src_o1 * 100

    change_tf = timeframe.change(fvg_tf)

    threshold = fvg_auto ? ta.cum(math.abs(change_tf ? delta_per : 0)) / n * 2 
      : 0

    // FVG conditions
    bullish_fvg_cnd := src_l > src_h2
      and src_c1 > src_h2 
      and delta_per > threshold
      and change_tf

    bearish_fvg_cnd := src_h < src_l2 
      and src_c1 < src_l2 
      and -delta_per > threshold
      and change_tf

    // FVG Areas
    if bullish_fvg_cnd
        array.unshift(bullish_fvg_max, box.new(n-1, src_l, n + fvg_extend, math.avg(src_l, src_h2)
          , border_color = bull_fvg_css
          , bgcolor = bull_fvg_css))
        
        array.unshift(bullish_fvg_min, box.new(n-1, math.avg(src_l, src_h2), n + fvg_extend, src_h2
          , border_color = bull_fvg_css
          , bgcolor = bull_fvg_css))
    
    if bearish_fvg_cnd
        array.unshift(bearish_fvg_max, box.new(n-1, src_h, n + fvg_extend, math.avg(src_h, src_l2)
          , border_color = bear_fvg_css
          , bgcolor = bear_fvg_css))
        
        array.unshift(bearish_fvg_min, box.new(n-1, math.avg(src_h, src_l2), n + fvg_extend, src_l2
          , border_color = bear_fvg_css
          , bgcolor = bear_fvg_css))

    for bx in bullish_fvg_min
        if low < box.get_bottom(bx)
            box.delete(bx)
            box.delete(array.get(bullish_fvg_max, array.indexof(bullish_fvg_min, bx)))
    
    for bx in bearish_fvg_max
        if high > box.get_top(bx)
            box.delete(bx)
            box.delete(array.get(bearish_fvg_min, array.indexof(bearish_fvg_max, bx)))

//-----------------------------------------------------------------------------}
// Previous day/week high/lows
//-----------------------------------------------------------------------------{
// Daily high/low
[pdh, pdl] = request.security(syminfo.tickerid, 'D', hl()
  , lookahead = barmerge.lookahead_on)

// Weekly high/low
[pwh, pwl] = request.security(syminfo.tickerid, 'W', hl()
  , lookahead = barmerge.lookahead_on)

// Monthly high/low
[pmh, pml] = request.security(syminfo.tickerid, 'M', hl()
  , lookahead = barmerge.lookahead_on)

// Display Daily
if show_pdhl
    phl(pdh, pdl, 'D', pdhl_css)

// Display Weekly
if show_pwhl
    phl(pwh, pwl, 'W', pwhl_css)
    
// Display Monthly
if show_pmhl
    phl(pmh, pml, 'M', pmhl_css)

//-----------------------------------------------------------------------------}
// Premium/Discount/Equilibrium zones
//-----------------------------------------------------------------------------{
var premium = box.new(na, na, na, na
  , bgcolor = color.new(premium_css, 80)
  , border_color = na)

var premium_lbl = label.new(na, na
  , text = 'Premium'
  , color = TRANSPARENT_COLOR
  , textcolor = premium_css
  , style = label.style_label_down
  , size = size.small)

var eq = box.new(na, na, na, na
  , bgcolor = color.new(eq_css, 95)
  , border_color = na)

var eq_lbl = label.new(na, na
  , text = 'Equilibrium'
  , color = TRANSPARENT_COLOR
  , textcolor = eq_css
  , style = label.style_label_left
  , size = size.small)

var discount = box.new(na, na, na, na
  , bgcolor = color.new(discount_css, 80)
  , border_color = na)

var discount_lbl = label.new(na, na
  , text = 'Discount'
  , color = TRANSPARENT_COLOR
  , textcolor = discount_css
  , style = label.style_label_up
  , size = size.small)

// Show Premium/Discount Areas
if barstate.islast and show_sd
    avg = math.avg(trail_up, trail_dn)

    box.set_lefttop(premium, math.max(top_x, btm_x), trail_up)
    box.set_rightbottom(premium, n, .95 * trail_up + .05 * trail_dn)

    label.set_xy(premium_lbl, int(math.avg(math.max(top_x, btm_x), n)), trail_up)

    box.set_lefttop(eq, math.max(top_x, btm_x), .525 * trail_up + .475*trail_dn)
    box.set_rightbottom(eq, n, .525 * trail_dn + .475 * trail_up)

    label.set_xy(eq_lbl, n, avg)
    
    box.set_lefttop(discount, math.max(top_x, btm_x), .95 * trail_dn + .05 * trail_up)
    box.set_rightbottom(discount, n, trail_dn)
    label.set_xy(discount_lbl, int(math.avg(math.max(top_x, btm_x), n)), trail_dn)

//-----------------------------------------------------------------------------}
// Trend
//-----------------------------------------------------------------------------{
var color trend_css = na

if show_trend
    if style == 'Colored'
        trend_css := itrend == 1 ? bull_css : bear_css
    else if style == 'Monochrome'
        trend_css := itrend == 1 ? #b2b5be : #5d606b

plotcandle(open, high, low, close
  , color = trend_css
  , wickcolor = trend_css
  , bordercolor = trend_css
  , editable = false)

//-----------------------------------------------------------------------------}
// Alerts
//-----------------------------------------------------------------------------{
// Internal Structure
alertcondition(bull_ibos_alert, 'Internal Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bull_ichoch_alert, 'Internal Bullish CHoCH', 'Internal Bullish CHoCH formed')

alertcondition(bear_ibos_alert, 'Internal Bearish BOS', 'Internal Bearish BOS formed')
alertcondition(bear_ichoch_alert, 'Internal Bearish CHoCH', 'Internal Bearish CHoCH formed')

// Swing Structure
alertcondition(bull_bos_alert, 'Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bull_choch_alert, 'Bullish CHoCH', 'Internal Bullish CHoCH formed')

alertcondition(bear_bos_alert, 'Bearish BOS', 'Bearish BOS formed')
alertcondition(bear_choch_alert, 'Bearish CHoCH', 'Bearish CHoCH formed')

// Order Blocks
alertcondition(bull_iob_break, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(bear_iob_break, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')

alertcondition(bull_ob_break, 'Bullish Swing OB Breakout', 'Price broke bullish swing OB')
alertcondition(bear_ob_break, 'Bearish Swing OB Breakout', 'Price broke bearish swing OB')

// EQH/EQL
alertcondition(eqh_alert, 'Equal Highs', 'Equal highs detected')
alertcondition(eql_alert, 'Equal Lows', 'Equal lows detected')

// FVG
alertcondition(bullish_fvg_cnd, 'Bullish FVG', 'Bullish FVG formed')
alertcondition(bearish_fvg_cnd, 'Bearish FVG', 'Bearish FVG formed')

//-----------------------------------------------------------------------------}








//-----------------------------------------------------------------------------{
// Master Pattern
//-----------------------------------------------------------------------------{

//------------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------{
string mpGrp = 'Master Pattern'
mpLen = input.int(500, 'Length', minval = 1, maxval = 500, group = mpGrp)
mpContractionLookback = input.int(3, 'Contraction Detection Lookback', minval = 1, group = mpGrp)
liqLen = input.int(20, 'Liquidity Levels', minval = 1, group = mpGrp)
mpColor = input.color(PURPLE_COLOR, 'Pattern Color', group = mpGrp)
showMinor = input(true, 'Show Minor Pattern', group = mpGrp)
mpShowLiq = input(true, 'Show Liquidity Levels', group = mpGrp)
bullLiqColor = input.color(RED_COLOR, 'Upper Liquidity Color', group = mpGrp)
bearLiqColor = input.color(AQUA_COLOR, 'Lower Liquidity Color', group = mpGrp)

//-----------------------------------------------------------------------------}
// UDT
//-----------------------------------------------------------------------------{
type mp
    box area
    line avg
    bool breakup
    bool breakdn

//-----------------------------------------------------------------------------}
// Detect contraction
//-----------------------------------------------------------------------------{
if last_bar_index - bar_index < mpLen
    var mpPhy = 0., var mpPhx = 0, var mpPht = 0.
    var mpPly = 0., var mpPlx = 0, var mpPlt = 0.

    var float mpTop = na
    var float mpBot = na

    mpBarIdx = bar_index
    mpPh = ta.pivothigh(mpContractionLookback, mpContractionLookback)
    mpPl = ta.pivotlow(mpContractionLookback, mpContractionLookback)

    if mpPh
        mpPht := math.sign(mpPh - mpPhy)
        mpPhy := mpPh

        if mpPht == -1 and mpPlt == 1
            mpTop := mpPh
            mpBot := mpPly
            mpPhx := mpBarIdx-mpContractionLookback

    if mpPl
        mpPlt := math.sign(mpPl - mpPly)
        mpPly := mpPl

        if mpPht  == -1 and mpPlt == 1
            mpTop := mpPhy
            mpBot := mpPl
            mpPlx := mpBarIdx-mpContractionLookback

    //-----------------------------------------------------------------------------}
    // Set pattern
    //-----------------------------------------------------------------------------{
    var mp master = mp.new()

    // Detect master pattern
    mpIsBull = high[mpContractionLookback] > mpTop and mpTop > mpBot
    mpIsBear = low[mpContractionLookback] < mpBot and mpTop > mpBot

    if mpIsBull or mpIsBear
        master.avg.set_x2(mpBarIdx-mpContractionLookback)
        val = math.avg(mpTop, mpBot)

        // Create new master pattern object
        master := mp.new(
          mpIsBull or mpIsBear ? box.new(math.max(mpPhx, mpPlx), mpTop, mpBarIdx-mpContractionLookback, mpBot, na, bgcolor = showMinor ? color.new(mpColor, 75) : na) : na
          , mpIsBull or mpIsBear ? line.new(mpBarIdx-mpContractionLookback, val, mpBarIdx, val, color = showMinor ? mpColor : na) : na
          , mpIsBull
          , mpIsBear)

        mpTop := na
        mpBot := na

    // Determine if pattern switch to major
    if master.breakup
        if low < master.area.get_bottom()
            master.area.set_border_color(mpColor)
            if not showMinor
                master.area.set_bgcolor(color.new(mpColor, 50))
                master.avg.set_color(mpColor)
    else if master.breakdn
        if high > master.area.get_top()
            master.area.set_border_color(mpColor)
            if not showMinor
                master.area.set_bgcolor(color.new(mpColor, 50))
                master.avg.set_color(mpColor)

    // Set friction level x2 coordinate to current bar
    if not na(master.avg)
        master.avg.set_x2(n)

    //-----------------------------------------------------------------------------}
    // Liquidity levels
    //-----------------------------------------------------------------------------{
    var line mpLiqUp = na, var liqup_reach = false
    var line mpLiqDn = na, var liqdn_reach = false

    mpLiqPh = ta.pivothigh(liqLen, liqLen)
    mpLiqPl = ta.pivotlow(liqLen, liqLen)

    // Set upper liquidity
    if mpLiqPh and mpShowLiq
        if not liqup_reach
            mpLiqUp.set_x2(mpBarIdx-liqLen)

        mpLiqUp := line.new(mpBarIdx-liqLen, mpLiqPh, mpBarIdx, mpLiqPh, color = bullLiqColor, style = line.style_dotted)
        liqup_reach := false
    else if not liqup_reach and mpShowLiq
        mpLiqUp.set_x2(mpBarIdx)

        if high > mpLiqUp.get_y1()
            liqup_reach := true

    // Set lower liquidity
    if mpLiqPl and mpShowLiq
        if not liqdn_reach
            mpLiqDn.set_x2(mpBarIdx-liqLen)

        mpLiqDn := line.new(mpBarIdx-liqLen, mpLiqPl, mpBarIdx, mpLiqPl, color = bearLiqColor, style = line.style_dotted)
        liqdn_reach := false
    else if not liqdn_reach and mpShowLiq
        mpLiqDn.set_x2(mpBarIdx)

        if low < mpLiqDn.get_y1()
            liqdn_reach := true

//-----------------------------------------------------------------------------}