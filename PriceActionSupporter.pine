// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© tamth_

// @version=5
indicator("Price Action Supporter", "Price Action Supporter", overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, max_bars_back = 500)


//-----------------------------------------------------------------------------*
//  Constants
//-----------------------------------------------------------------------------{
color TRANSPARENT_COLOR = #ffffff00
color WHITE_COLOR = #ffffff
color RED_COLOR = #e91e62
color AQUA_COLOR = #00bbf9
color LIGHT_GRAY_COLOR = #364156
color DARK_GRAY_COLOR = #212d40
color GREEN_COLOR = #008170
color PURPLE_COLOR = #764AF1
color YELLOW_COLOR = #f2e40a
color ORANGE_COLOR = #f2aa0a
color TXT_COLOR = #787b86
color BLOCK_COLOR = #5d606b19

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Common Functions
//-----------------------------------------------------------------------------{
debug(simple string txt) =>
    // Create label on the first bar
    var label = label.new(bar_index, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, WHITE_COLOR, size.large, text.align_left)
    // On next bars, update the label"s x and y position, and the text it displays
    label.set_xy(label, bar_index, ta.highest(10)[1])
    label.set_text(label, txt)

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Common Variables
//-----------------------------------------------------------------------------{
series int barIdx = bar_index
series int BAR_IDX_RIGHT_ALIGNMENT = barIdx + 21
series int BAR_TIME_RIGHT_ALIGNMENT = timenow + (time[1] - time[101]) / 100 * 20

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// General Settings
//-----------------------------------------------------------------------------{
string generalGrp = "General"

// 7 * 24 * 4
int generalLen = input.int(672, "Length", minval = 1, maxval = 672, group = generalGrp, tooltip = "Number of most recent bars to use for the calculation of supporter")

bool shouldDisplay = last_bar_index - bar_index < generalLen

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Volume Profile
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string vpGrp = "Volume Profile"
int vpLen = input.int(200, "Lookback", minval = 1, maxval = 500, tooltip = "Number of most recent bars", group = vpGrp)
int vpLevelsSize = input.int(200, "Size Of Levels", minval = 1, maxval = 400, group = vpGrp)
int vpWidth = input.int(16, "Profile's Width", minval = 1, maxval = 100, tooltip = "The length of the bars relative to the Lookback value", group = vpGrp)
int vpBarWidth = input.int(2, "Bar's Width", tooltip = "Width of each bar", group = vpGrp)
int vpOffset = input.int(16, "Offset From Last Bar", group = vpGrp)
color vpColor = input.color(DARK_GRAY_COLOR, "Color", group = vpGrp)

//-----------------------------------------------------------------------------}
// Render Volume Profile
//-----------------------------------------------------------------------------{
var vpLines = array.new_line()

if barstate.isfirst
    for i = 0 to vpLevelsSize - 1
        array.push(vpLines, line.new(na, na, na, na, width = 2))

series float vpHighest = ta.highest(vpLen)
series float vpLowest = ta.lowest(vpLen)
array<float> vpLevels = array.new_float(0)
array<int> vpVols = array.new_int(0)
array<float> vpSumv = array.new_float(0)
line vpLine = na

if barstate.islast
    for i = 0 to vpLevelsSize
        array.push(vpLevels, vpLowest + i / vpLevelsSize * (vpHighest - vpLowest))

    for i = 0 to vpLevelsSize - 1
        series float sum = 0.

        for j = 0 to vpLen - 1
            sum := high[j] > array.get(vpLevels, i) and low[j] < array.get(vpLevels, i + 1) ? sum + volume[j] : sum

        array.push(vpSumv, sum)


    for i = 0 to vpLevelsSize - 1
        series float mult = array.get(vpSumv, i) / array.max(vpSumv)
        series int vol = math.round(vpLen * vpWidth / 100 * mult)
        array.push(vpVols, vol)
    
    series int maxVol = array.max(vpVols)
    int shift = barIdx + maxVol + vpOffset

    for i = 0 to vpLevelsSize - 1
        series int vol = array.get(vpVols, i)
        series float level = array.get(vpLevels, i)
        vpLine := array.get(vpLines, i)
        line.set_xy1(vpLine, shift, level)
        line.set_xy2(vpLine, shift - vol, level)
        line.set_color(vpLine, vpColor)
        line.set_width(vpLine, vpBarWidth)

//-----------------------------------------------------------------------------}





//-----------------------------------------------------------------------------*
// Trend Lines
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string tlGrp = "Trend Lines"
bool tlShowed = input.bool(false, "Show", group = tlGrp)
color tlColor = input.color(TXT_COLOR, "Color", group = tlGrp)
int tlPivotLenL = input.int(20, "Lookback", step = 1, minval = 1, group = tlGrp)
int tlPivotLenR = tlPivotLenL
string tlSrc = input.string("Close", "Mitigation", options = ["Close", "High/Low"], group = tlGrp)
int tlMaxLines = input.int(2, "Max Broken Lines", step = 1, minval = 1, maxval = 50, group = tlGrp)

//-----------------------------------------------------------------------------}
// Get values
//-----------------------------------------------------------------------------{
series float tlClose = request.security(ticker.standard(syminfo.tickerid), timeframe.period, close)
series float tlOpen = request.security(ticker.standard(syminfo.tickerid), timeframe.period, open)
series float tlHigh = request.security(ticker.standard(syminfo.tickerid), timeframe.period, high)
series float tlLow = request.security(ticker.standard(syminfo.tickerid), timeframe.period, low)

var line[] tlPhs = array.new_line()
var line[] tlPls = array.new_line()
series float tlPh = ta.pivothigh(tlHigh, tlPivotLenL, tlPivotLenR)
series float tlPl = ta.pivotlow(tlLow, tlPivotLenL, tlPivotLenR)

var float tlPrevCloseH = na, var float tlCurCloseH = na
var float tlPrevCloseL = na, var float tlCurCloseL = na
var int tlXPrevLow = na, var float tlYPrevLow = na, var int tlXCurLow = na, var float tlYCurLow = na
var int tlXCurHigh = na, var float tlYCurHigh = na, var int tlXPrevHigh = na, var float tlYPrevHigh = na

int tlUpSize = tlMaxLines / 2
int tlDnSize = tlMaxLines % 2 == 0 ? tlMaxLines / 2 : (tlMaxLines / 2) + 1

//-----------------------------------------------------------------------------}
// Functions
//-----------------------------------------------------------------------------{
getNewTrendLine(string ptype, series int x1, series float y1, series int x2, series float y2)=>
    series line newTrendLine = line.new(x1, y1, x2, y2, extend = extend.none, color = tlColor, width = 1, style = line.style_solid, xloc = xloc.bar_index)

    if ptype == "ph"
        tlPhs.unshift(newTrendLine)
    else
        tlPls.unshift(newTrendLine)

slopeLine(series line line)=>
    float slopePh = (line.get_y2(line) - line.get_y1(line)) / (line.get_x2(line) - line.get_x1(line))
    float extendedPh = line.get_y2(line) - slopePh * (line.get_x2(line) - bar_index)
    extendedPh

if not na(tlPl)
    tlXPrevLow := tlXCurLow, tlYPrevLow := tlYCurLow, tlPrevCloseL := tlCurCloseL
    tlXCurLow := bar_index[tlPivotLenR], tlYCurLow := tlLow[tlPivotLenR], tlCurCloseL:= tlClose[tlPivotLenR]

    if tlYPrevLow < tlYCurLow and tlShowed and tlYCurLow > tlPrevCloseL 
        getNewTrendLine("pl", tlXPrevLow, tlYPrevLow, tlXCurLow, tlYCurLow)

if not na(tlPh)
    tlXPrevHigh := tlXCurHigh, tlYPrevHigh := tlYCurHigh, tlPrevCloseH := tlCurCloseH
    tlXCurHigh := bar_index[tlPivotLenR], tlYCurHigh := tlHigh[tlPivotLenR], tlCurCloseH:= tlClose[tlPivotLenR]
    
    if tlYPrevHigh > tlYCurHigh and tlShowed and tlPrevCloseH > tlYCurHigh
        getNewTrendLine("ph", tlXPrevHigh, tlYPrevHigh, tlXCurHigh, tlYCurHigh)

if close > tlYPrevHigh
    tlYPrevHigh := 0.000000

if close < tlYPrevLow
    tlYPrevLow := 9999999999.9999

//-----------------------------------------------------------------------------}
// Plots
//-----------------------------------------------------------------------------{
for x in tlPls
    var line [] downTrendLines = array.new_line(tlUpSize)
    var label [] downTrendLabels = array.new_label(tlUpSize)
    series float src = tlSrc == "Close" ? tlClose : tlLow
    x.set_xy2(bar_index, slopeLine(x))

    if x.get_x2() - x.get_x1() > 300
        x.delete()

    if src < line.get_y2(x)
        series line tlLine = line.new(line.get_x1(x), line.get_y1(x), line.get_x2(x), line.get_y2(x), color = tlColor, style = line.style_dashed, width = 1, xloc = xloc.bar_index, extend = extend.none)
        downTrendLines.unshift(tlLine)
        line.delete(x)

    if downTrendLines.size() > tlUpSize
        line.delete(downTrendLines.pop())

for x in tlPhs
    var line [] upTrendLines = array.new_line(tlDnSize)
    var label [] upTrendLabels = array.new_label(tlDnSize)
    series float src = tlSrc == "Close" ? tlClose : tlHigh
    x.set_xy2(bar_index, slopeLine(x))

    if x.get_x2() - x.get_x1() > 300
        x.delete()

    if src > line.get_y2(x)
        series line tlLine = line.new(line.get_x1(x), line.get_y1(x), line.get_x2(x), line.get_y2(x), color = tlColor, style = line.style_dashed, width = 1, xloc = xloc.bar_index, extend = extend.none)
        upTrendLines.unshift(tlLine)
        line.delete(x)

    if upTrendLines.size() > tlDnSize
        line.delete(upTrendLines.pop())

//-----------------------------------------------------------------------------}





//-----------------------------------------------------------------------------*
// Smart Money Concepts
//-----------------------------------------------------------------------------*
// Tooltips
//-----------------------------------------------------------------------------{
string MODE_TOOLTIP          = "Allows to display historical Structure or only the recent ones"
string STYLE_TOOLTIP         = "Indicator color theme"
string COLOR_CANDLES_TOOLTIP = "Display additional candles with a color reflecting the current trend detected by structure"
string SHOW_INTERNAL         = "Display internal market structure"
string CONFLUENCE_FILTER     = "Filter non significant internal structure breakouts"
string SHOW_SWING            = "Display swing market Structure"
string SHOW_SWING_POINTS     = "Display swing point as labels on the chart"
string SHOW_SWHL_POINTS      = "Highlight most recent strong and weak high/low points on the chart"
string SHOW_EQHL             = "Display equal highs and equal lows on the chart"
string EQHL_BARS             = "Number of bars used to confirm equal highs and equal lows"
string EQHL_THRESHOLD        = "Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results"
string SHOW_FVG              = "Display fair values gaps on the chart"
string AUTO_FVG              = "Filter out non significant fair value gaps"
string FVG_TF                = "Fair value gaps timeframe"
string EXTEND_FVG            = "Determine how many bars to extend the Fair Value Gap boxes on chart"
string PED_ZONES             = "Display premium, discount, and equilibrium zones on chart"

//-----------------------------------------------------------------------------}
// Settings
//-----------------------------------------------------------------------------{
// General
//----------------------------------------{
string mode = input.string("Historical"
  , options = ["Historical", "Present"]
  , group = "Smart Money Concepts"
  , tooltip = MODE_TOOLTIP)

string style = input.string("Colored"
  , options = ["Colored", "Monochrome"]
  , group = "Smart Money Concepts"
  , tooltip = STYLE_TOOLTIP)

bool trendShowed = input.bool(false, "Color Candles"
  , group = "Smart Money Concepts"
  , tooltip = COLOR_CANDLES_TOOLTIP)

//----------------------------------------}
// Internal Structure
//----------------------------------------{
bool iStructureShowed = input.bool(true, "Show Internal Structure"
  , group = "Real Time Internal Structure"
  , tooltip = SHOW_INTERNAL)

string iBullShowed = input.string("All", "Bullish Structure"
  , options = ["All", "BOS", "CHoCH"]
  , inline = "ibull"
  , group = "Real Time Internal Structure")

color iBullColor = input.color(AQUA_COLOR, ""
  , inline = "ibull"
  , group = "Real Time Internal Structure")

string iBearShowed = input.string("All", "Bearish Structure"
  , options = ["All", "BOS", "CHoCH"]
  , inline = "ibear"
  , group = "Real Time Internal Structure")

color iBearColor = input.color(RED_COLOR, ""
  , inline = "ibear"
  , group = "Real Time Internal Structure")

bool iConfluenceFiltered = input.bool(false, "Confluence Filter"
  , group = "Real Time Internal Structure"
  , tooltip = CONFLUENCE_FILTER)

string iStructureSize = input.string("Tiny", "Internal Label Size"
  , options = ["Tiny", "Small", "Normal"]
  , group = "Real Time Internal Structure")

//----------------------------------------}
// Swing Structure
//----------------------------------------{
bool sStructureShowed = input.bool(true, "Show Swing Structure"
  , group = "Real Time Swing Structure"
  , tooltip = SHOW_SWING)

string sBullShowed = input.string("All", "Bullish Structure"
  , options = ["All", "BOS", "CHoCH"]
  , inline = "bull"
  , group = "Real Time Swing Structure")

color sBullColor = input.color(AQUA_COLOR, ""
  , inline = "bull"
  , group = "Real Time Swing Structure")

string sBearShowed = input.string("All", "Bearish Structure"
  , options = ["All", "BOS", "CHoCH"]
  , inline = "bear"
  , group = "Real Time Swing Structure")

color sBearColor = input.color(RED_COLOR, ""
  , inline = "bear"
  , group = "Real Time Swing Structure")

string sStructureSize = input.string("Small", "Swing Label Size"
  , options = ["Tiny", "Small", "Normal"]
  , group = "Real Time Swing Structure")

bool swingsPointsShowed = input.bool(false, "Show Swings Points"
  , inline = "swings"
  , group = "Real Time Swing Structure"
  , tooltip = SHOW_SWING_POINTS)

int swingLen = input.int(50, ""
  , minval = 10
  , inline = "swings"
  , group = "Real Time Swing Structure")

bool hlSwingsShowed = input.bool(true, "Show Strong/Weak High/Low"
  , group = "Real Time Swing Structure"
  , tooltip = SHOW_SWHL_POINTS)

//----------------------------------------}
// Order Blocks
//----------------------------------------{
string obGrp = "Order Blocks"
bool obShowed = input.bool(true, "Order Blocks", inline = "ob1", group = obGrp)
color obBullishColor = input.color(BLOCK_COLOR, "", inline = "ob1", group = obGrp)
color obBearishColor = input.color(BLOCK_COLOR, "", inline = "ob1", group = obGrp)
var obTf = input.timeframe("", "Timeframe", inline = "ob2", group = obGrp)
string obMitigationFilt = input.string("Wicks", "Mitigation Method", options = ["Touch", "Wicks", "Close", "Average"], inline = "ob3", group = obGrp)
int obsMax = input.int(4, "Max OBs", minval = 3, inline = "ob4", group = obGrp)
bool obMtfShowed = input.bool(false, "MTF Order Blocks", inline = "m_ob1", group = obGrp)
color obBullishMtfColor = input.color(BLOCK_COLOR, "", inline = "m_ob1", group = obGrp)
color obBearishMtfColor = input.color(BLOCK_COLOR, "", inline = "m_ob1", group = obGrp)
var obMtfTf = input.timeframe("240", "Timeframe", inline = "mob2", group = obGrp)
string obMitigationMtfFilt = input.string("Wicks", "Mitigation Method", options = ["Touch", "Wicks", "Close", "Average"], inline = "mob3", group = obGrp)
int obsMaxMtf = input.int(4, "Max OBs", minval = 3, inline = "mob4", group = obGrp)

//----------------------------------------}
// Liquidity Levels
//----------------------------------------{
string llGrp = "Liquidity Levels"
bool llShowed = input.bool(true, title = "Showed", group = llGrp, inline = "1")
var llTf = input.timeframe("", title = "Timeframe", group = llGrp, inline = "2")
int llPivotLen = input.int(8, title = "Pivot Length", group = llGrp, inline = "3")
int llMaxLevels = input.int(6, title = "Max Levels", group = llGrp, inline = "4")
color llSellSideColor = input.color(#00bbf94d, "", group = llGrp, inline = "1")
color llBuySideColor = input.color(#e91e624d, "", group = llGrp, inline = "1")
float llBoxWidth = 2.5
series float llAtrLiq = ta.atr(300)
float llTholdLiq = llAtrLiq * llBoxWidth / 10

//----------------------------------------}
// EQH/EQL
//----------------------------------------{
bool eqShowed = input.bool(false, "Equal High/Low"
  , group = "EQH/EQL"
  , tooltip = SHOW_EQHL)

int eqLen = input.int(3, "Bars Confirmation"
  , minval = 1
  , group = "EQH/EQL"
  , tooltip = EQHL_BARS)

float eqThreshold = input.float(0.1, "Threshold"
  , minval = 0
  , maxval = 0.5
  , step = 0.1
  , group = "EQH/EQL"
  , tooltip = EQHL_THRESHOLD)

string eqSize = input.string("Tiny", "Label Size"
  , options = ["Tiny", "Small", "Normal"]
  , group = "EQH/EQL")

//----------------------------------------}
// Fair Value Gaps
//----------------------------------------{
bool fvgShowed = input.bool(true, "Fair Value Gaps"
  , group = "Fair Value Gaps"
  , tooltip = SHOW_FVG)
  
bool fvgAuto = input.bool(true, "Auto Threshold"
  , group = "Fair Value Gaps"
  , tooltip = AUTO_FVG)

var fvgTf = input.timeframe("", "Timeframe"
  , group = "Fair Value Gaps"
  , tooltip = FVG_TF)

color fvgBullColor = input.color(color.new(AQUA_COLOR, 70), "Bullish FVG"
  , group = "Fair Value Gaps")

color fvgBearColor = input.color(color.new(RED_COLOR, 70), "Bearish FVG"
  , group = "Fair Value Gaps")

int fvgExtend = input.int(1, "Extend FVG"
  , minval = 0
  , group = "Fair Value Gaps"
  , tooltip = EXTEND_FVG)

//----------------------------------------}
// Previous day/week high/low
//----------------------------------------{
// Daily
bool pdhlShowed = input.bool(false, "Daily"
  , inline = "daily"
  , group = "Highs & Lows MTF")

string pdhlStyle = input.string("â¯â¯â¯", ""
  , options = ["â¯â¯â¯", "----", "Â·Â·Â·Â·"]
  , inline = "daily"
  , group = "Highs & Lows MTF")

color pdhlColor = input.color(TXT_COLOR, ""
  , inline = "daily"
  , group = "Highs & Lows MTF")

// Weekly
bool pwhlShowed = input.bool(false, "Weekly"
  , inline = "weekly"
  , group = "Highs & Lows MTF")

string pwhlStyle = input.string("â¯â¯â¯", ""
  , options = ["â¯â¯â¯", "----", "Â·Â·Â·Â·"]
  , inline = "weekly"
  , group = "Highs & Lows MTF")

color pwhlColor = input.color(TXT_COLOR, ""
  , inline = "weekly"
  , group = "Highs & Lows MTF")

// Monthly
bool pmhlShowed = input.bool(false, "Monthly"
  , inline = "monthly"
  , group = "Highs & Lows MTF")

string pmhlStyle = input.string("â¯â¯â¯", ""
  , options = ["â¯â¯â¯", "----", "Â·Â·Â·Â·"]
  , inline = "monthly"
  , group = "Highs & Lows MTF")

color pmhlColor = input.color(TXT_COLOR, ""
  , inline = "monthly"
  , group = "Highs & Lows MTF")

//----------------------------------------}
// Premium/Discount zones
//----------------------------------------{
bool pdzShowed = input.bool(false, "Premium/Discount Zones"
  , group = "Premium & Discount Zones"
  , tooltip = PED_ZONES)

color pdzBgColor = input.color(BLOCK_COLOR, "Background Color", group = "Premium & Discount Zones")

color pdzTextColor = input.color(TXT_COLOR, "Text Color", group = "Premium & Discount Zones")

//-----------------------------------------------------------------------------}
// Functions
//-----------------------------------------------------------------------------{
series float atr = ta.atr(200)
series float cmean_range = ta.cum(high - low) / barIdx

// HL Output
getHL() => [high, low]

// Get ohlc values
getOHLC()=> [close[1], open[1], high, low, high[2], low[2]]

// Display structure
displayStructure(series int x, series float y, string txt, color color, bool dashed, bool down, string lblSize)=>
    line structureLine = line.new(x, y, barIdx, y, color = color, style = dashed ? line.style_dashed : line.style_solid)
    label structureLbl = label.new(int(math.avg(x, barIdx)), y, txt, color = TRANSPARENT_COLOR, textcolor = color, style = down ? label.style_label_down : label.style_label_up, size = lblSize)

    if mode == "Present"
        line.delete(structureLine[1])
        label.delete(structureLbl[1])

// Swings detection/measurements
getSwings(int len)=>
    var os = 0
    series float upper = ta.highest(len)
    series float lower = ta.lowest(len)
    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]
    float top = os == 0 and os[1] != 0 ? high[len] : 0
    float btm = os == 1 and os[1] != 1 ? low[len] : 0

    [top, btm]
        
// Line Style function
getLineStyle(string style) =>
    string out = switch style
        "â¯â¯â¯"  => line.style_solid
        "----" => line.style_dashed
        "Â·Â·Â·Â·" => line.style_dotted

// Set line/labels function for previous high/lows
getPHL(series float h, series float l, string tf, color css)=>
    var line highLine = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = getLineStyle(pdhlStyle))
    var label highLbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format("P{0}H", tf)
      , color = TRANSPARENT_COLOR
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)
    var line lowLine = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = getLineStyle(pdhlStyle))
    var label lowLbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format("P{0}L", tf)
      , color = TRANSPARENT_COLOR
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)

    series float hy = ta.valuewhen(h != h[1], h, 1)
    series int hx = ta.valuewhen(h == high, time, 1)
    series float ly = ta.valuewhen(l != l[1], l, 1)
    series int lx = ta.valuewhen(l == low, time, 1)

    if barstate.islast
        // High
        line.set_xy1(highLine, hx, hy)
        line.set_xy2(highLine, BAR_TIME_RIGHT_ALIGNMENT, hy)
        label.set_xy(highLbl, BAR_TIME_RIGHT_ALIGNMENT, hy)
        // Low
        line.set_xy1(lowLine, lx, ly)
        line.set_xy2(lowLine, BAR_TIME_RIGHT_ALIGNMENT, ly)
        label.set_xy(lowLbl, BAR_TIME_RIGHT_ALIGNMENT, ly)

//-----------------------------------------------------------------------------}
// Global variables
//-----------------------------------------------------------------------------{
var trend = 0, var itrend = 0
var topY = 0., var topX = 0
var btmY = 0., var btmX = 0
var iTopY = 0., var iTopX = 0
var iBtmY = 0., var iBtmX = 0
var trailUp = high, var trailDn = low
var trailUpX = 0,  var trailDnX = 0
var topCross = true,  var btmCross = true
var iTopCross = true, var iBtmCross = true
var txtTop = "",  var txtBtm = ""

// Structure colors
var bull_css = style == "Monochrome" ? #b2b5be 
  : sBullColor
var bear_css = style == "Monochrome" ? #b2b5be 
  : sBearColor
var ibull_css = style == "Monochrome" ? #b2b5be 
  : iBullColor
var ibear_css = style == "Monochrome" ? #b2b5be 
  : iBearColor

// Labels size
var internal_structureLblSize = iStructureSize == "Tiny" 
  ? size.tiny 
  : iStructureSize == "Small" 
  ? size.small 
  : size.normal 
var swing_structureLblSize = sStructureSize == "Tiny" 
  ? size.tiny 
  : sStructureSize == "Small" 
  ? size.small 
  : size.normal 
var eqhl_lblSize = eqSize == "Tiny" 
  ? size.tiny 
  : eqSize == "Small" 
  ? size.small
  : size.normal 

// Swings
[top, btm] = getSwings(swingLen)
[itop, ibtm] = getSwings(5)

//-----------------------------------------------------------------------------}
// Pivot High
//-----------------------------------------------------------------------------{
var line extendTop = na
var label extendTopLbl = label.new(na, na
  , color = TRANSPARENT_COLOR
  , textcolor = bear_css
  , style = label.style_label_down
  , size = size.tiny)

if top
    topCross := true
    txtTop := top > topY ? "HH" : "LH"

    if swingsPointsShowed
        top_lbl = label.new(barIdx - swingLen, top, txtTop
          , color = TRANSPARENT_COLOR
          , textcolor = bear_css
          , style = label.style_label_down
          , size = swing_structureLblSize)

        if mode == "Present"
            label.delete(top_lbl[1])

    // Extend recent top to last bar
    line.delete(extendTop[1])
    extendTop := line.new(barIdx - swingLen, top, barIdx, top, color = bear_css)
    topY := top
    topX := barIdx - swingLen
    trailUp := top
    trailUpX := barIdx - swingLen

if itop
    iTopCross := true
    iTopY := itop
    iTopX := barIdx - 5

// Trailing maximum
trailUp := math.max(high, trailUp)
trailUpX := trailUp == high ? barIdx : trailUpX

// Set top extension label/line
if barstate.islast and hlSwingsShowed
    line.set_xy1(extendTop, trailUpX, trailUp)
    line.set_xy2(extendTop, BAR_IDX_RIGHT_ALIGNMENT, trailUp)
    label.set_x(extendTopLbl, BAR_IDX_RIGHT_ALIGNMENT)
    label.set_y(extendTopLbl, trailUp)
    label.set_text(extendTopLbl, trend < 0 ? "Strong High" : "Weak High")

//-----------------------------------------------------------------------------}
// Pivot Low
//-----------------------------------------------------------------------------{
var line extend_btm = na 

var label extend_btm_lbl = label.new(na, na
  , color = TRANSPARENT_COLOR
  , textcolor = bull_css
  , style = label.style_label_up
  , size = size.tiny)

if btm
    btmCross := true
    txtBtm := btm < btmY ? "LL" : "HL"
    
    if swingsPointsShowed
        btm_lbl = label.new(barIdx - swingLen, btm, txtBtm
          , color = TRANSPARENT_COLOR
          , textcolor = bull_css
          , style = label.style_label_up
          , size = swing_structureLblSize)

        if mode == "Present"
            label.delete(btm_lbl[1])
    
    // Extend recent btm to last bar
    line.delete(extend_btm[1])
    extend_btm := line.new(barIdx - swingLen, btm, barIdx, btm, color = bull_css)
    btmY := btm
    btmX := barIdx - swingLen
    trailDn := btm
    trailDnX := barIdx - swingLen

if ibtm
    iBtmCross := true
    iBtmY := ibtm
    iBtmX := barIdx - 5

// Trailing minimum
trailDn := math.min(low, trailDn)
trailDnX := trailDn == low ? barIdx : trailDnX

// Set btm extension label/line
if barstate.islast and hlSwingsShowed
    line.set_xy1(extend_btm, trailDnX, trailDn)
    line.set_xy2(extend_btm, BAR_IDX_RIGHT_ALIGNMENT, trailDn)
    label.set_x(extend_btm_lbl, BAR_IDX_RIGHT_ALIGNMENT)
    label.set_y(extend_btm_lbl, trailDn)
    label.set_text(extend_btm_lbl, trend > 0 ? "Strong Low" : "Weak Low")

//-----------------------------------------------------------------------------}
// Pivot High BOS/CHoCH
//-----------------------------------------------------------------------------{
// Filtering
var bullConcordant = true

if iConfluenceFiltered
    bullConcordant := high - math.max(close, open) > math.min(close, open - low)

// Detect internal bullish Structure
if ta.crossover(close, iTopY) and iTopCross and topY != iTopY and bullConcordant
    bool choch = na
    
    if itrend < 0
        choch := true
    
    txt = choch ? "CHoCH" : "BOS"

    if iStructureShowed
        if (iBullShowed == "All" or (iBullShowed == "BOS" and not choch) or (iBullShowed == "CHoCH" and choch)) and shouldDisplay
            displayStructure(iTopX, iTopY, txt, ibull_css, true, true, internal_structureLblSize)
    
    iTopCross := false
    itrend := 1

// Detect bullish Structure
if ta.crossover(close, topY) and topCross
    bool choch = na
    
    if trend < 0
        choch := true

    txt = choch ? "CHoCH" : "BOS"
    
    if sStructureShowed
        if (sBullShowed == "All" or (sBullShowed == "BOS" and not choch) or (sBullShowed == "CHoCH" and choch)) and shouldDisplay
            displayStructure(topX, topY, txt, bull_css, false, true, swing_structureLblSize)

    topCross := false
    trend := 1

//-----------------------------------------------------------------------------}
// Pivot Low BOS/CHoCH
//-----------------------------------------------------------------------------{
var bear_concordant = true

if iConfluenceFiltered
    bear_concordant := high - math.max(close, open) < math.min(close, open - low)

// Detect internal bearish Structure
if ta.crossunder(close, iBtmY) and iBtmCross and btmY != iBtmY and bear_concordant
    bool choch = false
    
    if itrend > 0
        choch := true
    
    string txt = choch ? "CHoCH" : "BOS"

    if iStructureShowed
        if (iBearShowed == "All" or (iBearShowed == "BOS" and not choch) or (iBearShowed == "CHoCH" and choch)) and shouldDisplay
            displayStructure(iBtmX, iBtmY, txt, ibear_css, true, false, internal_structureLblSize)
    
    iBtmCross := false
    itrend := -1

// Detect bearish Structure
if ta.crossunder(close, btmY) and btmCross
    bool choch = na
    
    if trend > 0
        choch := true

    string txt = choch ? "CHoCH" : "BOS"
    
    if sStructureShowed
        if (sBearShowed == "All" or (sBearShowed == "BOS" and not choch) or (sBearShowed == "CHoCH" and choch))  and shouldDisplay
            displayStructure(btmX, btmY, txt, bear_css, false, false, swing_structureLblSize)

    btmCross := false
    trend := -1

//-----------------------------------------------------------------------------}
// Order Blocks
//-----------------------------------------------------------------------------{
string obTfStr = obMtfTf == "" ? timeframe.period : obMtfTf
string obTfPrefix = not(str.contains(obTfStr, "S")) and not(str.contains(obTfStr, "D")) and not(str.contains(obTfStr, "W")) and not(str.contains(obTfStr, "M")) ? str.tonumber(obTfStr) >= 60? str.tostring(str.tonumber(obTfStr) / 60) + "H" : obTfStr + "M" : obTfStr
string obTfTxt = obTfPrefix + " : "
var int obMaxWidth = 20

findOb() =>
    bool valid = false
    series float _high = high
    series float _low = low
    series float _open = open
    series float _close = close
    series float _vol = volume
    int idx = 1
    float fVol = 0.0
    var int bVol = 0
    var int sVol = 0
    var bool maxUsed = false
    var float min = 99999999.
    var float max = 0.

    if open[5] > close[5] and close[4] >= open[5] and low[1] > high[5] and low > high[5] and obShowed
        if low[5] > low[4]
            _high := math.min(high[4], high[5])
            _low := low[4]
            _open := open[4]        
            _close := close[4]
            _vol := volume[4]
            idx := time[4]
            valid := true
            maxUsed := false
        else
            _high := high[5]
            _low := low[5]
            _open := open[5]        
            _close := close[5]
            _vol := volume[5]
            idx := time[5]
            valid := true
            maxUsed := false
    else if open[5] < close[5] and close[4] <= open[5] and high[1] < low[5] and high < low[5] and obShowed
        if high[4] > high[5]
            _high := high[4]
            _low := math.max(low[4], low[5])
            _open := open[4]        
            _close := close[4]
            _vol := volume[4]
            idx := time[4]
            valid := true
            maxUsed := true
        else
            _high := high[5]
            _low := low[5]
            _open := open[5]        
            _close := close[5]
            _vol := volume[5]
            idx := time[5]
            valid := true
            maxUsed := true
    else if open[5] > close[5] and close[4] > close[5] and close[3] >= open[5] and low > high[5] and obShowed
        if low[5] > low[4]
            _high := math.min(high[4], high[5])
            _low := low[4]
            _open := open[4]        
            _close := close[4]
            _vol := volume[4]
            idx := time[4]
            valid := true
            maxUsed := false
        else
            _high := high[5]
            _low := low[5]
            _open := open[5]        
            _close := close[5]
            _vol := volume[5]
            idx := time[5]
            valid := true
            maxUsed := false
    else if open[5] < close[5] and close[4] < close[5] and close[3] <= open[5] and high < low[5] and obShowed
        if high[4] > high[5]
            _high := high[4]
            _low := math.max(low[4], low[5])
            _open := open[4]        
            _close := close[4]
            _vol := volume[4]
            idx := time[4]
            valid := true
            maxUsed := true
        else
            _high := high[5]
            _low := low[5]
            _open := open[5]      
            _close := close[5]
            _vol := volume[5]
            idx := time[5]
            valid := true
            maxUsed := true
    else
        valid := false

    if valid
        series float thold_ = (ta.highest(300) - ta.lowest(300)) * (obMaxWidth / 2.) / 100.
        series int buyingVol = math.round(_vol * (_close - _low) / (_high - _low))
        series int sellingVol = math.round(_vol * (_high - _close) / (_high - _low))
        series float tVol = (buyingVol + sellingVol) / 2.
        bVol := int((buyingVol / ta.highest(tVol, 300)) * 100)
        sVol := int((sellingVol / ta.highest(tVol, 300)) * 100)
        fVol := _vol

        // Search for highest/lowest high within the structure interval and get range
        if maxUsed
            max := _high
            min_1 = _low
            min := math.max(min_1, max - thold_)
        else
            max_1 = _high
            min := _low
            max := math.min(max_1, min + thold_)
    [valid, fVol, bVol, sVol, max, min, idx, maxUsed ? -1 : 1]

showOb(array<box> boxes, array<line> lines, array<float> targetTops, array<float> targetBtms, array<int> targetLefts, array<int> targetTypes, int showLast, series int size, array<float> vols, color col1, color col2, string tfTxt) =>
    for x = 0 to showLast - 1
        series box obBox = array.get(boxes, x)
        box.set_lefttop(obBox, na, na)
        box.set_rightbottom(obBox, na , na)
        box.set_border_color(obBox, na)
        box.set_bgcolor(obBox, na)
        series line obLine = array.get(lines, x)
        line.set_color(obLine, na)
        line.set_xy1(obLine, na, na)
        line.set_xy2(obLine, na, na)

    for i = 0 to size - 1
        series box obBox = array.get(boxes, i)
        series line obLine = array.get(lines, i)
        series int leftMax = bar_index - 750
        series float volTotal = array.sum(vols)
        series float vol = array.get(vols, i) > 100000000 ? array.get(vols, i) / 100000000. : array.get(vols, i)>1000000 ? array.get(vols, i) / 1000000. : array.get(vols, i) / 1000.
        series float volPercent = array.get(vols, i) / volTotal * 100
        string unit = array.get(vols, i) > 100000000 ? " B" : array.get(vols, i) > 1000000 ? " M" : " K"
        string volTxt = tfTxt +  str.tostring(vol, "#.##") + unit + " (" + str.tostring(volPercent, "#.##") + "%)"
        box.set_lefttop(obBox, array.get(targetLefts, i), array.get(targetTops, i))
        box.set_rightbottom(obBox, BAR_TIME_RIGHT_ALIGNMENT, array.get(targetBtms, i))
        box.set_text(obBox, volTxt)
        box.set_text_color(obBox, TXT_COLOR)
        box.set_border_color(obBox, TXT_COLOR)
        box.set_border_width(obBox, 2)
        box.set_text_halign(obBox, text.align_right)
        box.set_text_valign(obBox, text.align_center)
        box.set_text_size(obBox, size.normal)
        // line.set_extend(obLine, extend.none)
        // line.set_style(obLine, line.style_solid)
        // line.set_xy1(obLine, array.get(targetLeft, i), array.get(targetTop, i) - (array.get(targetTop, i) - array.get(targetBtm, i)) / 2)
        // line.set_xy2(obLine, time + ((time[1] - time[101]) / 10), array.get(targetTop, i) - (array.get(targetTop, i) - array.get(targetBtm, i)) / 2)
        // line.set_color(obLine, TXT_COLOR)
        color css = array.get(targetTypes, i) == 1 ? col1 : col2
        box.set_border_color(obBox, css)
        box.set_bgcolor(obBox, css)
        box.set_border_color(obBox, css)

removeOb(array<float> targetTops, array<float> targetBtms, int showLast, series int size) =>
    var int delIdx = 0
    bool deleted = false

    for i = 0 to size - 1
        if i > 0
            for x = i - 1 to 0
                if array.get(targetTops, i) >= array.get(targetBtms, x) and array.get(targetTops, i) <= array.get(targetTops, x)
                    deleted := true
                    delIdx := i
                if array.get(targetBtms, i) >= array.get(targetBtms, x) and array.get(targetBtms, i) <= array.get(targetTops, x)
                    deleted := true
                    delIdx := i
                if array.get(targetBtms, i) == array.get(targetBtms, x) and array.get(targetTops, i) == array.get(targetTops,x)
                    deleted := true
                    delIdx := i
                if array.get(targetBtms, i) <= array.get(targetBtms, x) and array.get(targetTops, i) >= array.get(targetTops,x)
                    deleted := true
                    delIdx := i
    [deleted, delIdx]

time_diff() => (time[1] - time[101]) / 100

var obTops = array.new_float(0)
var obBtms = array.new_float(0)
var obLefts = array.new_int(0)
var obTypes = array.new_int(0)
var obSellVols = array.new_int(0)
var obBuyVols = array.new_int(0)
var obVols = array.new_float(0)

var obMtfTops = array.new_float(0)
var obMtfBtms = array.new_float(0)
var obMtfLefts = array.new_int(0)
var obMtfTypes = array.new_int(0)
var obMtfSellVols = array.new_int(0)
var obMtfBuyVols = array.new_int(0)
var obMtfVols = array.new_float(0)

barMerge = barmerge.gaps_off
lookBars = barmerge.lookahead_on

[obValid, obFVol, obBVols, obSVols, obFTops, obFBtms, obFLefts, obFTypes] = request.security(ticker.standard(syminfo.tickerid), obTf, findOb(), barMerge, lookBars)
[obValidMtf, obMtfFVol, obMtfBVols, obMtfSVols, obMtfFTops, obMtfFBtms, obMtfFLefts, obMtfFTypes] = request.security(ticker.standard(syminfo.tickerid), obMtfTf, findOb(), barMerge, lookBars)

series int obTf1Request = request.security(ticker.standard(syminfo.tickerid), obTf, time_diff(), barMerge, lookBars)
series int obTf2Request = request.security(ticker.standard(syminfo.tickerid), obMtfTf, time_diff(), barMerge, lookBars)

if obValid and not(obValid[1]) and barstate.isconfirmed
    array.unshift(obVols, obFVol)
    array.unshift(obBuyVols, obBVols)
    array.unshift(obSellVols, obSVols)
    array.unshift(obTops, obFTops)
    array.unshift(obBtms, obFBtms)
    array.unshift(obLefts, obFLefts)
    array.unshift(obTypes, obFTypes)

if obValidMtf and not(obValidMtf[1]) and barstate.isconfirmed
    array.unshift(obMtfVols, obMtfFVol)
    array.unshift(obMtfBuyVols, obMtfBVols)
    array.unshift(obMtfSellVols, obMtfSVols)
    array.unshift(obMtfTops, obMtfFTops)
    array.unshift(obMtfBtms, obMtfFBtms)
    array.unshift(obMtfLefts, time - obTf2Request * 5)
    array.unshift(obMtfTypes, obMtfFTypes)

var obBoxes = array.new_box(0)
var obVolLines = array.new_line(0)
var obBuyBoxes = array.new_box(0)
var obSellBoxes = array.new_box(0)
var obMtfBoxes = array.new_box(0)
var obMtfVolLines = array.new_line(0)
var obMtfBuyBoxes = array.new_box(0)
var obMtfSellBoxes = array.new_box(0)

if array.size(obMtfTops) > obsMaxMtf
    array.pop(obMtfTops)
    array.pop(obMtfBtms)
    array.pop(obMtfLefts)
    array.pop(obMtfTypes)
    array.pop(obMtfBuyVols)
    array.pop(obMtfSellVols)
    array.pop(obMtfVols)

if array.size(obTops) > obsMax
    array.pop(obTops)
    array.pop(obBtms)
    array.pop(obLefts)
    array.pop(obTypes)
    array.pop(obBuyVols)
    array.pop(obSellVols)
    array.pop(obVols)

if array.size(obMtfTops) > 1
    for idx = 0 to array.size(obMtfTops) - 1
        series float src1 = obMitigationMtfFilt == "Wicks" or obMitigationMtfFilt == "Touch" ? low : obMitigationMtfFilt == "Close" ? close : low
        series float src2 = obMitigationMtfFilt == "Wicks" or obMitigationMtfFilt == "Touch" ? high : obMitigationMtfFilt == "Close" ? close : high
        series float up = obMitigationMtfFilt == "Touch" ? array.get(obMtfTops, idx) : obMitigationMtfFilt == "Average" ? array.get(obMtfTops, idx) - (array.get(obMtfTops, idx) - array.get(obMtfBtms, idx)) / 2  : array.get(obMtfBtms, idx)
        series float dn = obMitigationMtfFilt == "Touch" ? array.get(obMtfBtms, idx) : obMitigationMtfFilt == "Average" ? array.get(obMtfTops, idx) - (array.get(obMtfTops, idx) - array.get(obMtfBtms, idx)) / 2  : array.get(obMtfTops, idx)

        if (src1 < up or src1[1] < up or (obMitigationMtfFilt != "Touch" and src1[1] < up)) and array.get(obMtfTypes, idx) == 1
            array.remove(obMtfTops, idx) 
            array.remove(obMtfBtms, idx) 
            array.remove(obMtfLefts, idx) 
            array.remove(obMtfTypes, idx)
            array.remove(obMtfBuyVols, idx)
            array.remove(obMtfSellVols, idx)
            array.remove(obMtfVols, idx)
            break
        else if (src2 > dn or src2[1] > dn  or (obMitigationMtfFilt != "Touch" and src2[1] > dn)) and array.get(obMtfTypes, idx) == -1
            array.remove(obMtfTops, idx) 
            array.remove(obMtfBtms, idx)
            array.remove(obMtfLefts, idx) 
            array.remove(obMtfTypes, idx)
            array.remove(obMtfBuyVols, idx)
            array.remove(obMtfSellVols, idx)
            array.remove(obMtfVols, idx)
            break

if array.size(obTops) > 1
    for idx = 0 to array.size(obTops) - 1
        series float src1 = obMitigationFilt == "Wicks" or obMitigationFilt == "Touch"? low : obMitigationFilt == "Close" ? close : low
        series float src2 = obMitigationFilt == "Wicks" or obMitigationFilt == "Touch"? high : obMitigationFilt == "Close" ? close : high
        series float up = obMitigationFilt == "Touch" ? array.get(obTops, idx) : obMitigationFilt == "Average" ? array.get(obTops, idx) - (array.get(obTops, idx) - array.get(obBtms, idx)) / 2 : array.get(obBtms, idx)
        series float dn = obMitigationFilt == "Touch" ? array.get(obBtms, idx) : obMitigationFilt == "Average" ? array.get(obTops, idx) - (array.get(obTops, idx) - array.get(obBtms, idx)) / 2 : array.get(obTops, idx)

        if (src1 < up or src1[1] < up or (obMitigationFilt != "Touch" and src1[2] < up)) and array.get(obTypes, idx) == 1
            array.remove(obTops, idx) 
            array.remove(obBtms, idx) 
            array.remove(obLefts, idx) 
            array.remove(obTypes, idx)
            array.remove(obBuyVols, idx)
            array.remove(obSellVols, idx)
            array.remove(obVols, idx)
            break
        else if (src2 > dn or src2[1] > dn or (obMitigationFilt != "Touch" and src2[2] > dn)) and array.get(obTypes, idx) == -1
            array.remove(obTops, idx) 
            array.remove(obBtms, idx)
            array.remove(obLefts, idx) 
            array.remove(obTypes, idx)
            array.remove(obBuyVols, idx)
            array.remove(obSellVols, idx)
            array.remove(obVols, idx)
            break

series int obSize = array.size(obTypes)
series int obMtfSize = array.size(obMtfTypes)

if barstate.islast
    for i = 0 to obsMax - 1
        array.push(obBoxes, box.new(na, na, na, na, xloc = xloc.bar_time))
        array.push(obBuyBoxes, box.new(na, na, na, na, xloc = xloc.bar_time))
        array.push(obSellBoxes, box.new(na, na, na, na, xloc = xloc.bar_time))
        array.push(obVolLines, line.new(na, na, na, na, xloc = xloc.bar_time, color = TXT_COLOR, style = line.style_solid, width = 1))

    for i = 0 to obsMaxMtf - 1
        array.push(obMtfBoxes, box.new(na,na,na,na, xloc = xloc.bar_time))
        array.push(obMtfBuyBoxes, box.new(na,na,na,na, xloc = xloc.bar_time))
        array.push(obMtfSellBoxes, box.new(na,na,na,na, xloc = xloc.bar_time))
        array.push(obMtfVolLines, line.new(na,na,na,na, xloc = xloc.bar_time, color = TXT_COLOR, style = line.style_solid, width = 1))

if obSize > 1
    [deletedOb, delIdx] = removeOb(obTops, obBtms, obsMax, obSize)

    if deletedOb
        array.remove(obTops, delIdx)
        array.remove(obBtms, delIdx)
        array.remove(obLefts, delIdx)
        array.remove(obTypes, delIdx)
        array.remove(obBuyVols, delIdx)
        array.remove(obSellVols, delIdx)
        array.remove(obVols, delIdx)

if obMtfSize > 1
    [deletedOb, delIdx] = removeOb(obMtfTops, obMtfBtms, obsMaxMtf, obMtfSize)
    
    if deletedOb
        array.remove(obMtfTops, delIdx)
        array.remove(obMtfBtms, delIdx)
        array.remove(obMtfLefts, delIdx)
        array.remove(obMtfTypes, delIdx)
        array.remove(obMtfBuyVols, delIdx)
        array.remove(obMtfSellVols, delIdx)
        array.remove(obMtfVols, delIdx)

obMtfSize := array.size(obMtfTypes)
obSize := array.size(obTypes)

if obSize > 0 and barstate.islast
    if obShowed
        showOb(obBoxes, obVolLines, obTops, obBtms, obLefts, obTypes, obsMax, obSize, obVols, obBullishColor, obBearishColor, "")

if obMtfSize > 0 and barstate.islast
    if obMtfShowed
        showOb(obMtfBoxes, obMtfVolLines, obMtfTops, obMtfBtms, obMtfLefts, obMtfTypes, obsMaxMtf, obMtfSize, obMtfVols, obBullishMtfColor, obBearishMtfColor, obTfTxt)

//-----------------------------------------------------------------------------}
// Liquidity Levels
//-----------------------------------------------------------------------------{
getTfMulti(string tf) =>
    simple int ts = timeframe.in_seconds("")
    series int htfs = timeframe.in_seconds(tf)
    htfs / ts

shiftLimitBox(array<box> arr) =>
    if array.size(arr) > llMaxLevels / 2
        box.delete(array.shift(arr))

extendBoxToCurrent(array<box> arr) =>
    if array.size(arr) > 0
        for i = array.size(arr) - 1 to 0 by 1
            box.set_right(array.get(arr, i), BAR_TIME_RIGHT_ALIGNMENT)

removeMitigatedBoxes(array<box> arr, string hl) =>
    bool removed = false

    if array.size(arr) > 0
        for i = array.size(arr) - 1 to 0 by 1
            series box l = array.get(arr, i)
            series float hh = close[1]
            series float ll = close[1]

            if hl == "High" and hh > box.get_top(l)
                array.remove(arr, i)
                box.delete(l)
                removed := true
            if hl == "Low" and ll < box.get_top(l)
                array.remove(arr, i)
                box.delete(l)
                removed := true

    shiftLimitBox(arr) 
    removed


[_llTime, _llOpen, _llHigh, _llLow, _llClose] = request.security(syminfo.tickerid, llTf, [time, open, high, low, close])

series float llPivotHigh = ta.pivothigh(_llHigh, llPivotLen * getTfMulti(llTf), llPivotLen + getTfMulti(llTf))
series float llPivotLow = ta.pivotlow(_llLow, llPivotLen * getTfMulti(llTf), llPivotLen + getTfMulti(llTf))
var llHtfHighBoxes = array.new_box()
var llHtfLowBoxes = array.new_box()

if llShowed
    series float displacement = llPivotLen + getTfMulti(llTf)

    if not na(llPivotHigh)
        series float yOffset = _llHigh[displacement] - llTholdLiq
        array.push(llHtfHighBoxes, box.new(_llTime[displacement], _llHigh[displacement], _llTime[+1], yOffset, bgcolor = llBuySideColor, border_color = color.new(llBuySideColor, 90), xloc = xloc.bar_time, border_style = line.style_solid, extend = extend.none, border_width = 2, text = "BUY SIDE $$$", text_halign = text.align_center, text_color = WHITE_COLOR, text_size = size.small))  
    if not na(llPivotLow)
        series float yOffset = _llLow[displacement] + llTholdLiq
        array.push(llHtfLowBoxes, box.new(_llTime[displacement], _llLow[displacement], _llTime[+1], yOffset, bgcolor = llSellSideColor, border_color = color.new(llSellSideColor, 90), xloc = xloc.bar_time, border_style = line.style_solid, extend = extend.none, border_width = 2, text = "SELL SIDE $$$", text_halign = text.align_center, text_color = WHITE_COLOR, text_size = size.small))


removeMitigatedBoxes(llHtfHighBoxes, "High")
removeMitigatedBoxes(llHtfLowBoxes, "Low")
extendBoxToCurrent(llHtfHighBoxes)
extendBoxToCurrent(llHtfLowBoxes)

//-----------------------------------------------------------------------------}
// EQH/EQL
//-----------------------------------------------------------------------------{
var eqPrevTop = 0.
var eqTopX = 0
var eqPrevBtm = 0.
var eqBtmX = 0

if eqShowed
    series float eqTop = ta.pivothigh(eqLen, eqLen)
    series float eqBtm = ta.pivotlow(eqLen, eqLen)

    if not na(eqTop) 
        max = math.max(eqTop, eqPrevTop)
        min = math.min(eqTop, eqPrevTop)
        
        if max < min + atr * eqThreshold and shouldDisplay
            eqhLine = line.new(eqTopX, eqPrevTop, barIdx - eqLen, eqTop
              , color = bear_css
              , style = line.style_dotted)
            eqhLbl = label.new(int(math.avg(barIdx - eqLen, eqTopX)), eqTop, "EQH"
              , color = #00000000
              , textcolor = bear_css
              , style = label.style_label_down
              , size = eqhl_lblSize)

            if mode == "Present"
                line.delete(eqhLine[1])
                label.delete(eqhLbl[1])
            

        eqPrevTop := eqTop
        eqTopX := barIdx - eqLen

    if not na(eqBtm) 
        max = math.max(eqBtm, eqPrevBtm)
        min = math.min(eqBtm, eqPrevBtm)
        
        if min > max - atr * eqThreshold and shouldDisplay
            eqlLine = line.new(eqBtmX, eqPrevBtm, barIdx - eqLen, eqBtm
              , color = bull_css
              , style = line.style_dotted)
            eqlLbl = label.new(int(math.avg(barIdx - eqLen, eqBtmX)), eqBtm, "EQL"
              , color = #00000000
              , textcolor = bull_css
              , style = label.style_label_up
              , size = eqhl_lblSize)

            if mode == "Present"
                line.delete(eqlLine[1])
                label.delete(eqlLbl[1])

        eqPrevBtm := eqBtm
        eqBtmX := barIdx - eqLen

//-----------------------------------------------------------------------------}
// Fair Value Gaps
//-----------------------------------------------------------------------------{
var bullishFvgMax = array.new_box(0)
var bullishFvgMin = array.new_box(0)
var bearishFvgMax = array.new_box(0)
var bearishFvgMin = array.new_box(0)
float bullishFvgAvg = na
float bearishFvgAvg = na
bool bullishFvgCond = false
bool bearishFvgCond = false

[srcC1, srcO1, srcH, srcL, srcH2, srcL2] = request.security(syminfo.tickerid, fvgTf, getOHLC())

if fvgShowed
    series float delta = (srcC1 - srcO1) / srcO1 * 100
    series bool tfChanged = timeframe.change(fvgTf)
    series float threshold = fvgAuto ? ta.cum(math.abs(tfChanged ? delta : 0)) / barIdx * 2 : 0

    // FVG conditions
    bullishFvgCond := srcL > srcH2
      and srcC1 > srcH2 
      and delta > threshold
      and tfChanged
    bearishFvgCond := srcH < srcL2 
      and srcC1 < srcL2 
      and -delta > threshold
      and tfChanged

    // FVG Areas
    if bullishFvgCond and shouldDisplay
        array.unshift(bullishFvgMax, box.new(barIdx - 1, srcL, barIdx + fvgExtend, math.avg(srcL, srcH2)
          , border_color = fvgBullColor
          , bgcolor = fvgBullColor))
        array.unshift(bullishFvgMin, box.new(barIdx - 1, math.avg(srcL, srcH2), barIdx + fvgExtend, srcH2
          , border_color = fvgBullColor
          , bgcolor = fvgBullColor))
    
    if bearishFvgCond and shouldDisplay
        array.unshift(bearishFvgMax, box.new(barIdx - 1, srcH, barIdx + fvgExtend, math.avg(srcH, srcL2)
          , border_color = fvgBearColor
          , bgcolor = fvgBearColor))
        array.unshift(bearishFvgMin, box.new(barIdx - 1, math.avg(srcH, srcL2), barIdx + fvgExtend, srcL2
          , border_color = fvgBearColor
          , bgcolor = fvgBearColor))

    for bx in bullishFvgMin
        if low < box.get_bottom(bx)
            box.delete(bx)
            box.delete(array.get(bullishFvgMax, array.indexof(bullishFvgMin, bx)))
    
    for bx in bearishFvgMax
        if high > box.get_top(bx)
            box.delete(bx)
            box.delete(array.get(bearishFvgMin, array.indexof(bearishFvgMax, bx)))

//-----------------------------------------------------------------------------}
// Previous day/week high/lows
//-----------------------------------------------------------------------------{
// Daily high/low
[pdh, pdl] = request.security(syminfo.tickerid, "D", getHL()
  , lookahead = barmerge.lookahead_on)

// Weekly high/low
[pwh, pwl] = request.security(syminfo.tickerid, "W", getHL()
  , lookahead = barmerge.lookahead_on)

// Monthly high/low
[pmh, pml] = request.security(syminfo.tickerid, "M", getHL()
  , lookahead = barmerge.lookahead_on)

// Display Daily
if pdhlShowed
    getPHL(pdh, pdl, "D", pdhlColor)

// Display Weekly
if pwhlShowed
    getPHL(pwh, pwl, "W", pwhlColor)
    
// Display Monthly
if pmhlShowed
    getPHL(pmh, pml, "M", pmhlColor)

//-----------------------------------------------------------------------------}
// Premium/Discount/Equilibrium zones
//-----------------------------------------------------------------------------{
var premium = box.new(na, na, na, na, bgcolor = pdzBgColor, border_color = pdzBgColor, border_width = 2)

var premiumLbl = label.new(na, na
  , text = "Premium"
  , color = TRANSPARENT_COLOR
  , textcolor = pdzTextColor
  , style = label.style_label_down
  , size = size.small)

var eq = box.new(na, na, na, na, bgcolor = pdzBgColor, border_color = pdzBgColor, border_width = 2)

var eqLbl = label.new(na, na
  , text = "Equilibrium"
  , color = TRANSPARENT_COLOR
  , textcolor = pdzTextColor
  , style = label.style_label_left
  , size = size.small)

var discount = box.new(na, na, na, na, bgcolor = pdzBgColor, border_color = pdzBgColor, border_width = 2)

var discountLbl = label.new(na, na
  , text = "Discount"
  , color = TRANSPARENT_COLOR
  , textcolor = pdzTextColor
  , style = label.style_label_up
  , size = size.small)

// Show Premium/Discount Areas
if barstate.islast and pdzShowed
    // TODO
    series float avg = math.avg(trailUp, trailDn)
    box.set_lefttop(premium, math.max(topX, btmX), trailUp)
    box.set_rightbottom(premium, BAR_IDX_RIGHT_ALIGNMENT, .95 * trailUp + .05 * trailDn)
    label.set_xy(premiumLbl, int(math.avg(math.max(topX, btmX), BAR_IDX_RIGHT_ALIGNMENT)), trailUp)
    box.set_lefttop(eq, math.max(topX, btmX), .525 * trailUp + .475*trailDn)
    box.set_rightbottom(eq, BAR_IDX_RIGHT_ALIGNMENT, .525 * trailDn + .475 * trailUp)
    label.set_xy(eqLbl, BAR_IDX_RIGHT_ALIGNMENT, avg)
    box.set_lefttop(discount, math.max(topX, btmX), .95 * trailDn + .05 * trailUp)
    box.set_rightbottom(discount, BAR_IDX_RIGHT_ALIGNMENT, trailDn)
    label.set_xy(discountLbl, int(math.avg(math.max(topX, btmX), BAR_IDX_RIGHT_ALIGNMENT)), trailDn)

//-----------------------------------------------------------------------------}
// Trend
//-----------------------------------------------------------------------------{
var color trendColor = na

if trendShowed
    if style == "Colored"
        trendColor := itrend == 1 ? bull_css : bear_css
    else if style == "Monochrome"
        trendColor := itrend == 1 ? #b2b5be : #5d606b

plotcandle(open, high, low, close, color = trendColor, wickcolor = trendColor, bordercolor = trendColor, editable = false)

//-----------------------------------------------------------------------------}





//-----------------------------------------------------------------------------*
// Master Pattern
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string mpGrp = "Master Pattern"
bool mpShowed = input.bool(false, "Show", group = mpGrp)
int mpContractionLookback = input.int(3, "Contraction Detection Lookback", minval = 1, group = mpGrp)
int mpLiqLen = input.int(20, "Liquidity Levels Length", minval = 1, group = mpGrp)
color mpColor = input.color(PURPLE_COLOR, "Box & True Value Line Color", group = mpGrp)
bool mpMinorShowed = input(true, "Show Minor Pattern", group = mpGrp)
bool mpLiqShowed = input(true, "Show Liquidity Levels", group = mpGrp)
color mpUpperLiqColor = input.color(AQUA_COLOR, "Upper Liquidity Color", group = mpGrp)
color mpLowerLiqColor = input.color(RED_COLOR, "Lower Liquidity Color", group = mpGrp)

//-----------------------------------------------------------------------------}
// UDT
//-----------------------------------------------------------------------------{
type MasterPattern
    box area
    line avg
    bool breakup
    bool breakdn

//-----------------------------------------------------------------------------}
// Detect contraction & Liquidity Levels
//-----------------------------------------------------------------------------{
series float mpPh = ta.pivothigh(mpContractionLookback, mpContractionLookback)
series float mpPl = ta.pivotlow(mpContractionLookback, mpContractionLookback)
series float mpLiqPh = ta.pivothigh(mpLiqLen, mpLiqLen)
series float mpLiqPl = ta.pivotlow(mpLiqLen, mpLiqLen)

if shouldDisplay and mpShowed
    var mpPhy = 0., var mpPhx = 0, var mpPht = 0.
    var mpPly = 0., var mpPlx = 0, var mpPlt = 0.
    var float mpTop = na
    var float mpBot = na
    series int mpBarIdx = bar_index

    if not na(mpPh)
        mpPht := math.sign(mpPh - mpPhy)
        mpPhy := mpPh

        if mpPht == -1 and mpPlt == 1
            mpTop := mpPh
            mpBot := mpPly
            mpPhx := mpBarIdx - mpContractionLookback

    if not na(mpPl)
        mpPlt := math.sign(mpPl - mpPly)
        mpPly := mpPl

        if mpPht  == -1 and mpPlt == 1
            mpTop := mpPhy
            mpBot := mpPl
            mpPlx := mpBarIdx - mpContractionLookback

    var MasterPattern master = MasterPattern.new()
    bool mpIsBullish = high[mpContractionLookback] > mpTop and mpTop > mpBot
    bool mpIsBearish = low[mpContractionLookback] < mpBot and mpTop > mpBot

    if mpIsBullish or mpIsBearish
        master.avg.set_x2(mpBarIdx-mpContractionLookback)
        float val = math.avg(mpTop, mpBot)
  
        // Create new master pattern object
        master := MasterPattern.new(
          mpIsBullish or mpIsBearish ? box.new(math.max(mpPhx, mpPlx), mpTop, mpBarIdx-mpContractionLookback, mpBot, na, bgcolor = mpMinorShowed ? color.new(mpColor, 75) : na) : na
          , mpIsBullish or mpIsBearish ? line.new(mpBarIdx-mpContractionLookback, val, mpBarIdx, val, color = mpMinorShowed ? mpColor : na) : na
          , mpIsBullish
          , mpIsBearish)

        mpTop := na
        mpBot := na

    // Determine if pattern switch to major
    if master.breakup
        if low < master.area.get_bottom()
            master.area.set_border_color(mpColor)

            if not mpMinorShowed
                master.area.set_bgcolor(color.new(mpColor, 50))
                master.avg.set_color(mpColor)
    else if master.breakdn
        if high > master.area.get_top()
            master.area.set_border_color(mpColor)

            if not mpMinorShowed
                master.area.set_bgcolor(color.new(mpColor, 50))
                master.avg.set_color(mpColor)

    // Set friction level x2 coordinate to current bar
    if not na(master.avg)
        master.avg.set_x2(mpBarIdx)

    var line mpLiqUp = na, var liqupReached = false
    var line mpLiqDn = na, var liqdnReached = false

    // Set upper liquidity
    if not na(mpLiqPh) and mpLiqShowed
        if not liqupReached
            mpLiqUp.set_x2(mpBarIdx-mpLiqLen)

        mpLiqUp := line.new(mpBarIdx-mpLiqLen, mpLiqPh, mpBarIdx, mpLiqPh, color = mpUpperLiqColor, style = line.style_dotted)
        liqupReached := false
    else if not liqupReached and mpLiqShowed
        mpLiqUp.set_x2(mpBarIdx)

        if high > mpLiqUp.get_y1()
            liqupReached := true

    // Set lower liquidity
    if not na(mpLiqPl) and mpLiqShowed
        if not liqdnReached
            mpLiqDn.set_x2(mpBarIdx-mpLiqLen)

        mpLiqDn := line.new(mpBarIdx-mpLiqLen, mpLiqPl, mpBarIdx, mpLiqPl, color = mpLowerLiqColor, style = line.style_dotted)
        liqdnReached := false
    else if not liqdnReached and mpLiqShowed
        mpLiqDn.set_x2(mpBarIdx)

        if low < mpLiqDn.get_y1()
            liqdnReached := true

//-----------------------------------------------------------------------------}





//-----------------------------------------------------------------------------*
// OTE
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string oteGrp = "OTE"
bool oteShowed = input.bool(true, "Show", group = oteGrp)
string oteDepthTooltip = "The minimum number of bars that will be taken into account when calculating the indicator."
int oteDepth = input.int(10, "Depth", group = oteGrp, tooltip = oteDepthTooltip)
string oteDevTooltip = "Deviation is a multiplier that affects how much the price should deviate from the previous pivot in order for the bar to become a new pivot."
float oteThresholdMultiplier = input.float(3, "Deviation", group = oteGrp, tooltip = oteDevTooltip)
color oteColor = input.color(YELLOW_COLOR, "Color", group = oteGrp)

//-----------------------------------------------------------------------------}
// Types
//-----------------------------------------------------------------------------{
type Settings
    float devThreshold = 3
    int depth = 10

type Point
    int unixTime
    float price

type Pivot
    bool isHigh 
    float vol
    Point start
    Point end

type ZigZag
    Settings settings
    array<Pivot> pivots
    float volTotal = 0
    Pivot extend = na

//-----------------------------------------------------------------------------}
// Methods
//-----------------------------------------------------------------------------{
findPivotPoint(series float src, series float len, simple bool isHigh) =>
    float pivot = nz(src[len])

    if len == 0
        Point.new(time, pivot)
    else if len * 2 <= bar_index
        bool found = true

        for i = 0 to math.abs(len - 1)
            if (isHigh and src[i] > pivot) or (not isHigh and src[i] < pivot)
                found := false
                break

        for i = len + 1 to 2 * len
            if (isHigh and src[i] >= pivot) or (not isHigh and src[i] <= pivot)
                found := false
                break

        if found
            Point.new(time[len], pivot)

calcDev(series float basePrice, series float price) =>
    float result = 100 * (price - basePrice) / math.abs(basePrice)

method updatePivot(Pivot this, Point end, float vol, Settings settings) =>
    this.end := end
    this.vol := vol

getNewPivot(series Point start, series Point end, series float vol, series bool isHigh, series Settings settings) =>
    Pivot pivot = Pivot.new(isHigh, vol, start, end)
    pivot.updatePivot(end, vol, settings)
    pivot

method isPriceHigher(series Pivot this, series Point point) => 
    int mult = this.isHigh ? 1 : -1
    point.price * mult > this.end.price * mult

method getLastPivot(series ZigZag this) =>
    int size = this.pivots.size()
    size > 0 ? this.pivots.get(size - 1) : na

method updateLastPivot(series ZigZag this, series Point point) =>
    Pivot lastPivot = this.getLastPivot()

    if this.pivots.size() == 1
        lastPivot.start := point

    lastPivot.updatePivot(point, lastPivot.vol + this.volTotal, this.settings)
    this.volTotal := 0

method addNewPivot(series ZigZag this, series Pivot pivot) =>
    this.pivots.push(pivot)
    this.volTotal := 0

method hasNewPivotPointFound(series ZigZag this, simple bool isHigh, series Point point) =>
    bool found = false
    Pivot lastPivot = this.getLastPivot()

    if not na(lastPivot)
        if lastPivot.isHigh == isHigh 
            if lastPivot.isPriceHigher(point)
                this.updateLastPivot(point)
                found := true
        else
            float dev = calcDev(lastPivot.end.price, point.price)

            if (not lastPivot.isHigh and dev >= this.settings.devThreshold) or (lastPivot.isHigh and dev <= -1 * this.settings.devThreshold)
                this.addNewPivot(getNewPivot(lastPivot.end, point, this.volTotal, isHigh, this.settings))
                found := true
    else
        this.addNewPivot(getNewPivot(point, point, this.volTotal, isHigh, this.settings))
        found := true

    found

method findPivot(series ZigZag this, series float src, simple bool isHigh, series int depth, series bool pivotRegistered = true) =>
    Point point = findPivotPoint(src, depth, isHigh)
    not na(point) and pivotRegistered ? this.hasNewPivotPointFound(isHigh, point) : false

method updateZigzag(series ZigZag this, series float vols, series float highVal, series float lowVal, series int timeVal) =>
    int depth = math.max(2, math.floor(this.settings.depth / 2))
    this.volTotal += nz(vols[depth])
    bool updated = this.findPivot(highVal, true, depth)
    updated := this.findPivot(lowVal, false, depth, not updated) or updated
    Pivot lastPivot = this.getLastPivot()
    float remVol = math.sum(vols, math.max(depth, 1))

    if barstate.islast and not na(lastPivot)
        bool isHigh = not lastPivot.isHigh
        float curSeries = isHigh ? highVal : lowVal
        Point end = Point.new(timeVal, curSeries)

        if na(this.extend) or updated
            this.extend := getNewPivot(lastPivot.end, end, this.volTotal, isHigh, this.settings)

        this.extend.updatePivot(end, this.volTotal + remVol, this.settings)

    updated

initZigzag(series Settings settings = na) =>
    ZigZag result = ZigZag.new(na(settings) ? Settings.new() : settings, array.new<Pivot>())

getOTEVals(series float close_val, series float vol_val, series float highVal, series float lowVal, series int timeVal) =>
    var settings = Settings.new(oteThresholdMultiplier, oteDepth)
    var ZigZag zigzagInstance = initZigzag(settings)
    var Pivot lastPivot = na
    var float startPrice = na
    var float height = na
    settings.devThreshold := ta.atr(10) / close_val * 100 * oteThresholdMultiplier

    if zigzagInstance.updateZigzag(vol_val, highVal, lowVal, timeVal)
        lastPivot := zigzagInstance.getLastPivot()

        if not na(lastPivot)
            var line lastLine = na

            if na(lastLine) and oteShowed
                lastLine := line.new(lastPivot.start.unixTime, lastPivot.start.price, lastPivot.end.unixTime, lastPivot.end.price, xloc = xloc.bar_time, color = color.new(oteColor, 20), width = 1, style = line.style_dashed)
            else
                line.set_xy1(lastLine, lastPivot.start.unixTime, lastPivot.start.price)
                line.set_xy2(lastLine, lastPivot.end.unixTime, lastPivot.end.price)

            startPrice := lastPivot.end.price
            endPrice = lastPivot.start.price
            height := (startPrice > endPrice ? -1 : 1) * math.abs(startPrice - endPrice)

    [lastPivot, startPrice, height]

[oteLastPivot, oteStartPrice, oteHeight] = getOTEVals(close, volume, high, low, time)

drawFibLevel(Pivot pivot, float level, color color) =>
    var line fibLine = na, line.delete(fibLine)
    fibLine := line.new(pivot.start.unixTime, level, BAR_TIME_RIGHT_ALIGNMENT, level, color = color, width = 1, xloc = xloc.bar_time, extend = extend.none)
    fibLine

processFibLevel(Pivot pivot, series float startPrice, series float height, simple float val, color color) =>
    float level = startPrice + height * val

    if not na(pivot)
        line fibLine = drawFibLevel(pivot, level, color)
        [level, fibLine]
    else
        na

getPrdWidthByPerc(int prd, int perc) => (ta.highest(prd) - ta.lowest(prd)) * perc / 100

getTfTxt() =>
    string prd = timeframe.period
    string tf = na

    if str.contains(prd, "S")
        tf := str.length(prd) == 1 ? "1S" : prd
    else if str.contains(prd, "D")
        tf := str.length(prd) == 1 ? "1D" : prd
    else if str.contains(prd, "W")
        tf := str.length(prd) == 1 ? "1W" : prd
    else if str.contains(prd, "M")
        tf := str.length(prd) == 1 ? "1M" : prd
    else
        float mins = str.tonumber(prd)

        if mins >= 60
            tf := str.format("{0}H",  mins / 60)
        else
            tf := str.format("{0}M",  mins)

    tf

//-----------------------------------------------------------------------------}
// Plots
//-----------------------------------------------------------------------------{
if oteShowed
    [retracement1, retracement1Line] = processFibLevel(oteLastPivot, oteStartPrice, oteHeight, 0.618, color.new(oteColor, 20))
    [OTE, OTELine] = processFibLevel(oteLastPivot, oteStartPrice, oteHeight, 0.705, color.new(oteColor, 40))
    [retracement2, retracement2Line] = processFibLevel(oteLastPivot, oteStartPrice, oteHeight, 0.79, color.new(oteColor, 20))

    if barstate.islast
        linefill.new(retracement1Line, retracement2Line, color = color.new(oteColor, 95))
        float middle = (math.abs(retracement1 - retracement2) / 2) + (retracement1 > retracement2 ? retracement2 : retracement1)
        var label oteLabel = na, label.delete(oteLabel)
        oteLabel := label.new(BAR_TIME_RIGHT_ALIGNMENT, middle, xloc = xloc.bar_time, text = "OTE", color = TRANSPARENT_COLOR, textcolor = YELLOW_COLOR, size = size.small, style = label.style_label_left)

//-----------------------------------------------------------------------------}