// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tamth_

// @version=5
indicator("Price Action Supporter", "Price Action Supporter", overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, max_bars_back = 500)


//-----------------------------------------------------------------------------*
//  Constants
//-----------------------------------------------------------------------------{
color TRANSPARENT_COLOR = #ffffff00
color WHITE_COLOR = #ffffff
color RED_COLOR = #e91e62
color AQUA_COLOR = #00bbf9
color LIGHT_GRAY_COLOR = #364156
color DARK_GRAY_COLOR = #212d40
color GREEN_COLOR = #008170
color PURPLE_COLOR = #764AF1
color YELLOW_COLOR = #f2e40a
color ORANGE_COLOR = #f2aa0a

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Common Functions
//-----------------------------------------------------------------------------{
debug(simple string txt) =>
    // Create label on the first bar
    var label = label.new(bar_index, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, WHITE_COLOR, size.large, text.align_left)
    // On next bars, update the label"s x and y position, and the text it displays
    label.set_xy(label, bar_index, ta.highest(10)[1])
    label.set_text(label, txt)

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Volume Profile
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string vpGrp = "Volume Profile"
int vpLen = input.int(200, "Length", 1, 500, group = vpGrp)
int vpSmooth = input.int(3, "Smooth", 1, 6, group = vpGrp)
color vpHighColor = input.color(LIGHT_GRAY_COLOR, "Histogram Colors", inline = "hist", group = vpGrp)
color vpLowColor = input.color(DARK_GRAY_COLOR, "", inline = "hist", group = vpGrp)
int vpTransparency = input.int(20, "Transparency", 0, 100, group = vpGrp)
int vpOffset = input.int(20, "Offset From Last Bar", group = vpGrp)
int vpCompactionFactor = input.int(2, "Compaction Factor", tooltip = "Compact volume profile", minval = 1, maxval = 6, group = vpGrp)

//-----------------------------------------------------------------------------}
// Setup Volumes
//-----------------------------------------------------------------------------{
getWeight(int src, int bandwidth) =>
    if src == 0
        1
    else
        math.sin(math.pi * src / bandwidth) / (math.pi * src / bandwidth)  

getMultiKernelRegression(src, smooth)=>
    series int size = array.size(src)
    array<float> estimatedVals = array.new<float>(size) 
    float curPrice = na

    for i = 0 to size - 1 
        float sum = 0
        float sumw = 0

        for j = 0 to size - 1 
            int diff = i - j
            series float weight = getWeight(diff, smooth)
            sum += array.get(src, j) * weight
            sumw += weight

        curPrice := sum / sumw
        array.set(estimatedVals, i, curPrice >= 0 ? curPrice : 0)

    estimatedVals

int vpNumOfBars = 100
series float vpTop = ta.highest(vpLen)
series float vpBot = ta.lowest(vpLen)
series float vpDist = (vpTop - vpBot) / 500
series float vpStep = (vpTop - vpBot) / vpNumOfBars
array<float> vpLevels = array.new_float(vpNumOfBars + 1)

for x = 0 to vpNumOfBars by 1
    array.set(vpLevels, x, vpBot + vpStep * x)

caclLevelVol(float a, float b, float x, float y, float vol) =>
    // Bar is completely below or above the range
    if y < a or x > b
        0
    // Entire bar is inside the range but doesn't span it
    else if x >= a and y <= b
        pRange = (y - x) / (b - a)
        pRange * vol
    // Bar completely covers the range
    else if x <= a and y >= b
        pBar = (b - a) / (y - x)
        pBar * vol
    // vpTop of the bar is inside the range
    else if x < a and y <= b
        pBar = (y - a) / (y - x)
        pBar * vol
    // Bottom of the bar is inside the range
    else if x >= a and y > b
        pBar = (b - x) / (y - x)
        pBar * vol
    else
        vol

//-----------------------------------------------------------------------------}
// Render Volume Profile
//-----------------------------------------------------------------------------{
if barstate.islast
    array<float> levelVols = array.new_float(vpNumOfBars, 0.)
    array<float> bullishVols = array.new_float(vpNumOfBars, 0.)

    for i = 0 to vpLen - 1 by 1
        float _high = high[i]
        float _low = low[i]
        float _vol = volume[i]
        bool isBullish = open[i] < close[i]

        for x = 0 to vpNumOfBars - 1 by 1
            array.set(levelVols, x, array.get(levelVols, x) + caclLevelVol(array.get(vpLevels, x), array.get(vpLevels, x + 1), _low, _high, _vol))

            if isBullish
                array.set(bullishVols, x, array.get(bullishVols, x) + caclLevelVol(array.get(vpLevels, x), array.get(vpLevels, x + 1), _low, _high, _vol))
                 
    array<float> volColors = array.new_float(vpNumOfBars, 0.)

    for i = 0 to vpNumOfBars - 1
        float max_level = array.get(levelVols, i)
        float bullish_level = array.get(bullishVols, i)
        array.set(volColors, i, bullish_level / max_level)

    series float maxvol = array.max(levelVols)

    for x = 0 to vpNumOfBars - 1 by 1
        array.set(levelVols, x, array.get(levelVols, x) * vpLen / (3 * maxvol))

    array<float> processedVols = getMultiKernelRegression(levelVols, vpSmooth)
    int edge = bar_index + math.round(array.max(processedVols) / vpCompactionFactor) + vpOffset
    var volBars = array.new_box(vpNumOfBars, na)

    for i = 0 to vpNumOfBars - 1 by 1
        int vol = math.round(array.get(processedVols, i) / vpCompactionFactor)
        box.delete(array.get(volBars, i))
        array.set(
         volBars, i, 
         box.new(edge - vol, 
          array.get(vpLevels, i + 1) - vpDist, 
          edge, 
          array.get(vpLevels, i) + vpDist, 
          border_width = 0, 
          bgcolor = color.new(color.from_gradient(array.get(volColors, i), 0, 1, vpLowColor, vpHighColor), vpTransparency))
         )

//-----------------------------------------------------------------------------}





//-----------------------------------------------------------------------------*
// Smart Money Concepts
//-----------------------------------------------------------------------------*
// Tooltips
//-----------------------------------------------------------------------------{
string MODE_TOOLTIP          = 'Allows to display historical Structure or only the recent ones'
string STYLE_TOOLTIP         = 'Indicator color theme'
string COLOR_CANDLES_TOOLTIP = 'Display additional candles with a color reflecting the current trend detected by structure'
string SHOW_INTERNAL         = 'Display internal market structure'
string CONFLUENCE_FILTER     = 'Filter non significant internal structure breakouts'
string SHOW_SWING            = 'Display swing market Structure'
string SHOW_SWING_POINTS     = 'Display swing point as labels on the chart'
string SHOW_SWHL_POINTS      = 'Highlight most recent strong and weak high/low points on the chart'
string INTERNAL_OB           = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
string SWING_OB              = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
string FILTER_OB             = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
string SHOW_EQHL             = 'Display equal highs and equal lows on the chart'
string EQHL_BARS             = 'Number of bars used to confirm equal highs and equal lows'
string EQHL_THRESHOLD        = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
string SHOW_FVG              = 'Display fair values gaps on the chart'
string AUTO_FVG              = 'Filter out non significant fair value gaps'
string FVG_TF                = 'Fair value gaps timeframe'
string EXTEND_FVG            = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
string PED_ZONES             = 'Display premium, discount, and equilibrium zones on chart'

//-----------------------------------------------------------------------------}
// Settings
//-----------------------------------------------------------------------------{
// General
//----------------------------------------{
string mode = input.string('Historical'
  , options = ['Historical', 'Present']
  , group = 'Smart Money Concepts'
  , tooltip = MODE_TOOLTIP)

string style = input.string('Colored'
  , options = ['Colored', 'Monochrome']
  , group = 'Smart Money Concepts'
  , tooltip = STYLE_TOOLTIP)

bool trendShowed = input.bool(false, 'Color Candles'
  , group = 'Smart Money Concepts'
  , tooltip = COLOR_CANDLES_TOOLTIP)

//----------------------------------------}
// Internal Structure
//----------------------------------------{
bool iStructureShowed = input.bool(true, 'Show Internal Structure'
  , group = 'Real Time Internal Structure'
  , tooltip = SHOW_INTERNAL)

string iBullShowed = input.string('All', 'Bullish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'ibull'
  , group = 'Real Time Internal Structure')

color iBullColor = input.color(AQUA_COLOR, ''
  , inline = 'ibull'
  , group = 'Real Time Internal Structure')

string iBearShowed = input.string('All', 'Bearish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'ibear'
  , group = 'Real Time Internal Structure')

color iBearColor = input.color(RED_COLOR, ''
  , inline = 'ibear'
  , group = 'Real Time Internal Structure')

bool iConfluenceFiltered = input.bool(false, 'Confluence Filter'
  , group = 'Real Time Internal Structure'
  , tooltip = CONFLUENCE_FILTER)

string iStructureSize = input.string('Tiny', 'Internal Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'Real Time Internal Structure')

//----------------------------------------}
// Swing Structure
//----------------------------------------{
bool sStructureShowed = input.bool(true, 'Show Swing Structure'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWING)

string sBullShowed = input.string('All', 'Bullish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'bull'
  , group = 'Real Time Swing Structure')

color sBullColor = input.color(AQUA_COLOR, ''
  , inline = 'bull'
  , group = 'Real Time Swing Structure')

string sBearShowed = input.string('All', 'Bearish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'bear'
  , group = 'Real Time Swing Structure')

color sBearColor = input.color(RED_COLOR, ''
  , inline = 'bear'
  , group = 'Real Time Swing Structure')

string sStructureSize = input.string('Small', 'Swing Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'Real Time Swing Structure')

bool swingsPointsShowed = input.bool(false, 'Show Swings Points'
  , inline = 'swings'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWING_POINTS)

int swingLen = input.int(50, ''
  , minval = 10
  , inline = 'swings'
  , group = 'Real Time Swing Structure')

bool hlSwingsShowed = input.bool(true, 'Show Strong/Weak High/Low'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWHL_POINTS)

//----------------------------------------}
// Order Blocks
//----------------------------------------{
bool iobShowed = input.bool(true, 'Internal Order Blocks'
  , inline = 'iob'
  , group = 'Order Blocks'
  , tooltip = INTERNAL_OB)

int numOfIobs = input.int(5, ''
  , minval = 1
  , inline = 'iob'
  , group = 'Order Blocks')

bool sobShowed = input.bool(false, 'Swing Order Blocks'
  , inline = 'ob'
  , group = 'Order Blocks'
  , tooltip = SWING_OB)

int numOfSobs = input.int(5, ''
  , minval = 1
  , inline = 'ob'
  , group = 'Order Blocks')

string obFilter = input.string('Atr', 'Order Block Filter'
  , options = ['Atr', 'Cumulative Mean Range']
  , group = 'Order Blocks'
  , tooltip = FILTER_OB)

color iobBullColor = input.color(color.new(AQUA_COLOR, 85), 'Internal Bullish OB'
  , group = 'Order Blocks')

color iobBearColor = input.color(color.new(RED_COLOR, 85), 'Internal Bearish OB'
  , group = 'Order Blocks')

color sobBullColor = input.color(color.new(AQUA_COLOR, 85), 'Bullish OB'
  , group = 'Order Blocks')

color sobBearColor = input.color(color.new(RED_COLOR, 85), 'Bearish OB'
  , group = 'Order Blocks')

//----------------------------------------}
// EQH/EQL
//----------------------------------------{
bool eqShowed = input.bool(true, 'Equal High/Low'
  , group = 'EQH/EQL'
  , tooltip = SHOW_EQHL)

int eqLen = input.int(3, 'Bars Confirmation'
  , minval = 1
  , group = 'EQH/EQL'
  , tooltip = EQHL_BARS)

float eqThreshold = input.float(0.1, 'Threshold'
  , minval = 0
  , maxval = 0.5
  , step = 0.1
  , group = 'EQH/EQL'
  , tooltip = EQHL_THRESHOLD)

string eqSize = input.string('Tiny', 'Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'EQH/EQL')

//----------------------------------------}
// Fair Value Gaps
//----------------------------------------{
bool fvgShowed = input.bool(true, 'Fair Value Gaps'
  , group = 'Fair Value Gaps'
  , tooltip = SHOW_FVG)
  
bool fvgAuto = input.bool(true, "Auto Threshold"
  , group = 'Fair Value Gaps'
  , tooltip = AUTO_FVG)

var fvgTf = input.timeframe('', "Timeframe"
  , group = 'Fair Value Gaps'
  , tooltip = FVG_TF)

color fvgBullColor = input.color(color.new(AQUA_COLOR, 70), 'Bullish FVG'
  , group = 'Fair Value Gaps')

color fvgBearColor = input.color(color.new(RED_COLOR, 70), 'Bearish FVG'
  , group = 'Fair Value Gaps')

int fvgExtend = input.int(1, "Extend FVG"
  , minval = 0
  , group = 'Fair Value Gaps'
  , tooltip = EXTEND_FVG)

//----------------------------------------}
// Previous day/week high/low
//----------------------------------------{
// Daily
bool pdhlShowed = input.bool(false, 'Daily'
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

string pdhlStyle = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

color pdhlColor = input.color(YELLOW_COLOR, ''
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

// Weekly
bool pwhlShowed = input.bool(false, 'Weekly'
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

string pwhlStyle = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

color pwhlColor = input.color(YELLOW_COLOR, ''
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

// Monthly
bool pmhlShowed = input.bool(false, 'Monthly'
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

string pmhlStyle = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

color pmhlColor = input.color(YELLOW_COLOR, ''
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

//----------------------------------------}
// Premium/Discount zones
//----------------------------------------{
bool pdzShowed = input.bool(true, 'Premium/Discount Zones'
  , group = 'Premium & Discount Zones'
  , tooltip = PED_ZONES)

color premiumColor = input.color(ORANGE_COLOR, 'Premium Zone'
  , group = 'Premium & Discount Zones')

color eqColor = input.color(color.new(WHITE_COLOR, 60), 'Equilibrium Zone'
  , group = 'Premium & Discount Zones')

color discountColor = input.color(GREEN_COLOR, 'Discount Zone'
  , group = 'Premium & Discount Zones')

//-----------------------------------------------------------------------------}
// Functions
//-----------------------------------------------------------------------------{
barIdx = bar_index
atr = ta.atr(200)
cmean_range = ta.cum(high - low) / barIdx

// HL Output function
hl() => [high, low]

// Get ohlc values function
get_ohlc()=> [close[1], open[1], high, low, high[2], low[2]]

// Display Structure function
display_Structure(x, y, txt, css, dashed, down, lbl_size)=>
    structure_line = line.new(x, y, barIdx, y
      , color = css
      , style = dashed ? line.style_dashed : line.style_solid)

    structure_lbl = label.new(int(math.avg(x, barIdx)), y, txt
      , color = TRANSPARENT_COLOR
      , textcolor = css
      , style = down ? label.style_label_down : label.style_label_up
      , size = lbl_size)

    if mode == 'Present'
        line.delete(structure_line[1])
        label.delete(structure_lbl[1])

// Swings detection/measurements
swings(len)=>
    var os = 0
    
    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]

    top = os == 0 and os[1] != 0 ? high[len] : 0
    btm = os == 1 and os[1] != 1 ? low[len] : 0

    [top, btm]

// Order block coordinates function
ob_coord(use_max, loc, target_top, target_btm, target_left, target_type)=>
    min = 99999999.
    max = 0.
    idx = 1

    ob_threshold = obFilter == 'Atr' ? atr : cmean_range 

    // Search for highest/lowest high within the structure interval and get range
    if use_max
        for i = 1 to (barIdx - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                max := math.max(high[i], max)
                min := max == high[i] ? low[i] : min
                idx := max == high[i] ? i : idx
    else
        for i = 1 to (barIdx - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                min := math.min(low[i], min)
                max := min == low[i] ? high[i] : max
                idx := min == low[i] ? i : idx

    array.unshift(target_top, max)
    array.unshift(target_btm, min)
    array.unshift(target_left, time[idx])
    array.unshift(target_type, use_max ? -1 : 1)

// Set order blocks
getTfMillis() => math.round(timeframe.multiplier * (timeframe.isseconds ? 1 : timeframe.isminutes ? 1. : timeframe.isdaily ? 60. * 24 : timeframe.isweekly ? 60. * 24 * 7 : timeframe.ismonthly ? 60. * 24 * 30.4375 : 0)) * 60 * 1000

display_ob(boxes, target_top, target_btm, target_left, target_type, show_last, swing, size)=>
    for i = 0 to math.min(show_last - 1, size - 1)
        get_box = array.get(boxes, i)
        box.set_lefttop(get_box, array.get(target_left, i), array.get(target_top, i))
        box.set_rightbottom(get_box, time[0], array.get(target_btm, i))

        color css = na
        
        if swing 
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
                border_css = array.get(target_type, i) == 1 ? #b2b5be : #5d606b
                box.set_border_color(get_box, border_css)
            else
                css := array.get(target_type, i) == 1 ? sobBullColor : sobBearColor
                box.set_border_color(get_box, css)

            box.set_bgcolor(get_box, css)
        else
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
            else
                css := array.get(target_type, i) == 1 ? iobBullColor : iobBearColor
            
            box.set_border_color(get_box, css)
            box.set_bgcolor(get_box, css)

        
// Line Style function
get_line_style(style) =>
    out = switch style
        '⎯⎯⎯'  => line.style_solid
        '----' => line.style_dashed
        '····' => line.style_dotted

// Set line/labels function for previous high/lows
phl(h, l, tf, css)=>
    var line high_line = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = get_line_style(pdhlStyle))

    var label high_lbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format('P{0}H', tf)
      , color = TRANSPARENT_COLOR
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)

    var line low_line = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = get_line_style(pdhlStyle))

    var label low_lbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format('P{0}L', tf)
      , color = TRANSPARENT_COLOR
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)

    hy = ta.valuewhen(h != h[1], h, 1)
    hx = ta.valuewhen(h == high, time, 1)

    ly = ta.valuewhen(l != l[1], l, 1)
    lx = ta.valuewhen(l == low, time, 1)

    if barstate.islast
        ext = time + (time - time[1])*20

        //High
        line.set_xy1(high_line, hx, hy)
        line.set_xy2(high_line, ext, hy)

        label.set_xy(high_lbl, ext, hy)

        //Low
        line.set_xy1(low_line, lx, ly)
        line.set_xy2(low_line, ext, ly)

        label.set_xy(low_lbl, ext, ly)

//-----------------------------------------------------------------------------}
// Global variables
//-----------------------------------------------------------------------------{
var trend = 0, var itrend = 0

var top_y = 0., var top_x = 0
var btm_y = 0., var btm_x = 0

var itop_y = 0., var itop_x = 0
var ibtm_y = 0., var ibtm_x = 0

var trail_up = high, var trail_dn = low
var trail_up_x = 0,  var trail_dn_x = 0

var top_cross = true,  var btm_cross = true
var itop_cross = true, var ibtm_cross = true

var txt_top = '',  var txt_btm = ''

// Alerts
bull_choch_alert = false 
bull_bos_alert   = false 

bear_choch_alert = false 
bear_bos_alert   = false 

bull_ichoch_alert = false 
bull_ibos_alert   = false 

bear_ichoch_alert = false 
bear_ibos_alert   = false 

bull_iob_break = false 
bear_iob_break = false

bull_ob_break = false 
bear_ob_break = false

eqh_alert = false 
eql_alert = false 

// Structure colors
var bull_css = style == 'Monochrome' ? #b2b5be 
  : sBullColor

var bear_css = style == 'Monochrome' ? #b2b5be 
  : sBearColor

var ibull_css = style == 'Monochrome' ? #b2b5be 
  : iBullColor

var ibear_css = style == 'Monochrome' ? #b2b5be 
  : iBearColor

// Labels size
var internal_structure_lbl_size = iStructureSize == 'Tiny' 
  ? size.tiny 
  : iStructureSize == 'Small' 
  ? size.small 
  : size.normal 

var swing_structure_lbl_size = sStructureSize == 'Tiny' 
  ? size.tiny 
  : sStructureSize == 'Small' 
  ? size.small 
  : size.normal 

var eqhl_lbl_size = eqSize == 'Tiny' 
  ? size.tiny 
  : eqSize == 'Small' 
  ? size.small
  : size.normal 

// Swings
[top, btm] = swings(swingLen)

[itop, ibtm] = swings(5)

//-----------------------------------------------------------------------------}
// Pivot High
//-----------------------------------------------------------------------------{
var line extend_top = na

var label extend_top_lbl = label.new(na, na
  , color = TRANSPARENT_COLOR
  , textcolor = bear_css
  , style = label.style_label_down
  , size = size.tiny)

if top
    top_cross := true
    txt_top := top > top_y ? 'HH' : 'LH'

    if swingsPointsShowed
        top_lbl = label.new(barIdx - swingLen, top, txt_top
          , color = TRANSPARENT_COLOR
          , textcolor = bear_css
          , style = label.style_label_down
          , size = swing_structure_lbl_size)

        if mode == 'Present'
            label.delete(top_lbl[1])

    // Extend recent top to last bar
    line.delete(extend_top[1])
    extend_top := line.new(barIdx - swingLen, top, barIdx, top, color = bear_css)

    top_y := top
    top_x := barIdx - swingLen

    trail_up := top
    trail_up_x := barIdx - swingLen

if itop
    itop_cross := true

    itop_y := itop
    itop_x := barIdx - 5

// Trailing maximum
trail_up := math.max(high, trail_up)
trail_up_x := trail_up == high ? barIdx : trail_up_x

// Set top extension label/line
if barstate.islast and hlSwingsShowed
    line.set_xy1(extend_top, trail_up_x, trail_up)
    line.set_xy2(extend_top, barIdx + 12, trail_up)

    label.set_x(extend_top_lbl, barIdx + 12)
    label.set_y(extend_top_lbl, trail_up)
    label.set_text(extend_top_lbl, trend < 0 ? 'Strong High' : 'Weak High')

//-----------------------------------------------------------------------------}
// Pivot Low
//-----------------------------------------------------------------------------{
var line extend_btm = na 

var label extend_btm_lbl = label.new(na, na
  , color = TRANSPARENT_COLOR
  , textcolor = bull_css
  , style = label.style_label_up
  , size = size.tiny)

if btm
    btm_cross := true
    txt_btm := btm < btm_y ? 'LL' : 'HL'
    
    if swingsPointsShowed
        btm_lbl = label.new(barIdx - swingLen, btm, txt_btm
          , color = TRANSPARENT_COLOR
          , textcolor = bull_css
          , style = label.style_label_up
          , size = swing_structure_lbl_size)

        if mode == 'Present'
            label.delete(btm_lbl[1])
    
    // Extend recent btm to last bar
    line.delete(extend_btm[1])
    extend_btm := line.new(barIdx - swingLen, btm, barIdx, btm, color = bull_css)

    btm_y := btm
    btm_x := barIdx - swingLen

    trail_dn := btm
    trail_dn_x := barIdx - swingLen

if ibtm
    ibtm_cross := true

    ibtm_y := ibtm
    ibtm_x := barIdx - 5

// Trailing minimum
trail_dn := math.min(low, trail_dn)
trail_dn_x := trail_dn == low ? barIdx : trail_dn_x

// Set btm extension label/line
if barstate.islast and hlSwingsShowed
    line.set_xy1(extend_btm, trail_dn_x, trail_dn)
    line.set_xy2(extend_btm, barIdx + 12, trail_dn)

    label.set_x(extend_btm_lbl, barIdx + 12)
    label.set_y(extend_btm_lbl, trail_dn)
    label.set_text(extend_btm_lbl, trend > 0 ? 'Strong Low' : 'Weak Low')

//-----------------------------------------------------------------------------}
// Order Blocks Arrays
//-----------------------------------------------------------------------------{
var iob_top = array.new_float(0)
var iob_btm = array.new_float(0)
var iob_left = array.new_int(0)
var iob_type = array.new_int(0)

var ob_top = array.new_float(0)
var ob_btm = array.new_float(0)
var ob_left = array.new_int(0)
var ob_type = array.new_int(0)

//-----------------------------------------------------------------------------}
// Pivot High BOS/CHoCH
//-----------------------------------------------------------------------------{
// Filtering
var bull_concordant = true

if iConfluenceFiltered
    bull_concordant := high - math.max(close, open) > math.min(close, open - low)

// Detect internal bullish Structure
if ta.crossover(close, itop_y) and itop_cross and top_y != itop_y and bull_concordant
    bool choch = na
    
    if itrend < 0
        choch := true
        bull_ichoch_alert := true
    else 
        bull_ibos_alert := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    if iStructureShowed
        if iBullShowed == 'All' or (iBullShowed == 'BOS' and not choch) or (iBullShowed == 'CHoCH' and choch)
            display_Structure(itop_x, itop_y, txt, ibull_css, true, true, internal_structure_lbl_size)
    
    itop_cross := false
    itrend := 1
    
    // Internal Order Block
    if iobShowed
        ob_coord(false, itop_x, iob_top, iob_btm, iob_left, iob_type)

// Detect bullish Structure
if ta.crossover(close, top_y) and top_cross
    bool choch = na
    
    if trend < 0
        choch := true
        bull_choch_alert := true
    else 
        bull_bos_alert := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    if sStructureShowed
        if sBullShowed == 'All' or (sBullShowed == 'BOS' and not choch) or (sBullShowed == 'CHoCH' and choch)
            display_Structure(top_x, top_y, txt, bull_css, false, true, swing_structure_lbl_size)
    
    // Order Block
    if sobShowed
        ob_coord(false, top_x, ob_top, ob_btm, ob_left, ob_type)

    top_cross := false
    trend := 1

//-----------------------------------------------------------------------------}
// Pivot Low BOS/CHoCH
//-----------------------------------------------------------------------------{
var bear_concordant = true

if iConfluenceFiltered
    bear_concordant := high - math.max(close, open) < math.min(close, open - low)

// Detect internal bearish Structure
if ta.crossunder(close, ibtm_y) and ibtm_cross and btm_y != ibtm_y and bear_concordant
    bool choch = false
    
    if itrend > 0
        choch := true
        bear_ichoch_alert := true
    else 
        bear_ibos_alert := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    if iStructureShowed
        if iBearShowed == 'All' or (iBearShowed == 'BOS' and not choch) or (iBearShowed == 'CHoCH' and choch)
            display_Structure(ibtm_x, ibtm_y, txt, ibear_css, true, false, internal_structure_lbl_size)
    
    ibtm_cross := false
    itrend := -1
    
    // Internal Order Block
    if iobShowed
        ob_coord(true, ibtm_x, iob_top, iob_btm, iob_left, iob_type)

// Detect bearish Structure
if ta.crossunder(close, btm_y) and btm_cross
    bool choch = na
    
    if trend > 0
        choch := true
        bear_choch_alert := true
    else 
        bear_bos_alert := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    if sStructureShowed
        if sBearShowed == 'All' or (sBearShowed == 'BOS' and not choch) or (sBearShowed == 'CHoCH' and choch)
            display_Structure(btm_x, btm_y, txt, bear_css, false, false, swing_structure_lbl_size)
    
    // Order Block
    if sobShowed
        ob_coord(true, btm_x, ob_top, ob_btm, ob_left, ob_type)

    btm_cross := false
    trend := -1

//-----------------------------------------------------------------------------}
// Order Blocks
//-----------------------------------------------------------------------------{
// Set order blocks
var iob_boxes = array.new_box(0)
var ob_boxes = array.new_box(0)

// Delete internal order blocks box coordinates if top/bottom is broken
for element in iob_type
    index = array.indexof(iob_type, element)

    if close < array.get(iob_btm, index) and element == 1
        array.remove(iob_top, index) 
        array.remove(iob_btm, index) 
        array.remove(iob_left, index) 
        array.remove(iob_type, index)
        bull_iob_break := true

    else if close > array.get(iob_top, index) and element == -1
        array.remove(iob_top, index) 
        array.remove(iob_btm, index)
        array.remove(iob_left, index) 
        array.remove(iob_type, index)
        bear_iob_break := true

// Delete internal order blocks box coordinates if top/bottom is broken
for element in ob_type
    index = array.indexof(ob_type, element)

    if close < array.get(ob_btm, index) and element == 1
        array.remove(ob_top, index) 
        array.remove(ob_btm, index) 
        array.remove(ob_left, index) 
        array.remove(ob_type, index)
        bull_ob_break := true

    else if close > array.get(ob_top, index) and element == -1
        array.remove(ob_top, index) 
        array.remove(ob_btm, index)
        array.remove(ob_left, index) 
        array.remove(ob_type, index)
        bear_ob_break := true

iob_size = array.size(iob_type)
ob_size = array.size(ob_type)

if barstate.isfirst
    if iobShowed
        for i = 0 to numOfIobs-1
            array.push(iob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))
    if sobShowed
        for i = 0 to numOfSobs-1
            array.push(ob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))

if iob_size > 0
    if barstate.islast
        display_ob(iob_boxes, iob_top, iob_btm, iob_left, iob_type, numOfIobs, false, iob_size)

if ob_size > 0
    if barstate.islast
        display_ob(ob_boxes, ob_top, ob_btm, ob_left, ob_type, numOfSobs, true, ob_size)

//-----------------------------------------------------------------------------}
// EQH/EQL
//-----------------------------------------------------------------------------{
var eq_prev_top = 0.
var eq_top_x = 0

var eq_prev_btm = 0.
var eq_btm_x = 0

if eqShowed
    eq_top = ta.pivothigh(eqLen, eqLen)
    eq_btm = ta.pivotlow(eqLen, eqLen)

    if eq_top 
        max = math.max(eq_top, eq_prev_top)
        min = math.min(eq_top, eq_prev_top)
        
        if max < min + atr * eqThreshold
            eqh_line = line.new(eq_top_x, eq_prev_top, barIdx - eqLen, eq_top
              , color = bear_css
              , style = line.style_dotted)

            eqh_lbl = label.new(int(math.avg(barIdx - eqLen, eq_top_x)), eq_top, 'EQH'
              , color = #00000000
              , textcolor = bear_css
              , style = label.style_label_down
              , size = eqhl_lbl_size)

            if mode == 'Present'
                line.delete(eqh_line[1])
                label.delete(eqh_lbl[1])
            
            eqh_alert := true

        eq_prev_top := eq_top
        eq_top_x := barIdx - eqLen

    if eq_btm 
        max = math.max(eq_btm, eq_prev_btm)
        min = math.min(eq_btm, eq_prev_btm)
        
        if min > max - atr * eqThreshold
            eql_line = line.new(eq_btm_x, eq_prev_btm, barIdx - eqLen, eq_btm
              , color = bull_css
              , style = line.style_dotted)

            eql_lbl = label.new(int(math.avg(barIdx - eqLen, eq_btm_x)), eq_btm, 'EQL'
              , color = #00000000
              , textcolor = bull_css
              , style = label.style_label_up
              , size = eqhl_lbl_size)

            eql_alert := true

            if mode == 'Present'
                line.delete(eql_line[1])
                label.delete(eql_lbl[1])

        eq_prev_btm := eq_btm
        eq_btm_x := barIdx - eqLen

//-----------------------------------------------------------------------------}
// Fair Value Gaps
//-----------------------------------------------------------------------------{
var bullish_fvg_max = array.new_box(0)
var bullish_fvg_min = array.new_box(0)

var bearish_fvg_max = array.new_box(0)
var bearish_fvg_min = array.new_box(0)

float bullish_fvg_avg = na
float bearish_fvg_avg = na

bullish_fvg_cnd = false
bearish_fvg_cnd = false

[src_c1, src_o1, src_h, src_l, src_h2, src_l2] =
  request.security(syminfo.tickerid, fvgTf, get_ohlc())

if fvgShowed
    delta_per = (src_c1 - src_o1) / src_o1 * 100

    change_tf = timeframe.change(fvgTf)

    threshold = fvgAuto ? ta.cum(math.abs(change_tf ? delta_per : 0)) / barIdx * 2 
      : 0

    // FVG conditions
    bullish_fvg_cnd := src_l > src_h2
      and src_c1 > src_h2 
      and delta_per > threshold
      and change_tf

    bearish_fvg_cnd := src_h < src_l2 
      and src_c1 < src_l2 
      and -delta_per > threshold
      and change_tf

    // FVG Areas
    if bullish_fvg_cnd
        array.unshift(bullish_fvg_max, box.new(barIdx - 1, src_l, barIdx + fvgExtend, math.avg(src_l, src_h2)
          , border_color = fvgBullColor
          , bgcolor = fvgBullColor))
        
        array.unshift(bullish_fvg_min, box.new(barIdx - 1, math.avg(src_l, src_h2), barIdx + fvgExtend, src_h2
          , border_color = fvgBullColor
          , bgcolor = fvgBullColor))
    
    if bearish_fvg_cnd
        array.unshift(bearish_fvg_max, box.new(barIdx - 1, src_h, barIdx + fvgExtend, math.avg(src_h, src_l2)
          , border_color = fvgBearColor
          , bgcolor = fvgBearColor))
        
        array.unshift(bearish_fvg_min, box.new(barIdx - 1, math.avg(src_h, src_l2), barIdx + fvgExtend, src_l2
          , border_color = fvgBearColor
          , bgcolor = fvgBearColor))

    for bx in bullish_fvg_min
        if low < box.get_bottom(bx)
            box.delete(bx)
            box.delete(array.get(bullish_fvg_max, array.indexof(bullish_fvg_min, bx)))
    
    for bx in bearish_fvg_max
        if high > box.get_top(bx)
            box.delete(bx)
            box.delete(array.get(bearish_fvg_min, array.indexof(bearish_fvg_max, bx)))

//-----------------------------------------------------------------------------}
// Previous day/week high/lows
//-----------------------------------------------------------------------------{
// Daily high/low
[pdh, pdl] = request.security(syminfo.tickerid, 'D', hl()
  , lookahead = barmerge.lookahead_on)

// Weekly high/low
[pwh, pwl] = request.security(syminfo.tickerid, 'W', hl()
  , lookahead = barmerge.lookahead_on)

// Monthly high/low
[pmh, pml] = request.security(syminfo.tickerid, 'M', hl()
  , lookahead = barmerge.lookahead_on)

// Display Daily
if pdhlShowed
    phl(pdh, pdl, 'D', pdhlColor)

// Display Weekly
if pwhlShowed
    phl(pwh, pwl, 'W', pwhlColor)
    
// Display Monthly
if pmhlShowed
    phl(pmh, pml, 'M', pmhlColor)

//-----------------------------------------------------------------------------}
// Premium/Discount/Equilibrium zones
//-----------------------------------------------------------------------------{
var premium = box.new(na, na, na, na
  , bgcolor = color.new(premiumColor, 80)
  , border_color = na)

var premium_lbl = label.new(na, na
  , text = 'Premium'
  , color = TRANSPARENT_COLOR
  , textcolor = premiumColor
  , style = label.style_label_down
  , size = size.small)

var eq = box.new(na, na, na, na
  , bgcolor = color.new(eqColor, 95)
  , border_color = na)

var eq_lbl = label.new(na, na
  , text = 'Equilibrium'
  , color = TRANSPARENT_COLOR
  , textcolor = eqColor
  , style = label.style_label_left
  , size = size.small)

var discount = box.new(na, na, na, na
  , bgcolor = color.new(discountColor, 80)
  , border_color = na)

var discount_lbl = label.new(na, na
  , text = 'Discount'
  , color = TRANSPARENT_COLOR
  , textcolor = discountColor
  , style = label.style_label_up
  , size = size.small)

// Show Premium/Discount Areas
if barstate.islast and pdzShowed
    avg = math.avg(trail_up, trail_dn)

    box.set_lefttop(premium, math.max(top_x, btm_x), trail_up)
    box.set_rightbottom(premium, barIdx, .95 * trail_up + .05 * trail_dn)

    label.set_xy(premium_lbl, int(math.avg(math.max(top_x, btm_x), barIdx)), trail_up)

    box.set_lefttop(eq, math.max(top_x, btm_x), .525 * trail_up + .475*trail_dn)
    box.set_rightbottom(eq, barIdx, .525 * trail_dn + .475 * trail_up)

    label.set_xy(eq_lbl, barIdx, avg)
    
    box.set_lefttop(discount, math.max(top_x, btm_x), .95 * trail_dn + .05 * trail_up)
    box.set_rightbottom(discount, barIdx, trail_dn)
    label.set_xy(discount_lbl, int(math.avg(math.max(top_x, btm_x), barIdx)), trail_dn)

//-----------------------------------------------------------------------------}
// Trend
//-----------------------------------------------------------------------------{
var color trend_css = na

if trendShowed
    if style == 'Colored'
        trend_css := itrend == 1 ? bull_css : bear_css
    else if style == 'Monochrome'
        trend_css := itrend == 1 ? #b2b5be : #5d606b

plotcandle(open, high, low, close
  , color = trend_css
  , wickcolor = trend_css
  , bordercolor = trend_css
  , editable = false)

//-----------------------------------------------------------------------------}
// Alerts
//-----------------------------------------------------------------------------{
// Internal Structure
alertcondition(bull_ibos_alert, 'Internal Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bull_ichoch_alert, 'Internal Bullish CHoCH', 'Internal Bullish CHoCH formed')

alertcondition(bear_ibos_alert, 'Internal Bearish BOS', 'Internal Bearish BOS formed')
alertcondition(bear_ichoch_alert, 'Internal Bearish CHoCH', 'Internal Bearish CHoCH formed')

// Swing Structure
alertcondition(bull_bos_alert, 'Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bull_choch_alert, 'Bullish CHoCH', 'Internal Bullish CHoCH formed')

alertcondition(bear_bos_alert, 'Bearish BOS', 'Bearish BOS formed')
alertcondition(bear_choch_alert, 'Bearish CHoCH', 'Bearish CHoCH formed')

// Order Blocks
alertcondition(bull_iob_break, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(bear_iob_break, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')

alertcondition(bull_ob_break, 'Bullish Swing OB Breakout', 'Price broke bullish swing OB')
alertcondition(bear_ob_break, 'Bearish Swing OB Breakout', 'Price broke bearish swing OB')

// EQH/EQL
alertcondition(eqh_alert, 'Equal Highs', 'Equal highs detected')
alertcondition(eql_alert, 'Equal Lows', 'Equal lows detected')

// FVG
alertcondition(bullish_fvg_cnd, 'Bullish FVG', 'Bullish FVG formed')
alertcondition(bearish_fvg_cnd, 'Bearish FVG', 'Bearish FVG formed')

//-----------------------------------------------------------------------------}








//-----------------------------------------------------------------------------*
// Master Pattern
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string mpGrp = 'Master Pattern'
int mpLen = input.int(500, 'Length', minval = 1, maxval = 500, group = mpGrp)
int mpContractionLookback = input.int(3, 'Contraction Detection Lookback', minval = 1, group = mpGrp)
int mpLiqLen = input.int(20, 'Liquidity Levels Length', minval = 1, group = mpGrp)
color mpColor = input.color(PURPLE_COLOR, 'Box & True Value Line Color', group = mpGrp)
bool mpMinorShowed = input(true, 'Show Minor Pattern', group = mpGrp)
bool mpLiqShowed = input(true, 'Show Liquidity Levels', group = mpGrp)
color mpUpperLiqColor = input.color(RED_COLOR, 'Upper Liquidity Color', group = mpGrp)
color mpLowerLiqColor = input.color(AQUA_COLOR, 'Lower Liquidity Color', group = mpGrp)

//-----------------------------------------------------------------------------}
// UDT
//-----------------------------------------------------------------------------{
type MasterPattern
    box area
    line avg
    bool breakup
    bool breakdn

//-----------------------------------------------------------------------------}
// Detect contraction & Liquidity Levels
//-----------------------------------------------------------------------------{
series float mpPh = ta.pivothigh(mpContractionLookback, mpContractionLookback)
series float mpPl = ta.pivotlow(mpContractionLookback, mpContractionLookback)
series float mpLiqPh = ta.pivothigh(mpLiqLen, mpLiqLen)
series float mpLiqPl = ta.pivotlow(mpLiqLen, mpLiqLen)

if last_bar_index - bar_index < mpLen
    var mpPhy = 0., var mpPhx = 0, var mpPht = 0.
    var mpPly = 0., var mpPlx = 0, var mpPlt = 0.
    var float mpTop = na
    var float mpBot = na
    series int mpBarIdx = bar_index

    if not na(mpPh)
        mpPht := math.sign(mpPh - mpPhy)
        mpPhy := mpPh

        if mpPht == -1 and mpPlt == 1
            mpTop := mpPh
            mpBot := mpPly
            mpPhx := mpBarIdx - mpContractionLookback

    if not na(mpPl)
        mpPlt := math.sign(mpPl - mpPly)
        mpPly := mpPl

        if mpPht  == -1 and mpPlt == 1
            mpTop := mpPhy
            mpBot := mpPl
            mpPlx := mpBarIdx - mpContractionLookback

    var MasterPattern master = MasterPattern.new()
    bool mpIsBullish = high[mpContractionLookback] > mpTop and mpTop > mpBot
    bool mpIsBearish = low[mpContractionLookback] < mpBot and mpTop > mpBot

    if mpIsBullish or mpIsBearish
        master.avg.set_x2(mpBarIdx-mpContractionLookback)
        float val = math.avg(mpTop, mpBot)
  
        // Create new master pattern object
        master := MasterPattern.new(
          mpIsBullish or mpIsBearish ? box.new(math.max(mpPhx, mpPlx), mpTop, mpBarIdx-mpContractionLookback, mpBot, na, bgcolor = mpMinorShowed ? color.new(mpColor, 75) : na) : na
          , mpIsBullish or mpIsBearish ? line.new(mpBarIdx-mpContractionLookback, val, mpBarIdx, val, color = mpMinorShowed ? mpColor : na) : na
          , mpIsBullish
          , mpIsBearish)

        mpTop := na
        mpBot := na

    // Determine if pattern switch to major
    if master.breakup
        if low < master.area.get_bottom()
            master.area.set_border_color(mpColor)

            if not mpMinorShowed
                master.area.set_bgcolor(color.new(mpColor, 50))
                master.avg.set_color(mpColor)
    else if master.breakdn
        if high > master.area.get_top()
            master.area.set_border_color(mpColor)

            if not mpMinorShowed
                master.area.set_bgcolor(color.new(mpColor, 50))
                master.avg.set_color(mpColor)

    // Set friction level x2 coordinate to current bar
    if not na(master.avg)
        master.avg.set_x2(mpBarIdx)

    var line mpLiqUp = na, var liqupReached = false
    var line mpLiqDn = na, var liqdnReached = false

    // Set upper liquidity
    if not na(mpLiqPh) and mpLiqShowed
        if not liqupReached
            mpLiqUp.set_x2(mpBarIdx-mpLiqLen)

        mpLiqUp := line.new(mpBarIdx-mpLiqLen, mpLiqPh, mpBarIdx, mpLiqPh, color = mpUpperLiqColor, style = line.style_dotted)
        liqupReached := false
    else if not liqupReached and mpLiqShowed
        mpLiqUp.set_x2(mpBarIdx)

        if high > mpLiqUp.get_y1()
            liqupReached := true

    // Set lower liquidity
    if not na(mpLiqPl) and mpLiqShowed
        if not liqdnReached
            mpLiqDn.set_x2(mpBarIdx-mpLiqLen)

        mpLiqDn := line.new(mpBarIdx-mpLiqLen, mpLiqPl, mpBarIdx, mpLiqPl, color = mpLowerLiqColor, style = line.style_dotted)
        liqdnReached := false
    else if not liqdnReached and mpLiqShowed
        mpLiqDn.set_x2(mpBarIdx)

        if low < mpLiqDn.get_y1()
            liqdnReached := true

//-----------------------------------------------------------------------------}