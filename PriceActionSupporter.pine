// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tamth_

// @version=5
indicator("Price Action Supporter", "Price Action Supporter", overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, max_bars_back = 500)


//-----------------------------------------------------------------------------*
//  Constants
//-----------------------------------------------------------------------------{
color TRANSPARENT_COLOR = #ffffff00
color WHITE_COLOR = #ffffff
color RED_COLOR = #e91e62
color AQUA_COLOR = #00bbf9
color LIGHT_GRAY_COLOR = #364156
color DARK_GRAY_COLOR = #212d40
color GREEN_COLOR = #008170
color PURPLE_COLOR = #764AF1
color YELLOW_COLOR = #f2e40a
color ORANGE_COLOR = #f2aa0a

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Common Functions
//-----------------------------------------------------------------------------{
debug(simple string txt) =>
    // Create label on the first bar
    var label = label.new(bar_index, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, WHITE_COLOR, size.large, text.align_left)
    // On next bars, update the label"s x and y position, and the text it displays
    label.set_xy(label, bar_index, ta.highest(10)[1])
    label.set_text(label, txt)

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Common Variables
//-----------------------------------------------------------------------------{
series int barIdx = bar_index

//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// General Settings
//-----------------------------------------------------------------------------{
string generalGrp = 'General'
int generalLen = input.int(500, 'Length', minval = 1, maxval = 500, group = generalGrp, tooltip = "Number of most recent bars to use for the calculation of supporter")

bool shouldDisplay = last_bar_index - bar_index < generalLen
//-----------------------------------------------------------------------------}


//-----------------------------------------------------------------------------*
// Volume Profile
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string vpGrp = "Volume Profile"
int vpLen = input.int(200, "Lookback", minval = 1, maxval = 500, tooltip = "Number of most recent bars", group = vpGrp)
int vpLevelsSize = input.int(400, "Size Of Levels", minval = 1, maxval = 400, group = vpGrp)
int vpWidth = input.int(20, "Profile's Width", minval = 1, maxval = 100, tooltip = "The length of the bars relative to the Lookback value", group = vpGrp)
int vpBarWidth = input.int(2, "Bar's Width", tooltip = "Width of each bar", group = vpGrp)
int vpOffset = input.int(24, "Offset From Last Bar", group = vpGrp)
color vpColor = input.color(DARK_GRAY_COLOR, "Color", group = vpGrp)

//-----------------------------------------------------------------------------}
// Render Volume Profile
//-----------------------------------------------------------------------------{
var vpLines = array.new_line()

if barstate.isfirst
    for i = 0 to vpLevelsSize - 1
        array.push(vpLines, line.new(na, na, na, na, width = 2))

series float vpHighest = ta.highest(vpLen)
series float vpLowest = ta.lowest(vpLen)
array<float> vpLevels = array.new_float(0)
array<int> vpVols = array.new_int(0)
array<float> vpSumv = array.new_float(0)
line vpLine = na

if barstate.islast
    for i = 0 to vpLevelsSize
        array.push(vpLevels, vpLowest + i / vpLevelsSize * (vpHighest - vpLowest))

    for i = 0 to vpLevelsSize - 1
        series float sum = 0.

        for j = 0 to vpLen - 1
            sum := high[j] > array.get(vpLevels, i) and low[j] < array.get(vpLevels, i + 1) ? sum + volume[j] : sum

        array.push(vpSumv, sum)


    for i = 0 to vpLevelsSize - 1
        series float mult = array.get(vpSumv, i) / array.max(vpSumv)
        series int vol = math.round(vpLen * vpWidth / 100 * mult)
        array.push(vpVols, vol)
    
    series int maxVol = array.max(vpVols)
    int shift = barIdx + maxVol + vpOffset

    for i = 0 to vpLevelsSize - 1
        series int vol = array.get(vpVols, i)
        series float level = array.get(vpLevels, i)
        vpLine := array.get(vpLines, i)
        line.set_xy1(vpLine, shift, level)
        line.set_xy2(vpLine, shift - vol, level)
        line.set_color(vpLine, vpColor)
        line.set_width(vpLine, vpBarWidth)

//-----------------------------------------------------------------------------}





//-----------------------------------------------------------------------------*
// Smart Money Concepts
//-----------------------------------------------------------------------------*
// Tooltips
//-----------------------------------------------------------------------------{
string MODE_TOOLTIP          = 'Allows to display historical Structure or only the recent ones'
string STYLE_TOOLTIP         = 'Indicator color theme'
string COLOR_CANDLES_TOOLTIP = 'Display additional candles with a color reflecting the current trend detected by structure'
string SHOW_INTERNAL         = 'Display internal market structure'
string CONFLUENCE_FILTER     = 'Filter non significant internal structure breakouts'
string SHOW_SWING            = 'Display swing market Structure'
string SHOW_SWING_POINTS     = 'Display swing point as labels on the chart'
string SHOW_SWHL_POINTS      = 'Highlight most recent strong and weak high/low points on the chart'
string INTERNAL_OB           = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
string SWING_OB              = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
string FILTER_OB             = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
string SHOW_EQHL             = 'Display equal highs and equal lows on the chart'
string EQHL_BARS             = 'Number of bars used to confirm equal highs and equal lows'
string EQHL_THRESHOLD        = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
string SHOW_FVG              = 'Display fair values gaps on the chart'
string AUTO_FVG              = 'Filter out non significant fair value gaps'
string FVG_TF                = 'Fair value gaps timeframe'
string EXTEND_FVG            = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
string PED_ZONES             = 'Display premium, discount, and equilibrium zones on chart'

//-----------------------------------------------------------------------------}
// Settings
//-----------------------------------------------------------------------------{
// General
//----------------------------------------{
string mode = input.string('Historical'
  , options = ['Historical', 'Present']
  , group = 'Smart Money Concepts'
  , tooltip = MODE_TOOLTIP)

string style = input.string('Colored'
  , options = ['Colored', 'Monochrome']
  , group = 'Smart Money Concepts'
  , tooltip = STYLE_TOOLTIP)

bool trendShowed = input.bool(false, 'Color Candles'
  , group = 'Smart Money Concepts'
  , tooltip = COLOR_CANDLES_TOOLTIP)

//----------------------------------------}
// Internal Structure
//----------------------------------------{
bool iStructureShowed = input.bool(true, 'Show Internal Structure'
  , group = 'Real Time Internal Structure'
  , tooltip = SHOW_INTERNAL)

string iBullShowed = input.string('All', 'Bullish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'ibull'
  , group = 'Real Time Internal Structure')

color iBullColor = input.color(AQUA_COLOR, ''
  , inline = 'ibull'
  , group = 'Real Time Internal Structure')

string iBearShowed = input.string('All', 'Bearish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'ibear'
  , group = 'Real Time Internal Structure')

color iBearColor = input.color(RED_COLOR, ''
  , inline = 'ibear'
  , group = 'Real Time Internal Structure')

bool iConfluenceFiltered = input.bool(false, 'Confluence Filter'
  , group = 'Real Time Internal Structure'
  , tooltip = CONFLUENCE_FILTER)

string iStructureSize = input.string('Tiny', 'Internal Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'Real Time Internal Structure')

//----------------------------------------}
// Swing Structure
//----------------------------------------{
bool sStructureShowed = input.bool(true, 'Show Swing Structure'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWING)

string sBullShowed = input.string('All', 'Bullish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'bull'
  , group = 'Real Time Swing Structure')

color sBullColor = input.color(AQUA_COLOR, ''
  , inline = 'bull'
  , group = 'Real Time Swing Structure')

string sBearShowed = input.string('All', 'Bearish Structure'
  , options = ['All', 'BOS', 'CHoCH']
  , inline = 'bear'
  , group = 'Real Time Swing Structure')

color sBearColor = input.color(RED_COLOR, ''
  , inline = 'bear'
  , group = 'Real Time Swing Structure')

string sStructureSize = input.string('Small', 'Swing Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'Real Time Swing Structure')

bool swingsPointsShowed = input.bool(false, 'Show Swings Points'
  , inline = 'swings'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWING_POINTS)

int swingLen = input.int(50, ''
  , minval = 10
  , inline = 'swings'
  , group = 'Real Time Swing Structure')

bool hlSwingsShowed = input.bool(true, 'Show Strong/Weak High/Low'
  , group = 'Real Time Swing Structure'
  , tooltip = SHOW_SWHL_POINTS)

//----------------------------------------}
// Order Blocks
//----------------------------------------{
bool iobShowed = input.bool(true, 'Internal Order Blocks'
  , inline = 'iob'
  , group = 'Order Blocks'
  , tooltip = INTERNAL_OB)

int numOfIobs = input.int(5, ''
  , minval = 1
  , inline = 'iob'
  , group = 'Order Blocks')

bool sobShowed = input.bool(false, 'Swing Order Blocks'
  , inline = 'ob'
  , group = 'Order Blocks'
  , tooltip = SWING_OB)

int numOfSobs = input.int(5, ''
  , minval = 1
  , inline = 'ob'
  , group = 'Order Blocks')

string obFilter = input.string('Atr', 'Order Block Filter'
  , options = ['Atr', 'Cumulative Mean Range']
  , group = 'Order Blocks'
  , tooltip = FILTER_OB)

color iobBullColor = input.color(color.new(AQUA_COLOR, 85), 'Internal Bullish OB'
  , group = 'Order Blocks')

color iobBearColor = input.color(color.new(RED_COLOR, 85), 'Internal Bearish OB'
  , group = 'Order Blocks')

color sobBullColor = input.color(color.new(AQUA_COLOR, 85), 'Bullish OB'
  , group = 'Order Blocks')

color sobBearColor = input.color(color.new(RED_COLOR, 85), 'Bearish OB'
  , group = 'Order Blocks')

//----------------------------------------}
// EQH/EQL
//----------------------------------------{
bool eqShowed = input.bool(true, 'Equal High/Low'
  , group = 'EQH/EQL'
  , tooltip = SHOW_EQHL)

int eqLen = input.int(3, 'Bars Confirmation'
  , minval = 1
  , group = 'EQH/EQL'
  , tooltip = EQHL_BARS)

float eqThreshold = input.float(0.1, 'Threshold'
  , minval = 0
  , maxval = 0.5
  , step = 0.1
  , group = 'EQH/EQL'
  , tooltip = EQHL_THRESHOLD)

string eqSize = input.string('Tiny', 'Label Size'
  , options = ['Tiny', 'Small', 'Normal']
  , group = 'EQH/EQL')

//----------------------------------------}
// Fair Value Gaps
//----------------------------------------{
bool fvgShowed = input.bool(true, 'Fair Value Gaps'
  , group = 'Fair Value Gaps'
  , tooltip = SHOW_FVG)
  
bool fvgAuto = input.bool(true, "Auto Threshold"
  , group = 'Fair Value Gaps'
  , tooltip = AUTO_FVG)

var fvgTf = input.timeframe('', "Timeframe"
  , group = 'Fair Value Gaps'
  , tooltip = FVG_TF)

color fvgBullColor = input.color(color.new(AQUA_COLOR, 70), 'Bullish FVG'
  , group = 'Fair Value Gaps')

color fvgBearColor = input.color(color.new(RED_COLOR, 70), 'Bearish FVG'
  , group = 'Fair Value Gaps')

int fvgExtend = input.int(1, "Extend FVG"
  , minval = 0
  , group = 'Fair Value Gaps'
  , tooltip = EXTEND_FVG)

//----------------------------------------}
// Previous day/week high/low
//----------------------------------------{
// Daily
bool pdhlShowed = input.bool(false, 'Daily'
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

string pdhlStyle = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

color pdhlColor = input.color(YELLOW_COLOR, ''
  , inline = 'daily'
  , group = 'Highs & Lows MTF')

// Weekly
bool pwhlShowed = input.bool(false, 'Weekly'
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

string pwhlStyle = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

color pwhlColor = input.color(YELLOW_COLOR, ''
  , inline = 'weekly'
  , group = 'Highs & Lows MTF')

// Monthly
bool pmhlShowed = input.bool(false, 'Monthly'
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

string pmhlStyle = input.string('⎯⎯⎯', ''
  , options = ['⎯⎯⎯', '----', '····']
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

color pmhlColor = input.color(YELLOW_COLOR, ''
  , inline = 'monthly'
  , group = 'Highs & Lows MTF')

//----------------------------------------}
// Premium/Discount zones
//----------------------------------------{
bool pdzShowed = input.bool(true, 'Premium/Discount Zones'
  , group = 'Premium & Discount Zones'
  , tooltip = PED_ZONES)


color pdzBgColor = input.color(#5d606b19, 'Background Color', group = 'Premium & Discount Zones')

color pdzTextColor = input.color(#787b86, 'Text Color', group = 'Premium & Discount Zones')

//-----------------------------------------------------------------------------}
// Functions
//-----------------------------------------------------------------------------{
series float atr = ta.atr(200)
series float cmean_range = ta.cum(high - low) / barIdx

// HL Output
getHL() => [high, low]

// Get ohlc values
getOHLC()=> [close[1], open[1], high, low, high[2], low[2]]

// Display structure
displayStructure(series int x, series float y, string txt, color color, bool dashed, bool down, string lblSize)=>
    line structureLine = line.new(x, y, barIdx, y, color = color, style = dashed ? line.style_dashed : line.style_solid)
    label structureLbl = label.new(int(math.avg(x, barIdx)), y, txt, color = TRANSPARENT_COLOR, textcolor = color, style = down ? label.style_label_down : label.style_label_up, size = lblSize)

    if mode == 'Present'
        line.delete(structureLine[1])
        label.delete(structureLbl[1])

// Swings detection/measurements
getSwings(int len)=>
    var os = 0
    series float upper = ta.highest(len)
    series float lower = ta.lowest(len)
    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]
    float top = os == 0 and os[1] != 0 ? high[len] : 0
    float btm = os == 1 and os[1] != 1 ? low[len] : 0

    [top, btm]

// Order block coordinates function
getObCoord(bool maxUsed, series int loc, array<float> targetTop, array<float> targetBtm, array<int> targetLeft, array<int> targetType) =>
    float min = 99999999.
    float max = 0.
    int idx = 1
    series float ob_threshold = obFilter == 'Atr' ? atr : cmean_range 

    // Search for highest/lowest high within the structure interval and get range
    if maxUsed
        for i = 1 to (barIdx - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                max := math.max(high[i], max)
                min := max == high[i] ? low[i] : min
                idx := max == high[i] ? i : idx
    else
        for i = 1 to (barIdx - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                min := math.min(low[i], min)
                max := min == low[i] ? high[i] : max
                idx := min == low[i] ? i : idx

    array.unshift(targetTop, max)
    array.unshift(targetBtm, min)
    array.unshift(targetLeft, time[idx])
    array.unshift(targetType, maxUsed ? -1 : 1)

// Set order blocks
displayOb(array<box> boxes, array<float> targetTop, array<float> targetBtm, array<int> targetLeft, array<int> targetType, int lastShowed, bool swing, series int size)=>
    for i = 0 to math.min(lastShowed - 1, size - 1)
        box box = array.get(boxes, i)
        box.set_lefttop(box, array.get(targetLeft, i), array.get(targetTop, i))
        box.set_rightbottom(box, time[0], array.get(targetBtm, i))
        color contractionColor = na
        
        if swing 
            if style == 'Monochrome'
                contractionColor := array.get(targetType, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
                borderColor = array.get(targetType, i) == 1 ? #b2b5be : #5d606b
                box.set_border_color(box, borderColor)
            else
                contractionColor := array.get(targetType, i) == 1 ? sobBullColor : sobBearColor
                box.set_border_color(box, contractionColor)

            box.set_bgcolor(box, contractionColor)
        else
            if style == 'Monochrome'
                contractionColor := array.get(targetType, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
            else
                contractionColor := array.get(targetType, i) == 1 ? iobBullColor : iobBearColor
            
            box.set_border_color(box, contractionColor)
            box.set_bgcolor(box, contractionColor)

        
// Line Style function
getLineStyle(string style) =>
    string out = switch style
        '⎯⎯⎯'  => line.style_solid
        '----' => line.style_dashed
        '····' => line.style_dotted

// Set line/labels function for previous high/lows
getPHL(series float h, series float l, string tf, color css)=>
    var line highLine = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = getLineStyle(pdhlStyle))
    var label highLbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format('P{0}H', tf)
      , color = TRANSPARENT_COLOR
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)
    var line lowLine = line.new(na,na,na,na
      , xloc = xloc.bar_time
      , color = css
      , style = getLineStyle(pdhlStyle))
    var label lowLbl = label.new(na,na
      , xloc = xloc.bar_time
      , text = str.format('P{0}L', tf)
      , color = TRANSPARENT_COLOR
      , textcolor = css
      , size = size.small
      , style = label.style_label_left)

    series float hy = ta.valuewhen(h != h[1], h, 1)
    series int hx = ta.valuewhen(h == high, time, 1)
    series float ly = ta.valuewhen(l != l[1], l, 1)
    series int lx = ta.valuewhen(l == low, time, 1)

    if barstate.islast
        series int ext = time + (time - time[1]) * 20
        //High
        line.set_xy1(highLine, hx, hy)
        line.set_xy2(highLine, ext, hy)
        label.set_xy(highLbl, ext, hy)
        //Low
        line.set_xy1(lowLine, lx, ly)
        line.set_xy2(lowLine, ext, ly)
        label.set_xy(lowLbl, ext, ly)

//-----------------------------------------------------------------------------}
// Global variables
//-----------------------------------------------------------------------------{
var trend = 0, var itrend = 0
var topY = 0., var topX = 0
var btmY = 0., var btmX = 0
var iTopY = 0., var iTopX = 0
var iBtmY = 0., var iBtmX = 0
var trailUp = high, var trailDn = low
var trailUpX = 0,  var trailDnX = 0
var topCross = true,  var btmCross = true
var iTopCross = true, var iBtmCross = true
var txtTop = '',  var txtBtm = ''

// Alerts
bool bullChochAlert = false 
bool bullBosAlert   = false 
bool bearChochAlert = false 
bool bearBosAlert   = false 
bool bullIChochAlert = false 
bool bullIBosAlert   = false 
bool bearIChochAlert = false 
bool bearIBosAlert   = false 
bool bullIObBreak = false 
bool bearIObBreak = false
bool bullObBreak = false 
bool bearObBreak = false
bool eqhAlert = false 
bool eqlAlert = false 

// Structure colors
var bull_css = style == 'Monochrome' ? #b2b5be 
  : sBullColor
var bear_css = style == 'Monochrome' ? #b2b5be 
  : sBearColor
var ibull_css = style == 'Monochrome' ? #b2b5be 
  : iBullColor
var ibear_css = style == 'Monochrome' ? #b2b5be 
  : iBearColor

// Labels size
var internal_structureLblSize = iStructureSize == 'Tiny' 
  ? size.tiny 
  : iStructureSize == 'Small' 
  ? size.small 
  : size.normal 
var swing_structureLblSize = sStructureSize == 'Tiny' 
  ? size.tiny 
  : sStructureSize == 'Small' 
  ? size.small 
  : size.normal 
var eqhl_lblSize = eqSize == 'Tiny' 
  ? size.tiny 
  : eqSize == 'Small' 
  ? size.small
  : size.normal 

// Swings
[top, btm] = getSwings(swingLen)
[itop, ibtm] = getSwings(5)

//-----------------------------------------------------------------------------}
// Pivot High
//-----------------------------------------------------------------------------{
var line extendTop = na
var label extendTopLbl = label.new(na, na
  , color = TRANSPARENT_COLOR
  , textcolor = bear_css
  , style = label.style_label_down
  , size = size.tiny)

if top
    topCross := true
    txtTop := top > topY ? 'HH' : 'LH'

    if swingsPointsShowed
        top_lbl = label.new(barIdx - swingLen, top, txtTop
          , color = TRANSPARENT_COLOR
          , textcolor = bear_css
          , style = label.style_label_down
          , size = swing_structureLblSize)

        if mode == 'Present'
            label.delete(top_lbl[1])

    // Extend recent top to last bar
    line.delete(extendTop[1])
    extendTop := line.new(barIdx - swingLen, top, barIdx, top, color = bear_css)
    topY := top
    topX := barIdx - swingLen
    trailUp := top
    trailUpX := barIdx - swingLen

if itop
    iTopCross := true
    iTopY := itop
    iTopX := barIdx - 5

// Trailing maximum
trailUp := math.max(high, trailUp)
trailUpX := trailUp == high ? barIdx : trailUpX

// Set top extension label/line
if barstate.islast and hlSwingsShowed
    line.set_xy1(extendTop, trailUpX, trailUp)
    line.set_xy2(extendTop, barIdx + 12, trailUp)
    label.set_x(extendTopLbl, barIdx + 12)
    label.set_y(extendTopLbl, trailUp)
    label.set_text(extendTopLbl, trend < 0 ? 'Strong High' : 'Weak High')

//-----------------------------------------------------------------------------}
// Pivot Low
//-----------------------------------------------------------------------------{
var line extend_btm = na 

var label extend_btm_lbl = label.new(na, na
  , color = TRANSPARENT_COLOR
  , textcolor = bull_css
  , style = label.style_label_up
  , size = size.tiny)

if btm
    btmCross := true
    txtBtm := btm < btmY ? 'LL' : 'HL'
    
    if swingsPointsShowed
        btm_lbl = label.new(barIdx - swingLen, btm, txtBtm
          , color = TRANSPARENT_COLOR
          , textcolor = bull_css
          , style = label.style_label_up
          , size = swing_structureLblSize)

        if mode == 'Present'
            label.delete(btm_lbl[1])
    
    // Extend recent btm to last bar
    line.delete(extend_btm[1])
    extend_btm := line.new(barIdx - swingLen, btm, barIdx, btm, color = bull_css)
    btmY := btm
    btmX := barIdx - swingLen
    trailDn := btm
    trailDnX := barIdx - swingLen

if ibtm
    iBtmCross := true
    iBtmY := ibtm
    iBtmX := barIdx - 5

// Trailing minimum
trailDn := math.min(low, trailDn)
trailDnX := trailDn == low ? barIdx : trailDnX

// Set btm extension label/line
if barstate.islast and hlSwingsShowed
    line.set_xy1(extend_btm, trailDnX, trailDn)
    line.set_xy2(extend_btm, barIdx + 12, trailDn)
    label.set_x(extend_btm_lbl, barIdx + 12)
    label.set_y(extend_btm_lbl, trailDn)
    label.set_text(extend_btm_lbl, trend > 0 ? 'Strong Low' : 'Weak Low')

//-----------------------------------------------------------------------------}
// Order Blocks Arrays
//-----------------------------------------------------------------------------{
var iobTop = array.new_float(0)
var iobBtm = array.new_float(0)
var iobLeft = array.new_int(0)
var iobType = array.new_int(0)
var obTop = array.new_float(0)
var obBtm = array.new_float(0)
var obLeft = array.new_int(0)
var obType = array.new_int(0)

//-----------------------------------------------------------------------------}
// Pivot High BOS/CHoCH
//-----------------------------------------------------------------------------{
// Filtering
var bullConcordant = true

if iConfluenceFiltered
    bullConcordant := high - math.max(close, open) > math.min(close, open - low)

// Detect internal bullish Structure
if ta.crossover(close, iTopY) and iTopCross and topY != iTopY and bullConcordant
    bool choch = na
    
    if itrend < 0
        choch := true
        bullIChochAlert := true
    else 
        bullIBosAlert := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    if iStructureShowed
        if (iBullShowed == 'All' or (iBullShowed == 'BOS' and not choch) or (iBullShowed == 'CHoCH' and choch)) and shouldDisplay
            displayStructure(iTopX, iTopY, txt, ibull_css, true, true, internal_structureLblSize)
    
    iTopCross := false
    itrend := 1
    
    // Internal Order Block
    if iobShowed
        getObCoord(false, iTopX, iobTop, iobBtm, iobLeft, iobType)

// Detect bullish Structure
if ta.crossover(close, topY) and topCross
    bool choch = na
    
    if trend < 0
        choch := true
        bullChochAlert := true
    else 
        bullBosAlert := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    if sStructureShowed
        if (sBullShowed == 'All' or (sBullShowed == 'BOS' and not choch) or (sBullShowed == 'CHoCH' and choch)) and shouldDisplay
            displayStructure(topX, topY, txt, bull_css, false, true, swing_structureLblSize)
    
    // Order Block
    if sobShowed
        getObCoord(false, topX, obTop, obBtm, obLeft, obType)

    topCross := false
    trend := 1

//-----------------------------------------------------------------------------}
// Pivot Low BOS/CHoCH
//-----------------------------------------------------------------------------{
var bear_concordant = true

if iConfluenceFiltered
    bear_concordant := high - math.max(close, open) < math.min(close, open - low)

// Detect internal bearish Structure
if ta.crossunder(close, iBtmY) and iBtmCross and btmY != iBtmY and bear_concordant
    bool choch = false
    
    if itrend > 0
        choch := true
        bearIChochAlert := true
    else 
        bearIBosAlert := true
    
    string txt = choch ? 'CHoCH' : 'BOS'

    if iStructureShowed
        if (iBearShowed == 'All' or (iBearShowed == 'BOS' and not choch) or (iBearShowed == 'CHoCH' and choch)) and shouldDisplay
            displayStructure(iBtmX, iBtmY, txt, ibear_css, true, false, internal_structureLblSize)
    
    iBtmCross := false
    itrend := -1
    
    // Internal Order Block
    if iobShowed
        getObCoord(true, iBtmX, iobTop, iobBtm, iobLeft, iobType)

// Detect bearish Structure
if ta.crossunder(close, btmY) and btmCross
    bool choch = na
    
    if trend > 0
        choch := true
        bearChochAlert := true
    else 
        bearBosAlert := true

    string txt = choch ? 'CHoCH' : 'BOS'
    
    if sStructureShowed
        if (sBearShowed == 'All' or (sBearShowed == 'BOS' and not choch) or (sBearShowed == 'CHoCH' and choch))  and shouldDisplay
            displayStructure(btmX, btmY, txt, bear_css, false, false, swing_structureLblSize)
    
    // Order Block
    if sobShowed
        getObCoord(true, btmX, obTop, obBtm, obLeft, obType)

    btmCross := false
    trend := -1

//-----------------------------------------------------------------------------}
// Order Blocks
//-----------------------------------------------------------------------------{
// Set order blocks
var iobBoxes = array.new_box(0)
var obBoxes = array.new_box(0)

// Delete internal order blocks box coordinates if top/bottom is broken
for element in iobType
    series int idx = array.indexof(iobType, element)

    if close < array.get(iobBtm, idx) and element == 1
        array.remove(iobTop, idx) 
        array.remove(iobBtm, idx) 
        array.remove(iobLeft, idx) 
        array.remove(iobType, idx)
        bullIObBreak := true

    else if close > array.get(iobTop, idx) and element == -1
        array.remove(iobTop, idx) 
        array.remove(iobBtm, idx)
        array.remove(iobLeft, idx) 
        array.remove(iobType, idx)
        bearIObBreak := true

// Delete internal order blocks box coordinates if top/bottom is broken
for element in obType
    series int idx = array.indexof(obType, element)

    if close < array.get(obBtm, idx) and element == 1
        array.remove(obTop, idx) 
        array.remove(obBtm, idx) 
        array.remove(obLeft, idx) 
        array.remove(obType, idx)
        bullObBreak := true

    else if close > array.get(obTop, idx) and element == -1
        array.remove(obTop, idx) 
        array.remove(obBtm, idx)
        array.remove(obLeft, idx) 
        array.remove(obType, idx)
        bearObBreak := true

series int iobSize = array.size(iobType)
series int obSize = array.size(obType)

if barstate.isfirst
    if iobShowed
        for i = 0 to numOfIobs - 1
            array.push(iobBoxes, box.new(na,na,na,na, xloc = xloc.bar_time))
    if sobShowed
        for i = 0 to numOfSobs - 1
            array.push(obBoxes, box.new(na,na,na,na, xloc = xloc.bar_time))

if iobSize > 0
    if barstate.islast
        displayOb(iobBoxes, iobTop, iobBtm, iobLeft, iobType, numOfIobs, false, iobSize)

if obSize > 0
    if barstate.islast
        displayOb(obBoxes, obTop, obBtm, obLeft, obType, numOfSobs, true, obSize)

//-----------------------------------------------------------------------------}
// EQH/EQL
//-----------------------------------------------------------------------------{
var eqPrevTop = 0.
var eqTopX = 0
var eqPrevBtm = 0.
var eqBtmX = 0

if eqShowed
    series float eqTop = ta.pivothigh(eqLen, eqLen)
    series float eqBtm = ta.pivotlow(eqLen, eqLen)

    if not na(eqTop) 
        max = math.max(eqTop, eqPrevTop)
        min = math.min(eqTop, eqPrevTop)
        
        if max < min + atr * eqThreshold and shouldDisplay
            eqhLine = line.new(eqTopX, eqPrevTop, barIdx - eqLen, eqTop
              , color = bear_css
              , style = line.style_dotted)
            eqhLbl = label.new(int(math.avg(barIdx - eqLen, eqTopX)), eqTop, 'EQH'
              , color = #00000000
              , textcolor = bear_css
              , style = label.style_label_down
              , size = eqhl_lblSize)
            eqhAlert := true

            if mode == 'Present'
                line.delete(eqhLine[1])
                label.delete(eqhLbl[1])
            

        eqPrevTop := eqTop
        eqTopX := barIdx - eqLen

    if not na(eqBtm) 
        max = math.max(eqBtm, eqPrevBtm)
        min = math.min(eqBtm, eqPrevBtm)
        
        if min > max - atr * eqThreshold and shouldDisplay
            eqlLine = line.new(eqBtmX, eqPrevBtm, barIdx - eqLen, eqBtm
              , color = bull_css
              , style = line.style_dotted)
            eqlLbl = label.new(int(math.avg(barIdx - eqLen, eqBtmX)), eqBtm, 'EQL'
              , color = #00000000
              , textcolor = bull_css
              , style = label.style_label_up
              , size = eqhl_lblSize)
            eqlAlert := true

            if mode == 'Present'
                line.delete(eqlLine[1])
                label.delete(eqlLbl[1])

        eqPrevBtm := eqBtm
        eqBtmX := barIdx - eqLen

//-----------------------------------------------------------------------------}
// Fair Value Gaps
//-----------------------------------------------------------------------------{
var bullishFvgMax = array.new_box(0)
var bullishFvgMin = array.new_box(0)
var bearishFvgMax = array.new_box(0)
var bearishFvgMin = array.new_box(0)
float bullishFvgAvg = na
float bearishFvgAvg = na
bool bullishFvgCond = false
bool bearishFvgCond = false

[srcC1, srcO1, srcH, srcL, srcH2, srcL2] = request.security(syminfo.tickerid, fvgTf, getOHLC())

if fvgShowed
    series float delta = (srcC1 - srcO1) / srcO1 * 100
    series bool tfChanged = timeframe.change(fvgTf)
    series float threshold = fvgAuto ? ta.cum(math.abs(tfChanged ? delta : 0)) / barIdx * 2 : 0

    // FVG conditions
    bullishFvgCond := srcL > srcH2
      and srcC1 > srcH2 
      and delta > threshold
      and tfChanged
    bearishFvgCond := srcH < srcL2 
      and srcC1 < srcL2 
      and -delta > threshold
      and tfChanged

    // FVG Areas
    if bullishFvgCond and shouldDisplay
        array.unshift(bullishFvgMax, box.new(barIdx - 1, srcL, barIdx + fvgExtend, math.avg(srcL, srcH2)
          , border_color = fvgBullColor
          , bgcolor = fvgBullColor))
        array.unshift(bullishFvgMin, box.new(barIdx - 1, math.avg(srcL, srcH2), barIdx + fvgExtend, srcH2
          , border_color = fvgBullColor
          , bgcolor = fvgBullColor))
    
    if bearishFvgCond and shouldDisplay
        array.unshift(bearishFvgMax, box.new(barIdx - 1, srcH, barIdx + fvgExtend, math.avg(srcH, srcL2)
          , border_color = fvgBearColor
          , bgcolor = fvgBearColor))
        array.unshift(bearishFvgMin, box.new(barIdx - 1, math.avg(srcH, srcL2), barIdx + fvgExtend, srcL2
          , border_color = fvgBearColor
          , bgcolor = fvgBearColor))

    for bx in bullishFvgMin
        if low < box.get_bottom(bx)
            box.delete(bx)
            box.delete(array.get(bullishFvgMax, array.indexof(bullishFvgMin, bx)))
    
    for bx in bearishFvgMax
        if high > box.get_top(bx)
            box.delete(bx)
            box.delete(array.get(bearishFvgMin, array.indexof(bearishFvgMax, bx)))

//-----------------------------------------------------------------------------}
// Previous day/week high/lows
//-----------------------------------------------------------------------------{
// Daily high/low
[pdh, pdl] = request.security(syminfo.tickerid, 'D', getHL()
  , lookahead = barmerge.lookahead_on)

// Weekly high/low
[pwh, pwl] = request.security(syminfo.tickerid, 'W', getHL()
  , lookahead = barmerge.lookahead_on)

// Monthly high/low
[pmh, pml] = request.security(syminfo.tickerid, 'M', getHL()
  , lookahead = barmerge.lookahead_on)

// Display Daily
if pdhlShowed
    getPHL(pdh, pdl, 'D', pdhlColor)

// Display Weekly
if pwhlShowed
    getPHL(pwh, pwl, 'W', pwhlColor)
    
// Display Monthly
if pmhlShowed
    getPHL(pmh, pml, 'M', pmhlColor)

//-----------------------------------------------------------------------------}
// Premium/Discount/Equilibrium zones
//-----------------------------------------------------------------------------{
var premium = box.new(na, na, na, na, bgcolor = pdzBgColor, border_color = pdzBgColor, border_width = 2)

var premiumLbl = label.new(na, na
  , text = 'Premium'
  , color = TRANSPARENT_COLOR
  , textcolor = pdzTextColor
  , style = label.style_label_down
  , size = size.small)

var eq = box.new(na, na, na, na, bgcolor = pdzBgColor, border_color = pdzBgColor, border_width = 2)

var eqLbl = label.new(na, na
  , text = 'Equilibrium'
  , color = TRANSPARENT_COLOR
  , textcolor = pdzTextColor
  , style = label.style_label_left
  , size = size.small)

var discount = box.new(na, na, na, na, bgcolor = pdzBgColor, border_color = pdzBgColor, border_width = 2)

var discountLbl = label.new(na, na
  , text = 'Discount'
  , color = TRANSPARENT_COLOR
  , textcolor = pdzTextColor
  , style = label.style_label_up
  , size = size.small)

// Show Premium/Discount Areas
if barstate.islast and pdzShowed
    series float avg = math.avg(trailUp, trailDn)
    box.set_lefttop(premium, math.max(topX, btmX), trailUp)
    box.set_rightbottom(premium, barIdx, .95 * trailUp + .05 * trailDn)
    label.set_xy(premiumLbl, int(math.avg(math.max(topX, btmX), barIdx)), trailUp)
    box.set_lefttop(eq, math.max(topX, btmX), .525 * trailUp + .475*trailDn)
    box.set_rightbottom(eq, barIdx, .525 * trailDn + .475 * trailUp)
    label.set_xy(eqLbl, barIdx, avg)
    box.set_lefttop(discount, math.max(topX, btmX), .95 * trailDn + .05 * trailUp)
    box.set_rightbottom(discount, barIdx, trailDn)
    label.set_xy(discountLbl, int(math.avg(math.max(topX, btmX), barIdx)), trailDn)

//-----------------------------------------------------------------------------}
// Trend
//-----------------------------------------------------------------------------{
var color trendColor = na

if trendShowed
    if style == 'Colored'
        trendColor := itrend == 1 ? bull_css : bear_css
    else if style == 'Monochrome'
        trendColor := itrend == 1 ? #b2b5be : #5d606b

plotcandle(open, high, low, close, color = trendColor, wickcolor = trendColor, bordercolor = trendColor, editable = false)

//-----------------------------------------------------------------------------}
// Alerts
//-----------------------------------------------------------------------------{
// Internal Structure
alertcondition(bullIBosAlert, 'Internal Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bullIChochAlert, 'Internal Bullish CHoCH', 'Internal Bullish CHoCH formed')
alertcondition(bearIBosAlert, 'Internal Bearish BOS', 'Internal Bearish BOS formed')
alertcondition(bearIChochAlert, 'Internal Bearish CHoCH', 'Internal Bearish CHoCH formed')

// Swing Structure
alertcondition(bullBosAlert, 'Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bullChochAlert, 'Bullish CHoCH', 'Internal Bullish CHoCH formed')
alertcondition(bearBosAlert, 'Bearish BOS', 'Bearish BOS formed')
alertcondition(bearChochAlert, 'Bearish CHoCH', 'Bearish CHoCH formed')

// Order Blocks
alertcondition(bullIObBreak, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')
alertcondition(bearIObBreak, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')
alertcondition(bullObBreak, 'Bullish Swing OB Breakout', 'Price broke bullish swing OB')
alertcondition(bearObBreak, 'Bearish Swing OB Breakout', 'Price broke bearish swing OB')

// EQH/EQL
alertcondition(eqhAlert, 'Equal Highs', 'Equal highs detected')
alertcondition(eqlAlert, 'Equal Lows', 'Equal lows detected')

// FVG
alertcondition(bullishFvgCond, 'Bullish FVG', 'Bullish FVG formed')
alertcondition(bearishFvgCond, 'Bearish FVG', 'Bearish FVG formed')

//-----------------------------------------------------------------------------}





//-----------------------------------------------------------------------------*
// Master Pattern
//-----------------------------------------------------------------------------*
// Settings
//-----------------------------------------------------------------------------{
string mpGrp = 'Master Pattern'
int mpContractionLookback = input.int(3, 'Contraction Detection Lookback', minval = 1, group = mpGrp)
int mpLiqLen = input.int(20, 'Liquidity Levels Length', minval = 1, group = mpGrp)
color mpColor = input.color(PURPLE_COLOR, 'Box & True Value Line Color', group = mpGrp)
bool mpMinorShowed = input(true, 'Show Minor Pattern', group = mpGrp)
bool mpLiqShowed = input(true, 'Show Liquidity Levels', group = mpGrp)
color mpUpperLiqColor = input.color(AQUA_COLOR, 'Upper Liquidity Color', group = mpGrp)
color mpLowerLiqColor = input.color(RED_COLOR, 'Lower Liquidity Color', group = mpGrp)

//-----------------------------------------------------------------------------}
// UDT
//-----------------------------------------------------------------------------{
type MasterPattern
    box area
    line avg
    bool breakup
    bool breakdn

//-----------------------------------------------------------------------------}
// Detect contraction & Liquidity Levels
//-----------------------------------------------------------------------------{
series float mpPh = ta.pivothigh(mpContractionLookback, mpContractionLookback)
series float mpPl = ta.pivotlow(mpContractionLookback, mpContractionLookback)
series float mpLiqPh = ta.pivothigh(mpLiqLen, mpLiqLen)
series float mpLiqPl = ta.pivotlow(mpLiqLen, mpLiqLen)

if shouldDisplay
    var mpPhy = 0., var mpPhx = 0, var mpPht = 0.
    var mpPly = 0., var mpPlx = 0, var mpPlt = 0.
    var float mpTop = na
    var float mpBot = na
    series int mpBarIdx = bar_index

    if not na(mpPh)
        mpPht := math.sign(mpPh - mpPhy)
        mpPhy := mpPh

        if mpPht == -1 and mpPlt == 1
            mpTop := mpPh
            mpBot := mpPly
            mpPhx := mpBarIdx - mpContractionLookback

    if not na(mpPl)
        mpPlt := math.sign(mpPl - mpPly)
        mpPly := mpPl

        if mpPht  == -1 and mpPlt == 1
            mpTop := mpPhy
            mpBot := mpPl
            mpPlx := mpBarIdx - mpContractionLookback

    var MasterPattern master = MasterPattern.new()
    bool mpIsBullish = high[mpContractionLookback] > mpTop and mpTop > mpBot
    bool mpIsBearish = low[mpContractionLookback] < mpBot and mpTop > mpBot

    if mpIsBullish or mpIsBearish
        master.avg.set_x2(mpBarIdx-mpContractionLookback)
        float val = math.avg(mpTop, mpBot)
  
        // Create new master pattern object
        master := MasterPattern.new(
          mpIsBullish or mpIsBearish ? box.new(math.max(mpPhx, mpPlx), mpTop, mpBarIdx-mpContractionLookback, mpBot, na, bgcolor = mpMinorShowed ? color.new(mpColor, 75) : na) : na
          , mpIsBullish or mpIsBearish ? line.new(mpBarIdx-mpContractionLookback, val, mpBarIdx, val, color = mpMinorShowed ? mpColor : na) : na
          , mpIsBullish
          , mpIsBearish)

        mpTop := na
        mpBot := na

    // Determine if pattern switch to major
    if master.breakup
        if low < master.area.get_bottom()
            master.area.set_border_color(mpColor)

            if not mpMinorShowed
                master.area.set_bgcolor(color.new(mpColor, 50))
                master.avg.set_color(mpColor)
    else if master.breakdn
        if high > master.area.get_top()
            master.area.set_border_color(mpColor)

            if not mpMinorShowed
                master.area.set_bgcolor(color.new(mpColor, 50))
                master.avg.set_color(mpColor)

    // Set friction level x2 coordinate to current bar
    if not na(master.avg)
        master.avg.set_x2(mpBarIdx)

    var line mpLiqUp = na, var liqupReached = false
    var line mpLiqDn = na, var liqdnReached = false

    // Set upper liquidity
    if not na(mpLiqPh) and mpLiqShowed
        if not liqupReached
            mpLiqUp.set_x2(mpBarIdx-mpLiqLen)

        mpLiqUp := line.new(mpBarIdx-mpLiqLen, mpLiqPh, mpBarIdx, mpLiqPh, color = mpUpperLiqColor, style = line.style_dotted)
        liqupReached := false
    else if not liqupReached and mpLiqShowed
        mpLiqUp.set_x2(mpBarIdx)

        if high > mpLiqUp.get_y1()
            liqupReached := true

    // Set lower liquidity
    if not na(mpLiqPl) and mpLiqShowed
        if not liqdnReached
            mpLiqDn.set_x2(mpBarIdx-mpLiqLen)

        mpLiqDn := line.new(mpBarIdx-mpLiqLen, mpLiqPl, mpBarIdx, mpLiqPl, color = mpLowerLiqColor, style = line.style_dotted)
        liqdnReached := false
    else if not liqdnReached and mpLiqShowed
        mpLiqDn.set_x2(mpBarIdx)

        if low < mpLiqDn.get_y1()
            liqdnReached := true

//-----------------------------------------------------------------------------}